[{"categories":["Docker"],"content":"Docker 镜像制作教程：减小镜像体积 原文链接： Docker Images : Part I - Reducing Image Size 对于刚接触容器的人来说，他们很容易被自己制作的 Docker 镜像体积吓到，我只需要一个几 MB 的可执行文件而已，为何镜像的体积会达到 1 GB 以上？本文将会介绍几个奇技淫巧来帮助你精简镜像，同时又不牺牲开发人员和运维人员的操作便利性。本系列文章将分为三个部分： 第一部分着重介绍多阶段构建（multi-stage builds），因为这是镜像精简之路至关重要的一环。在这部分内容中，我会解释静态链接和动态链接的区别，它们对镜像带来的影响，以及如何避免那些不好的影响。中间会穿插一部分对 Alpine 镜像的介绍。链接： Docker 镜像制作教程：减小镜像体积 第二部分将会针对不同的语言来选择适当的精简策略，其中主要讨论 Go，同时也涉及到了 Java，Node，Python，Ruby 和 Rust。这一部分也会详细介绍 Alpine 镜像的避坑指南。什么？你不知道 Alpine 镜像有哪些坑？我来告诉你。链接： Docker 镜像制作教程：针对不同语言的精简策略 第三部分将会探讨适用于大多数语言和框架的通用精简策略，例如使用常见的基础镜像、提取可执行文件和减小每一层的体积。同时还会介绍一些更加奇特或激进的工具，例如 Bazel，Distroless，DockerSlim 和 UPX，虽然这些工具在某些特定场景下能带来奇效，但大多情况下会起到反作用。 本文介绍第一部分。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:0:0","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"1. 万恶之源 我敢打赌，每一个初次使用自己写好的代码构建 Docker 镜像的人都会被镜像的体积吓到，来看一个例子。 让我们搬出那个屡试不爽的 hello world C 程序： /* hello.c */ int main () { puts(\"Hello, world!\"); return 0; } 并通过下面的 Dockerfile 构建镜像： FROM gcc COPY hello.c . RUN gcc -o hello hello.c CMD [\"./hello\"] 然后你会发现构建成功的镜像体积远远超过了 1 GB。。。因为该镜像包含了整个 gcc 镜像的内容。 如果使用 Ubuntu 镜像，安装 C 编译器，最后编译程序，你会得到一个大概 300 MB 大小的镜像，比上面的镜像小多了。但还是不够小，因为编译好的可执行文件还不到 20 KB： $ ls -l hello -rwxr-xr-x 1 root root 16384 Nov 18 14:36 hello 类似地，Go 语言版本的 hello world 会得到相同的结果： package main import \"fmt\" func main () { fmt.Println(\"Hello, world!\") } 使用基础镜像 golang 构建的镜像大小是 800 MB，而编译后的可执行文件只有 2 MB 大小： $ ls -l hello -rwxr-xr-x 1 root root 2008801 Jan 15 16:41 hello 还是不太理想，有没有办法大幅度减少镜像的体积呢？往下看。 为了更直观地对比不同镜像的大小，所有镜像都使用相同的镜像名，不同的标签。例如：hello:gcc，hello:ubuntu，hello:thisweirdtrick 等等，这样就可以直接使用命令 docker images hello 列出所有镜像名为 hello 的镜像，不会被其他镜像所干扰。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:1:0","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"2. 多阶段构建 要想大幅度减少镜像的体积，多阶段构建是必不可少的。多阶段构建的想法很简单：“我不想在最终的镜像中包含一堆 C 或 Go 编译器和整个编译工具链，我只要一个编译好的可执行文件！” 多阶段构建可以由多个 FROM 指令识别，每一个 FROM 语句表示一个新的构建阶段，阶段名称可以用 AS 参数指定，例如： FROM gcc AS mybuildstage COPY hello.c . RUN gcc -o hello hello.c FROM ubuntu COPY --from=mybuildstage hello . CMD [\"./hello\"] 本例使用基础镜像 gcc 来编译程序 hello.c，然后启动一个新的构建阶段，它以 ubuntu 作为基础镜像，将可执行文件 hello 从上一阶段拷贝到最终的镜像中。最终的镜像大小是 64 MB，比之前的 1.1 GB 减少了 95%： 🐳 → docker images minimage REPOSITORY TAG ... SIZE minimage hello-c.gcc ... 1.14GB minimage hello-c.gcc.ubuntu ... 64.2MB 还能不能继续优化？当然能。在继续优化之前，先提醒一下： 在声明构建阶段时，可以不必使用关键词 AS，最终阶段拷贝文件时可以直接使用序号表示之前的构建阶段（从零开始）。也就是说，下面两行是等效的： COPY --from=mybuildstage hello . COPY --from=0 hello . 如果 Dockerfile 内容不是很复杂，构建阶段也不是很多，可以直接使用序号表示构建阶段。一旦 Dockerfile 变复杂了，构建阶段增多了，最好还是通过关键词 AS 为每个阶段命名，这样也便于后期维护。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:2:0","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"使用经典的基础镜像 我强烈建议在构建的第一阶段使用经典的基础镜像，这里经典的镜像指的是 CentOS，Debian，Fedora 和 Ubuntu 之类的镜像。你可能还听说过 Alpine 镜像，不要用它！至少暂时不要用，后面我会告诉你有哪些坑。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:2:1","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"COPY --from 使用绝对路径 从上一个构建阶段拷贝文件时，使用的路径是相对于上一阶段的根目录的。如果你使用 golang 镜像作为构建阶段的基础镜像，就会遇到类似的问题。假设使用下面的 Dockerfile 来构建镜像： FROM golang COPY hello.go . RUN go build hello.go FROM ubuntu COPY --from=0 hello . CMD [\"./hello\"] 你会看到这样的报错： COPY failed: stat /var/lib/docker/overlay2/1be...868/merged/hello: no such file or directory 这是因为 COPY 命令想要拷贝的是 /hello，而 golang 镜像的 WORKDIR 是 /go，所以可执行文件的真正路径是 /go/hello。 当然你可以使用绝对路径来解决这个问题，但如果后面基础镜像改变了 WORKDIR 怎么办？你还得不断地修改绝对路径，所以这个方案还是不太优雅。最好的方法是在第一阶段指定 WORKDIR，在第二阶段使用绝对路径拷贝文件，这样即使基础镜像修改了 WORKDIR，也不会影响到镜像的构建。例如： FROM golang WORKDIR /src COPY hello.go . RUN go build hello.go FROM ubuntu COPY --from=0 /src/hello . CMD [\"./hello\"] 最后的效果还是很惊人的，将镜像的体积直接从 800 MB 降低到了 66 MB： 🐳 → docker images minimage REPOSITORY TAG ... SIZE minimage hello-go.golang ... 805MB minimage hello-go.golang.ubuntu-workdir ... 66.2MB ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:2:2","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"3. FROM scratch 的魔力 回到我们的 hello world，C 语言版本的程序大小为 16 kB，Go 语言版本的程序大小为 2 MB，那么我们到底能不能将镜像缩减到这么小？能否构建一个只包含我需要的程序，没有任何多余文件的镜像？ 答案是肯定的，你只需要将多阶段构建的第二阶段的基础镜像改为 scratch 就好了。scratch 是一个虚拟镜像，不能被 pull，也不能运行，因为它表示空、nothing！这就意味着新镜像的构建是从零开始，不存在其他的镜像层。例如： FROM golang COPY hello.go . RUN go build hello.go FROM scratch COPY --from=0 /go/hello . CMD [\"./hello\"] 这一次构建的镜像大小正好就是 2 MB，堪称完美！ 然而，但是，使用 scratch 作为基础镜像时会带来很多的不便，且听我一一道来。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:3:0","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"缺少 shell scratch 镜像的第一个不便是没有 shell，这就意味着 CMD/RUN 语句中不能使用字符串，例如： ... FROM scratch COPY --from=0 /go/hello . CMD ./hello 如果你使用构建好的镜像创建并运行容器，就会遇到下面的报错： docker: Error response from daemon: OCI runtime create failed: container_linux.go:345: starting container process caused \"exec: \\\"/bin/sh\\\": stat /bin/sh: no such file or directory\": unknown. 从报错信息可以看出，镜像中并不包含 /bin/sh，所以无法运行程序。这是因为当你在 CMD/RUN 语句中使用字符串作为参数时，这些参数会被放到 /bin/sh 中执行，也就是说，下面这两条语句是等效的： CMD ./hello CMD /bin/sh -c \"./hello\" 解决办法其实也很简单 : 使用 JSON 语法取代字符串语法。 例如，将 CMD ./hello 替换为 CMD [\"./hello\"]，这样 Docker 就会直接运行程序，不会把它放到 shell 中运行。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:3:1","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"缺少调试工具 scratch 镜像不包含任何调试工具，ls、ps、ping 这些统统没有，当然了，shell 也没有（上文提过了），你无法使用 docker exec 进入容器，也无法查看网络堆栈信息等等。 如果想查看容器中的文件，可以使用 docker cp；如果想查看或调试网络堆栈，可以使用 docker run --net container:，或者使用 nsenter；为了更好地调试容器，Kubernetes 也引入了一个新概念叫 Ephemeral Containers，但现在还是 Alpha 特性。 虽然有这么多杂七杂八的方法可以帮助我们调试容器，但它们会将事情变得更加复杂，我们追求的是简单，越简单越好。 折中一下可以选择 busybox 或 alpine 镜像来替代 scratch，虽然它们多了那么几 MB，但从整体来看，这只是牺牲了少量的空间来换取调试的便利性，还是很值得的。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:3:2","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"缺少 libc 这是最难解决的问题。使用 scratch 作为基础镜像时，Go 语言版本的 hello world 跑得很欢快，C 语言版本就不行了，或者换个更复杂的 Go 程序也是跑不起来的（例如用到了网络相关的工具包），你会遇到类似于下面的错误： standard_init_linux.go:211: exec user process caused \"no such file or directory\" 从报错信息可以看出缺少文件，但没有告诉我们到底缺少哪些文件，其实这些文件就是程序运行所必需的动态库（dynamic library）。 那么，什么是动态库？为什么需要动态库？ 所谓动态库、静态库，指的是程序编译的链接阶段，链接成可执行文件的方式。静态库指的是在链接阶段将汇编生成的目标文件.o 与引用到的库一起链接打包到可执行文件中，因此对应的链接方式称为静态链接（static linking）。而动态库在程序编译时并不会被连接到目标代码中，而是在程序运行时才被载入，因此对应的链接方式称为动态链接（dynamic linking）。 90 年代的程序大多使用的是静态链接，因为当时的程序大多数都运行在软盘或者盒式磁带上，而且当时根本不存在标准库。这样程序在运行时与函数库再无瓜葛，移植方便。但对于 Linux 这样的分时系统，会在同一块硬盘上并发运行多个程序，这些程序基本上都会用到标准的 C 库，这时使用动态链接的优点就体现出来了。使用动态链接时，可执行文件不包含标准库文件，只包含到这些库文件的索引。例如，某程序依赖于库文件 libtrigonometry.so 中的 cos 和 sin 函数，该程序运行时就会根据索引找到并加载 libtrigonometry.so，然后程序就可以调用这个库文件中的函数。 使用动态链接的好处显而易见： 节省磁盘空间，不同的程序可以共享常见的库。 节省内存，共享的库只需从磁盘中加载到内存一次，然后在不同的程序之间共享。 更便于维护，库文件更新后，不需要重新编译使用该库的所有程序。 严格来说，动态库与共享库（shared libraries）相结合才能达到节省内存的功效。Linux 中动态库的扩展名是 .so（ shared object），而 Windows 中动态库的扩展名是 .DLL（ Dynamic-link library）。 回到最初的问题，默认情况下，C 程序使用的是动态链接，Go 程序也是。上面的 hello world 程序使用了标准库文件 libc.so.6，所以只有镜像中包含该文件，程序才能正常运行。使用 scratch 作为基础镜像肯定是不行的，使用 busybox 和 alpine 也不行，因为 busybox 不包含标准库，而 alpine 使用的标准库是 musl libc，与大家常用的标准库 glibc 不兼容，后续的文章会详细解读，这里就不赘述了。 那么该如何解决标准库的问题呢？有三种方案。 1、使用静态库 我们可以让编译器使用静态库编译程序，办法有很多，如果使用 gcc 作为编译器，只需加上一个参数 -static： $ gcc -o hello hello.c -static 编译完的可执行文件大小为 760 kB，相比于之前的 16kB 是大了好多，这是因为可执行文件中包含了其运行所需要的库文件。编译完的程序就可以跑在 scratch 镜像中了。 如果使用 alpine 镜像作为基础镜像来编译，得到的可执行文件会更小（\u003c 100kB），下篇文章会详述。 2、拷贝库文件到镜像中 为了找出程序运行需要哪些库文件，可以使用 ldd 工具： $ ldd hello linux-vdso.so.1 (0x00007ffdf8acb000) libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007ff897ef6000) /lib64/ld-linux-x86-64.so.2 =\u003e /usr/lib64/ld-linux-x86-64.so.2 (0x00007ff8980f7000) 从输出结果可知，该程序只需要 libc.so.6 这一个库文件。linux-vdso.so.1 与一种叫做 VDSO 的机制有关，用来加速某些系统调用，可有可无。ld-linux-x86-64.so.2 表示动态链接器本身，包含了所有依赖的库文件的信息。 你可以选择将 ldd 列出的所有库文件拷贝到镜像中，但这会很难维护，特别是当程序有大量依赖库时。对于 hello world 程序来说，拷贝库文件完全没有问题，但对于更复杂的程序（例如使用到 DNS 的程序），就会遇到令人费解的问题：glibc（GNU C library）通过一种相当复杂的机制来实现 DNS，这种机制叫 NSS（Name Service Switch, 名称服务开关）。它需要一个配置文件 /etc/nsswitch.conf 和额外的函数库，但使用 ldd 时不会显示这些函数库，因为这些库在程序运行后才会加载。如果想让 DNS 解析正确工作，必须要拷贝这些额外的库文件（/lib64/libnss_*）。 我个人不建议直接拷贝库文件，因为它非常难以维护，后期需要不断地更改，而且还有很多未知的隐患。 3、使用 busybox:glibc 作为基础镜像 有一个镜像可以完美解决所有的这些问题，那就是 busybox:glibc。它只有 5 MB 大小，并且包含了 glibc 和各种调试工具。如果你想选择一个合适的镜像来运行使用动态链接的程序，busybox:glibc 是最好的选择。 注意：如果你的程序使用到了除标准库之外的库，仍然需要将这些库文件拷贝到镜像中。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:3:3","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["Docker"],"content":"4. 总结 最后来对比一下不同构建方法构建的镜像大小： 原始的构建方法：1.14 GB 使用 ubuntu 镜像的多阶段构建：64.2 MB 使用 alpine 镜像和静态 glibc：6.5 MB 使用 alpine 镜像和动态库：5.6 MB 使用 scratch 镜像和静态 glibc：940 kB 使用 scratch 镜像和静态 musl libc：94 kB 最终我们将镜像的体积减少了 99.99%。 但我不建议使用 sratch 作为基础镜像，因为调试起来非常麻烦，但如果你喜欢，我也不会拦着你。 ","date":"2023-11-19","objectID":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/:4:0","tags":["Docker"],"title":"Docker 镜像制作教程:减小镜像体积","uri":"/posts/docker-%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B-%E5%87%8F%E5%B0%8F%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF/"},{"categories":["ElasticSearch"],"content":"一 read_only_allow_delete\" : “true” 当我们在向某个索引添加一条数据的时候，可能（极少情况）会碰到下面的报错： { \"error\": { \"root_cause\": [ { \"type\": \"cluster_block_exception\", \"reason\": \"blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];\" } ], \"type\": \"cluster_block_exception\", \"reason\": \"blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];\" }, \"status\": 403 } 上述报错是说索引现在的状态是只读模式（read-only），如果查看该索引此时的状态： GET z1/_settings # 结果如下 { \"z1\" : { \"settings\" : { \"index\" : { \"number_of_shards\" : \"5\", \"blocks\" : { \"read_only_allow_delete\" : \"true\" }, \"provided_name\" : \"z1\", \"creation_date\" : \"1556204559161\", \"number_of_replicas\" : \"1\", \"uuid\" : \"3PEevS9xSm-r3tw54p0o9w\", \"version\" : { \"created\" : \"6050499\" } } } } } 可以看到\"read_only_allow_delete\" : \"true\"，说明此时无法插入数据，当然，我们也可以模拟出来这个错误： PUT z1 { \"mappings\": { \"doc\": { \"properties\": { \"title\": { \"type\":\"text\" } } } }, \"settings\": { \"index.blocks.read_only_allow_delete\": true } } PUT z1/doc/1 { \"title\": \"es真难学\" } 现在我们如果执行插入数据，就会报开始的错误。那么怎么解决呢？ 清理磁盘，使占用率低于85%。 手动调整该项，具体参考官网 这里介绍一种，我们将该字段重新设置为： PUT z1/_settings { \"index.blocks.read_only_allow_delete\": null } 现在再查看该索引就正常了，也可以正常的插入数据和查询了。 ","date":"2023-08-31","objectID":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:0","tags":["文档操作"],"title":"ElasticSearch常见错误","uri":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["ElasticSearch"],"content":"二 illegal_argument_exception 有时候，在聚合中，我们会发现如下报错： { \"error\": { \"root_cause\": [ { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [age] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } ], \"type\": \"search_phase_execution_exception\", \"reason\": \"all shards failed\", \"phase\": \"query\", \"grouped\": true, \"failed_shards\": [ { \"shard\": 0, \"index\": \"z2\", \"node\": \"NRwiP9PLRFCTJA7w3H9eqA\", \"reason\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [age] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } } ], \"caused_by\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [age] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\", \"caused_by\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [age] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } } }, \"status\": 400 } 这是怎么回事呢？是因为，聚合查询时，指定字段不能是text类型。比如下列示例： PUT z2/doc/1 { \"age\":\"18\" } PUT z2/doc/2 { \"age\":20 } GET z2/doc/_search { \"query\": { \"match_all\": {} }, \"aggs\": { \"my_sum\": { \"sum\": { \"field\": \"age\" } } } } 当我们向elasticsearch中，添加一条数据时（此时，如果索引存在则直接新增或者更新文档，不存在则先创建索引），首先检查该age字段的映射类型。如上示例中，我们添加第一篇文档时（z1索引不存在），elasticsearch会自动的创建索引，然后为age字段创建映射关系（es就猜此时age字段的值是什么类型，如果发现是text类型，那么存储该字段的映射类型就是text），此时age字段的值是text类型，所以，第二条插入数据，age的值也是text类型，而不是我们看到的long类型。我们可以查看一下该索引的mappings信息： GET z2/_mapping # mapping信息如下 { \"z2\" : { \"mappings\" : { \"doc\" : { \"properties\" : { \"age\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } } } } 上述返回结果发现，age类型是text。而该类型又不支持聚合，所以，就会报错了。解决办法就是： 如果选择动态创建一篇文档，映射关系取决于你添加的第一条文档的各字段都对应什么类型。而不是我们看到的那样，第一次是text，第二次不加引号，就是long类型了不是这样的。 如果嫌弃上面的解决办法麻烦，那就选择手动创建映射关系。首先指定好各字段对应什么类型。后续才不至于出错。 ","date":"2023-08-31","objectID":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:2:0","tags":["文档操作"],"title":"ElasticSearch常见错误","uri":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["ElasticSearch"],"content":"三 Result window is too large 很多时候，我们在查询文档时，一次查询结果很可能会有很多，而elasticsearch一次返回多少条结果，由size参数决定： GET e2/doc/_search { \"size\": 100000, \"query\": { \"match_all\": {} } } 而默认是最多范围一万条，那么当我们的请求超过一万条时（比如有十万条），就会报： Result window is too large, from + size must be less than or equal to: [10000] but was [100000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting. 意思是一次请求返回的结果太大，可以另行参考 scroll API或者设置index.max_result_window参数手动调整size的最大默认值： # kibana中设置 PUT e2/_settings { \"index\": { \"max_result_window\": \"100000\" } } # Python中设置 from elasticsearch import Elasticsearch es = Elasticsearch() es.indices.put_settings(index='e2', body={\"index\": {\"max_result_window\": 100000}}) 如上例，我们手动调整索引e2的size参数最大默认值到十万，这时，一次查询结果只要不超过10万就都会一次返回。 注意，这个设置对于索引es的size参数是永久生效的。 ","date":"2023-08-31","objectID":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:3:0","tags":["文档操作"],"title":"ElasticSearch常见错误","uri":"/posts/20-elasticsearch%E4%B9%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":["ElasticSearch"],"content":"一 例子 现在，讲述一个真实的故事！ 故事一定是伴随着赵忠祥老师的声音开始的，雨季就要来临了，又到了动物们发情的季节了… 还记得，之前发生的作家六六吐槽xx的事情吗？对了，有图有真相！上图上图： 身为吃瓜群众，要从专业的角度来分析，就事论事哈： 就搜索结果本身而言，xx返回了正确的结果（是的，人家已经调整了，现在搜没问题！）。因为返回的结果中，都包含了搜索的关键字。而我们从逻辑上来看，这他娘的一堆广告算是咋回事！这个吐槽是从用户的角度出发的。很显然，返回的结果中，尤其是前几条，有时甚至是前几页，都跟我们想要的结果相差深远！ 进一步说，仅仅以二元的方式来考虑文档和查询的匹配可能是有意义的，也就是百度搜索引擎返回了二元的匹配结果：是的，找到了，不，老娘没找到！虽然返回了结果，其中也包含了我们想要的结果，即便你要在大堆的广告中找正确的结果实属不易，但就像大家都习惯了广告中插播电视剧一样，习惯就好嘛！xx从x的角度出发，为广告的词条增加权重，至于那个真正的结果，我擦，你也没给我钱…….. 而需要xx才能访问的xx浏览器，在正确的给用户返回二元结果之前，更多的考虑文档的相关性（relevancy），因为就某个结果而言，如果A文档要比B文档更和结果相关，那么A文档在结果中就要比B文档靠前，再加上以其他的优化，最终将所有结果返回，而用户最期待的那条结果很可能排在最高位，这岂不美哉？ 确定文档和查询有多么相关的过程被称为打分（scoring）。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:1:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"二 文档打分的运作机制：TF-IDF Lucene和es的打分机制是一个公式。将查询作为输入，使用不同的手段来确定每一篇文档的得分，将每一个因素最后通过公式综合起来，返回该文档的最终得分。这个综合考量的过程，就是我们希望相关的文档被优先返回的考量过程。在Lucene和es中这种相关性称为得分。 在开始计算得分之前，es使用了被搜索词条的频率和它有多常见来影响得分，从两个方面理解： 一个词条在某篇文档中出现的次数越多，该文档就越相关。 一个词条如果在不同的文档中出现的次数越多，它就越不相关！ 我们称之为TF-IDF，TF是词频（term frequency），而IDF是逆文档频率（inverse document frequency）。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:2:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"2.1 词频：TF 考虑一篇文档得分的首要方式，是查看一个词条在文档中出现的次数，比如某篇文章围绕es的打分展开的，那么文章中肯定会多次出现相关字眼，当查询时，我们认为该篇文档更符合，所以，这篇文档的得分会更高。 闲的蛋疼的可以Ctrl + f搜一下相关的关键词（es，得分、打分）之类的试试。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:2:1","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"2.2 逆文档频率：IDF 相对于词频，逆文档频率稍显复杂，如果一个词条在索引中的不同文档中出现的次数越多，那么它就越不重要。 来个例子，示例地址： The rules-which require employees to work from 9 am to 9 pm In the weeks that followed the creation of 996.ICU in March The 996.ICU page was soon blocked on multiple platforms including the messaging tool WeChat and the UC Browser. 假如es索引中，有上述3篇文档： 词条ICU的文档频率是2，因为它出现在2篇文档中，文档的逆源自得分乘以1/DF，DF是该词条的文档频率，这就意味着，由于ICU词条拥有更高的文档频率，所以，它的权重会降低。 词条the的文档频率是3，它在3篇文档中都出现了，注意：尽管the在后两篇文档出都出现两次，但是它的词频是还是3，因为，逆文档词频只检查词条是否出现在某篇文档中，而不检查它在这篇文档中出现了多少次，那是词频该干的事儿。 逆文档词频是一个重要的因素，用来平衡词条的词频。比如我们搜索the 996.ICU。单词the几乎出现在所有的文档中（中文中比如的），如果这个鬼东西要不被均衡一下，那么the的频率将完全淹没996.ICU。所以，逆文档词频就有效的均衡了the这个常见词的相关性影响。以达到实际的相关性得分将会对查询的词条有一个更准确地描述。 当词频和逆文档词频计算完成。就可以使用TF-IDF公式来计算文档的得分了。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:2:2","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"三 Lucene评分公式 之前的讨论Lucene默认评分公式被称为TF-IDF，一个基于词频和逆文档词频的公式。Lucene实用评分公式如下： 你以为我会着重介绍这个该死的公式？！ 我只能说，词条的词频越高，得分越高；相似地，索引中词条越罕见，逆文档频率越高，其中再加商调和因子和查询标准化，调和因子考虑了搜索过多少文档以及发现了多少词条；查询标准化，是试图让不同的查询结果具有可比性，这显然…..很困难。 我们称这种默认的打分方法是TF-IDF和向量空间模型（vector space model）的结合。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:3:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"四 其他的打分方法 除了TF-IDF结合向量空间模型的实用评分模式，是es和Lucene最为主流的评分机制，但这并不是唯一的，除了TF-IDF这种实用模型之外，其他的模型包括： Okapi BM25。 随机性分歧（Divergence from randomness），即DFR相似度。 LM Dirichlet相似度。 LM Jelinek Mercer相似度。 这里简要的介绍BM25几种主要设置，即k1、b和discount_overlaps： k1和b是数值的设置，用于调整得分是如何计算的。 k1控制对于得分而言词频（TF）的重要性。 b是介于0 ~ 1之间的数值，它控制了文档篇幅对于得分的影响程度。 默认情况下，k1设置为1.2，而b则被设置为0.75 discount_overlaps的设置用于告诉es，在某个字段中，多少个分词出现在同一位置，是否应该影响长度的标准化，默认值是true。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:4:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"五 配置打分模型 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:5:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"5.1 简要配置BM25打分模型 BM25（是不是跟pm2.5好像！！！）是一种基于概率的打分框架。我们来简要的配置一下： PUT w2 { \"mappings\": { \"doc\": { \"properties\": { \"title\": { \"type\": \"text\", \"similarity\": \"BM25\" } } } } } PUT w2/doc/1 { \"title\":\"The rules-which require employees to work from 9 am to 9 pm\" } PUT w2/doc/2 { \"title\":\"In the weeks that followed the creation of 996.ICU in March\" } PUT w2/doc/3 { \"title\":\"The 996.ICU page was soon blocked on multiple platforms including the messaging tool WeChat and the UC Browser.\" } GET w2/doc/_search { \"query\": { \"match\": { \"title\": \"the 996\" } } } 上例是通过similarity参数来指定打分模型。至于查询，还是当数据量比较大的时候，多试几次，比较容易发现不同之处。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:5:1","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"5.2 为BM25配置高级的settings PUT w3 { \"settings\": { \"index\": { \"analysis\": { \"analyzer\":\"ik_smart\" } }, \"similarity\": { \"my_custom_similarity\": { \"type\": \"BM25\", \"k1\": 1.2, \"b\": 0.75, \"discount_overlaps\": false } } }, \"mappings\": { \"doc\": { \"properties\": { \"title\": { \"type\": \"text\", \"similarity\":\"my_custom_similarity\" } } } } } PUT w3/doc/1 { \"title\":\"The rules-which require employees to work from 9 am to 9 pm\" } PUT w3/doc/2 { \"title\":\"In the weeks that followed the creation of 996.ICU in March\" } PUT w3/doc/3 { \"title\":\"The 996.ICU page was soon blocked on multiple platforms including the messaging tool WeChat and the UC Browser.\" } GET w3/doc/_search { \"query\": { \"match\": { \"title\": \"the 996\" } } } ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:5:2","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"5.3 配置全局打分模型 如果我们要使用某种特定的打分模型，并且希望应用到全局，那么就在elasticsearch.yml配置文件中加入： index.similarity.default.type: BM25 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:5:3","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"六 boosting boosting是一个用来修改文档相关性的程序。boosting有两种类型： 索引的时候，比如我们在定义mappings的时候。 查询一篇文档的时候。 以上两种方式都可以提升一个篇文档的得分。需要注意的是：在索引期间修改的文档boosting是存储在索引中的，要想修改boosting必须重新索引该篇文档。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:6:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"6.1 索引期间的boosting 啥也不说了，都在酒里！上代码： PUT w4 { \"mappings\": { \"doc\": { \"properties\": { \"name\": { \"boost\": 2.0, \"type\": \"text\" }, \"age\": { \"type\": \"long\" } } } } } 一劳永逸是没错，但一般不推荐这么玩。 原因之一是因为一旦映射建立完成，那么所有name字段都会自动拥有一个boost值。要想修改这个值，那就必须重新索引文档。 另一个原因是，boost值是以降低精度的数值存储在Lucene内部的索引结构中。只有一个字节用于存储浮点型数值（存不下就损失精度了），所以，计算文档的最终得分时可能会损失精度。 最后，boost是应用与词条的。因此，再被boost的字段中如果匹配上了多个词条，就意味着计算多次的boost，这将会进一步增加字段的权重，可能会影响最终的文档得分。 现在我们再来介绍另一种方式。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:6:1","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"6.2 查询期间的boosting 在es中，几乎所有的查询类型都支持boost，正如你想象的那些match、multi_match等等。 来个示例，在查询期间，使用match查询进行boosting： PUT w5 { \"mappings\":{ \"doc\":{ \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" }, \"content\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } } } } PUT w5/doc/1 { \"title\":\"Lucene is cool\", \"content\": \"Lucene is cool\" } PUT w5/doc/2 { \"title\":\"Elasticsearch builds on top of lucene\", \"content\":\"Elasticsearch builds on top of lucene\" } PUT w5/doc/3 { \"title\":\"Elasticsearch rocks\", \"content\":\"Elasticsearch rocks\" } 来查询： GET w5/doc/_search { \"query\": { \"bool\": { \"should\": [ { \"match\": { \"title\":{ \"query\": \"elasticserach rocks\", \"boost\": 2.5 } } }, { \"match\": { \"content\": \"elasticserach rocks\" } } ] } } } 就对于最终得分而言，content字段，加了boost的title查询更有影响力。也只有在bool查询中，boost更有意义。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:6:2","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"6.3 跨越多个字段的查询 boost也可以用于multi_match查询。 GET w5/doc/_search { \"query\": { \"multi_match\": { \"query\": \"elasticserach rocks\", \"fields\": [\"title\", \"content\"], \"boost\": 2.5 } } } 除此之外，我们还可以使用特殊的语法，只为特定的字段指定一个boost。通过在字段名称后添加一个^符号和boost的值。告诉es只需对那个字段进行boost： GET w5/doc/_search { \"query\": { \"multi_match\": { \"query\": \"elasticserach rocks\", \"fields\": [\"title^3\", \"content\"] } } } 上例中，title字段被boost了3倍。 需要注意的是：在使用boost的时候，无论是字段或者词条，都是按照相对值来boost的，而不是乘以乘数。如果对于所有的待搜索词条boost了同样的值，那么就好像没有boost一样（废话，就像大家都同时长高一米似的）！因为Lucene会标准化boost的值。如果boost一个字段4倍，不是意味着该字段的得分就是乘以4的结果。所以，如果你的得分不是按照严格的乘法结果，也不要担心。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:6:3","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"七 使用“解释”来理解文档是如何评分的 一切都不是你想的那样！是的，在es中，一个文档要比另一个文档更符合某个查询很可能跟我们想象的不太一样！ 这一小节，我们来研究下es和Lucene内部使用了怎样的公式来计算得分。 我们通过explain=true来告诉es，你要给洒家解释一下为什么这个得分是这样的？！背后到底以有什么py交易！ 比如我们来查询： GET py1/doc/_search { \"query\": { \"match\": { \"title\": \"北京\" } }, \"explain\": true, \"_source\": \"title\", \"size\": 1 } 由于结果太长，我们这里对结果进行了过滤（\"size\": 1返回一篇文档），只查看指定的字段（\"_source\": \"title\"只返回title字段）。 看结果： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 24, \"max_score\" : 4.9223156, \"hits\" : [ { \"_shard\" : \"[py1][1]\", \"_node\" : \"NRwiP9PLRFCTJA7w3H9eqA\", \"_index\" : \"py1\", \"_type\" : \"doc\", \"_id\" : \"NIjS1mkBuoj17MYtV-dX\", \"_score\" : 4.9223156, \"_source\" : { \"title\" : \"大写的尴尬 插混为啥在北京不受待见？\" }, \"_explanation\" : { \"value\" : 4.9223156, \"description\" : \"weight(title:北京 in 36) [PerFieldSimilarity], result of:\", \"details\" : [ { \"value\" : 4.9223156, \"description\" : \"score(doc=36,freq=1.0 = termFreq=1.0\\n), product of:\", \"details\" : [ { \"value\" : 4.562031, \"description\" : \"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:\", \"details\" : [ { \"value\" : 4.0, \"description\" : \"docFreq\", \"details\" : [ ] }, { \"value\" : 430.0, \"description\" : \"docCount\", \"details\" : [ ] } ] }, { \"value\" : 1.0789746, \"description\" : \"tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:\", \"details\" : [ { \"value\" : 1.0, \"description\" : \"termFreq=1.0\", \"details\" : [ ] }, { \"value\" : 1.2, \"description\" : \"parameter k1\", \"details\" : [ ] }, { \"value\" : 0.75, \"description\" : \"parameter b\", \"details\" : [ ] }, { \"value\" : 12.1790695, \"description\" : \"avgFieldLength\", \"details\" : [ ] }, { \"value\" : 10.0, \"description\" : \"fieldLength\", \"details\" : [ ] } ] } ] } ] } } ] } } 在新增的_explanation字段中，可以看到value值是4.9223156，那么是怎么算出来的呢？ 来分析，分词北京在描述字段（title）出现了1次，所以TF的综合得分经过\"description\" : \"tfNorm, computed as (freq * (k1 + 1)) / (freq + k1 * (1 - b + b * fieldLength / avgFieldLength)) from:\"计算，得分是1.0789746。 那么逆文档词频呢？根据\"description\" : \"idf, computed as log(1 + (docCount - docFreq + 0.5) / (docFreq + 0.5)) from:\"计算得分是4.562031。 所以最终得分是： 1.0789746 * 4.562031 = 4.9223155734126 结果在四舍五入后就是4.9223156。 需要注意的是，explain的特性会给es带来额外的性能开销。所以，除了在调试时可以使用，生产环境下，应避免使用explain。 ","date":"2023-08-31","objectID":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/:7:0","tags":["文档操作"],"title":"ElasticSearch打分机制","uri":"/posts/18-elasticsearch%E4%B9%8B%E6%89%93%E5%88%86%E6%9C%BA%E5%88%B6/"},{"categories":["ElasticSearch"],"content":"随着央视诗词大会的热播，小史开始对诗词感兴趣，最喜欢的就是飞花令的环节。 但是由于小史很久没有背过诗词了，飞一个字很难说出一句，很多之前很熟悉的诗句也想不起来。 倒排索引 **吕老师：**但是我让你说出带“前”字的诗句，由于没有索引，你只能遍历脑海中所有诗词，当你的脑海中诗词量大的时候，就很难在短时间内得到结果了。 索引量爆炸 搜索引擎原理 Elasticsearch 简介 **吕老师：**但是 Lucene 还是一个库，必须要懂一点搜索引擎原理的人才能用的好，所以后来又有人基于 Lucene 进行封装，写出了 Elasticsearch。 Elasticsearch 基本概念 **吕老师：**类型是用来定义数据结构的，你可以认为是 MySQL 中的一张表。文档就是最终的数据了，你可以认为一个文档就是一条记录。 **吕老师：**比如一首诗，有诗题、作者、朝代、字数、诗内容等字段，那么首先，我们可以建立一个名叫 Poems 的索引，然后创建一个名叫 Poem 的类型，类型是通过 Mapping 来定义每个字段的类型。 比如诗题、作者、朝代都是 Keyword 类型，诗内容是 Text 类型，而字数是 Integer 类型，最后就是把数据组织成 Json 格式存放进去了。 **吕老师：**这个问题问得好，这涉及到分词的问题，Keyword 类型是不会分词的，直接根据字符串内容建立反向索引，Text 类型在存入 Elasticsearch 的时候，会先分词，然后根据分词后的内容建立反向索引。 **吕老师：**之前我们说过，Elasticsearch 把操作都封装成了 HTTP 的 API，我们只要给 Elasticsearch 发送 HTTP 请求就行。 比如使用 curl -XPUT ‘http://ip:port/poems’，就能建立一个名为 Poems 的索引，其他操作也是类似的。 Elasticsearch 分布式原理 **吕老师：**没错，Elasticsearch 也是会对数据进行切分，同时每一个分片会保存多个副本，其原因和 HDFS 是一样的，都是为了保证分布式环境下的高可用。 **吕老师：**没错，在 Elasticsearch 中，节点是对等的，节点间会通过自己的一些规则选取集群的 Master，Master 会负责集群状态信息的改变，并同步给其他节点。 **吕老师：**注意，只有建立索引和类型需要经过 Master，数据的写入有一个简单的 Routing 规则，可以 Route 到集群中的任意节点，所以数据写入压力是分散在整个集群的。 ELK 系统 **吕老师：**其实很多公司都用 Elasticsearch 搭建 ELK 系统，也就是日志分析系统。其中 E 就是 Elasticsearch，L 是 Logstash，是一个日志收集系统，K 是 Kibana，是一个数据可视化平台。 **吕老师：**分析日志的用处可大了，你想，假如一个分布式系统有 1000 台机器，系统出现故障时，我要看下日志，还得一台一台登录上去查看，是不是非常麻烦？ **吕老师：**但是如果日志接入了 ELK 系统就不一样。比如系统运行过程中，突然出现了异常，在日志中就能及时反馈，日志进入 ELK 系统中，我们直接在 Kibana 就能看到日志情况。如果再接入一些实时计算模块，还能做实时报警功能。 搜索引擎原理 小史学完了 Elasticsearch，在笔记本上写下了如下记录： 反向索引又叫倒排索引，是根据文章内容中的关键字建立索引。 搜索引擎原理就是建立反向索引。 Elasticsearch 在 Lucene 的基础上进行封装，实现了分布式搜索引擎。 Elasticsearch 中的索引、类型和文档的概念比较重要，类似于 MySQL 中的数据库、表和行。 Elasticsearch 也是 Master-slave 架构，也实现了数据的分片和备份。 Elasticsearch 一个典型应用就是 ELK 日志分析系统。 写完，又高高兴兴背诗去了。 ","date":"2023-08-31","objectID":"/posts/16-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/:0:0","tags":["文档操作"],"title":"ElasticSearch倒排索引","uri":"/posts/16-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"},{"categories":["ElasticSearch"],"content":"介绍: 业务需要, 为了增加mysql一张数据库表的查询速率, 特实现es作为传统数据库使用的方案. ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:0:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"django-elasticsearch 的使用 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"一 安装 pip install django-elasticsearch-dsl # 会同时安装 elasticsearch-dsl 和 elasticsearch ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:1","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"二 注册 + 配置 INSTALLED_APPS = [ ... 'django_elasticsearch_dsl', ... ] # Es 配置 ELASTICSEARCH_DSL={ 'default': { 'hosts': 'localhost:9200' }, } ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:2","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"三 创建documents.py文件,做 orm 与 es 索引的映射 # 注意, 在app 目录下创建 documents.py 文件 名字一定要对, 不然执行命令时 会找不到索引 from django_elasticsearch_dsl import Document, fields from django_elasticsearch_dsl.registries import registry from public_app.models import NcInfo @registry.register_document class NcInfoDocument(Document): # 注意命名规范 # 自定义索引字段类型 因为要作为mysql数据库的延伸 , 所以 需要自定义字段为keyword 类型. 否则会被es自动分词 pk = fields.IntegerField() base_product_name = fields.KeywordField() base_standard_model = fields.KeywordField() business_sla_category = fields.KeywordField() ds = fields.KeywordField() ip = fields.KeywordField() ops_azone_id = fields.KeywordField() ops_cluster_id = fields.KeywordField() ops_region_name = fields.KeywordField() business_nc_id = fields.KeywordField() business_instance_family = fields.KeywordField() class Index: name = 'nc_info' settings = { # 设置最大索引深度(**重要) 分页查询时要用到 'max_result_window': 10000000, # 切片个数 'number_of_shards':8, # 保存副本数 'number_of_replicas':2 } class Django: model = NcInfo # 与此文档关联的模型 # 要在Elasticsearch中建立索引的模型的字段 # fields 置空 则会根据上方的对象的属性进行映射, 可直接写orm模型类字段名, 会根据orm中的字段类型进行自动选择文档字段类型 fields = [] # 执行迁移时的 每次从mysql中数据读取的条数. queryset_pagination = 50000 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:3","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"四 执行迁移 python manage.py search_index --rebuild 执行成功后 如下图所示 ![image-20201215113559893](C:\\Users\\zhang\\Desktop\\工作记录\\Elasticsearch 集成 django(传统数据库).assets\\image-20201215113559893.png) ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:4","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"五 查看索引信息 ![image-20201215151341060](C:\\Users\\zhang\\Desktop\\工作记录\\Elasticsearch 集成 django(传统数据库).assets\\image-20201215151341060.png) ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:1:5","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"ElasticSearch 的搭建 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"一 安装JDK环境 因为ElasticSearch是用Java语言编写的，所以必须安装JDK的环境，并且是JDK 1.8以上，具体操作步骤自行百度 安装完成查看java版本 java -version ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:1","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"二 官网下载最新版本 下载地址[https://www.elastic.co/cn/downloads/elasticsearch],选择相应版本下载即可 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:2","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"三 下载其他版本 直接点击https://www.elastic.co/cn/downloads/past-releases#elasticsearch ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:3","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"三 下载完成，启动 解压文件，切换到解压文件路径下，执行 cd elasticsearch-\u003cversion\u003e #切换到路径下 ./bin/elasticsearch #启动es #如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d 。 #如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\\elasticsearch.bat 而不是 bin\\elasticsearch ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:4","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"四 测试启动是否成功 在浏览器输入以下地址：http://127.0.0.1:9200/ 即可看到如下内容： { \"name\" : \"lqzMacBook.local\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"G1DFg-u6QdGFvz8Z-XMZqQ\", \"version\" : { \"number\" : \"7.5.0\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"e9ccaed468e2fac2275a3761849cbee64b39519f\", \"build_date\" : \"2019-11-26T01:06:52.518245Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.3.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:5","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"五 关闭es #查看进程 ps -ef | grep elastic #干掉进程 kill -9 2382（进程号） #以守护进程方式启动es elasticsearch -d ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:6","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"六 Es 集群配置 node1 # 集群名称 cluster.name: online-virt-elasticsearch # 节点名称 node.name: es-node-1 # 是否可以成为master节点 node.master: true # 是否允许该节点存储数据,默认开启 node.data: true # 网络绑定,写自己的主机 network.host: 0.0.0.0 # 设置对外服务的http端口，默认为9200,为和单机分开，我设置9201 http.port: 9200 # 设置节点间交互的tcp端口,默认是9300，为和单机分开，我设置9301 transport.tcp.port: 9401 # 手动指定可以成为 mater 的所有节点的 name 或者 ip，这些配置将会在第一次选举中进行计算 cluster.initial_master_nodes: [\"es-node-1\",\"es-node-2\",\"es-node-3\",\"es-node-4\",\"es-node-5\"] ##设置集群自动发现机器ip的集合 discovery.seed_hosts: [\"localhost:9401\",\"localhost:9402\",\"localhost:9403\", \"localhost:9404\",\"localhost:9405\"] bootstrap.memory_lock: false bootstrap.system_call_filter: false #允许跨域访问 http.cors.enabled: true http.cors.allow-origin: \"*\" ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:2:7","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"封装 elasticsearch 集成 drf (只查询接口使用) elasticsearch 自定义包封装 __init__ .py from .filterset import EsFilterSet from .elasticsearch_generic import ElasticSearch from .pagination import EsStandardPagination elasticsearch_generic.py # -*- coding: utf-8 -*- from elasticsearch_dsl.document import IndexMeta from . import filter_backend class ElasticSearch(object): search_object = None es_filter_class = None es_paginate_class = None es_paginator = None def get_search_object(self): assert self.search_object is not None, ( \"'%s' should either include a `search_object` attribute, \" \"or override the `get_search_object()` method.\" % self.__class__.__name__ ) search_object = self.search_object if isinstance(search_object, IndexMeta): search_object = search_object.search() return search_object def filter_search_object(self, search_object): if self.es_filter_class: return filter_backend.EsFilterBackend().filter_search_object(self.request, search_object, self) return search_object def paginate_search(self, search_obj, sort=None): if self.es_paginate_class: self.es_paginator = self.es_paginate_class(search_obj, self.request, sort) return self.es_paginator.paginate def get_es_paginated_response(self, data): \"\"\" Return a paginated style `Response` object for the given output data. \"\"\" return self.es_paginator.get_paginated_response(data) filter_backend.py # -*- coding: utf-8 -*- class EsFilterBackend(object): @staticmethod def get_es_filter_class(view, search_object=None): es_filter_class = getattr(view, 'es_filter_class', None) if es_filter_class: filter_model = es_filter_class.Meta.model assert issubclass(search_object._model, filter_model), \\ 'EsFilterSet model %s does not match search_object model %s' % \\ (filter_model, search_object.model) return es_filter_class def filter_search_object(self, request, search_object, view): es_filter_class = self.get_es_filter_class(view, search_object) if es_filter_class: return es_filter_class(request.query_params, search_object=search_object, request=request).qs return search_object filters.py # -*- coding: utf-8 -*- from django_elasticsearch_dsl import fields from elasticsearch_dsl import Q class Filter(object): field_class = fields.Field def __init__(self, field_name=None, lookup_expr='exact', **kwargs): self.field_name = field_name if field_name is None and 'name' in kwargs: self.field_name = kwargs.pop('name') self.lookup_expr = lookup_expr def filter(self, name, params): if not params.get(name): return if self.lookup_expr == 'term': param = params.get(name) key = 'term' if '\u0026' in param: values = param.split('\u0026') key = 'terms' elif ',' in param: values = param.split(',') key = 'terms' else: values = param query = Q(key, **{self.field_name: values}) elif self.lookup_expr == 'gte' or self.lookup_expr == \"lte\": m = {self.lookup_expr: params.get(name)} q = {self.field_name: m} # query = {'range': q} query = Q('range', **q) else: raise Exception(\"{} can not set lookup_expr='{}'\".format(self.field_name, self.lookup_expr)) return query class KeywordField(Filter): field_class = fields.KeywordField class IntegerField(Filter): field_class = fields.IntegerField class DateField(Filter): field_class = fields.DateField filterset.py # -*- coding: utf-8 -*- import copy from collections import OrderedDict from elasticsearch_dsl import Q class FilterSetOptions(object): def __init__(self, options=None): self.model = getattr(options, 'model', None) self.fields = getattr(options, 'fields', None) self.exclude = getattr(options, 'exclude', None) class FilterSetMetaclass(type): def __new__(cls, name, bases, attrs): new_class = super(FilterSetMetaclass, cls).__new__(cls, name, bases, attrs) new_class._meta = FilterSetOptions(getattr(new_class, 'Meta', None)) new_class.base_filters = new_class.get_filters() return new_class class BaseFilterSet(object): def __init__(self, data=None, search_object=None, request=None): self.params = data self.search_object = search_object self.is_bound = data is not None self.request = request self.filte","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:3:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"封装包的使用, 快速写接口 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:4:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"视图 # 导入自定义的 ElasticSearch 和 EsStandardPagination from utils.elasticsearch import ElasticSearch, EsStandardPagination # 继承 GenericAPIView 和 ElasticSearch class NcInfoShowEsView(GenericAPIView, ElasticSearch): # 获取 search_object, 此为 documents 定义的文档类. search_object = documents.NcInfoDocument.search() # 搜索类 es_filter_class = es_filter.NcInfoFilter # 分页类 es_paginate_class = EsStandardPagination def get(self, request): s = self.filter_search_object(self.get_search_object()) # 分页组件会把分页后的es对象 转换成 queryset 对象. paginate_search 有两个参数, 一是查询后的 search对象, 第二个是排序参数, 默认是 {'pk': {'order': 'asc'}} pk为从orm 获取的 id,或 pk . page = self.paginate_search(s) if page is not None: # 视图中 分页组件会把分页后的es对象 转换成 queryset 对象. 可以使用序列化类进行序列化. 完成 serializer = serializers.NcInfoSerializer(page, many=True) return self.get_es_paginated_response(serializer.data) serializer = serializers.NcInfoSerializer(page, many=True) return APIResponse(data=serializer.data) ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:4:1","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"过滤组件 from . import models from utils.elasticsearch import EsFilterSet from utils.elasticsearch import filters # 继承自定义esFilterSet class NcInfoFilter(EsFilterSet): # 前端携带参数来的key 对应的文档字段类型 # field_name: 对应的es索引 文档中的字段 # lookup_expr: 过滤方式, 目前有 term方式 为精准匹配. lte, gte 大于小于. base_product_name = filters.KeywordField(field_name='base_product_name', lookup_expr='term') business_sla_category = filters.KeywordField(field_name='business_sla_category', lookup_expr='term') ds = filters.KeywordField(field_name='ds', lookup_expr='term') class Meta: # 过滤所对应的orm表 model = models.NcInfo # 参与过滤的字段, 需要在此注册, 否则不参与过滤. fields = ['base_product_name', 'business_sla_category', 'ds', 'business_instance_family', 'ops_cluster_id', 'ops_region_name', 'ops_azone_id','base_standard_model'] ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:4:2","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"聚合查询 # 聚合查询 elasticsearch 没有提供很好的接口. 目前使用 collapse 进行聚合查询 class NcInfoOptionsView(GenericAPIView, ElasticSearch): \"\"\" nc_info数据展示列表页筛选数据 \"\"\" search_object = documents.NcInfoDocument.search() es_filter_class = es_filter.NcInfoFilter def get(self, request, *args, **kwargs): params_map = {'standard_model_list': 'base_standard_model', 'region_name_list': 'ops_region_name', 'azone_id_list': 'ops_azone_id', 'cluster_id_list': 'ops_cluster_id', 'instance_family_list': 'business_instance_family'} results = {} all_s = self.get_search_object() sla_category_list = all_s.extra(collapse={'field': 'business_sla_category'}) results.update({'sla_category_list': [getattr(i, 'business_sla_category', None) for i in sla_category_list]}) product_name_list = all_s.extra(collapse={'field': 'base_product_name'}) results.update({'product_name_list': [getattr(i, 'base_product_name', None) for i in product_name_list]}) s = self.filter_search_object(all_s) for key, param in params_map.items(): s = s.extra(collapse={'field': param}) results.update({key: [getattr(i, param) for i in s[0:100]]}) return APIResponse(data=results) # 使用 search对象的 .extra() 进行聚合查询 具体请去看官方文档 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:4:3","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"使用 go-mysql-elasticsearch 对 mysql 数据库进行数据的同步. **如果所有的数据都是通过orm 进行操作 则可以使用此方法, 不需要使用 go-mysql-elasticsearch ** django-elasticsearch-dsl 可以使用信号量对mysql数据自动更新同步进es 只需要在 settings.py 文件中 添加以下配置 # 实时同步 用的是 django的信号量, 不需要额外的参数 ELASTICSEARCH_DSL_SIGNAL_PROCESSOR = 'django_elasticsearch_dsl.signals.RealTimeSignalProcessor' ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"mysql 开启 binlog server_id = 7578 log_bin = /apsarapangu/disk8/mysql/mysql-bin/bin-log binlog_format = ROW ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:1","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"下载go-mysql-elasticsearch ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:2","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"编译 cd /apsarapangu/disk8/go-mysql-elasticsearch make ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:3","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"配置文件 配置文件在 项目目录的 etc文件夹下, river.toml # MySQL address, user and password # user must have replication privilege in MySQL. my_addr = \"127.0.0.1:3306\" my_user = \"root\" my_pass = \"virtweb@2017\" my_charset = \"utf8\" # Set true when elasticsearch use https #es_https = false # Elasticsearch address es_addr = \"localhost:9200\" # Elasticsearch user and password, maybe set by shield, nginx, or x-pack es_user = \"\" es_pass = \"\" # Path to store data, like master.info, if not set or empty, # we must use this to support breakpoint resume syncing. # TODO: support other storage, like etcd. data_dir = \"./var\" # Inner Http status address stat_addr = \"127.0.0.1:12800\" stat_path = \"/metrics\" # pseudo server id like a slave server_id = 1001 # mysql or mariadb flavor = \"mysql\" # mysqldump execution path # if not set or empty, ignore mysqldump. # mysqldump = \"mysqldump\" # if we have no privilege to use mysqldump with --master-data, # we must skip it. #skip_master_data = false # minimal items to be inserted in one bulk bulk_size = 128 # force flush the pending requests if we don't have enough items \u003e= bulk_size flush_bulk_time = \"200ms\" # Ignore table without primary key skip_no_pk_table = false # MySQL data source [[source]] schema = \"virt_dashboard\" # Only below tables will be synced into Elasticsearch. # \"t_[0-9]{4}\" is a wildcard table format, you can use it if you have many sub tables, like table_0000 - table_1023 # I don't think it is necessary to sync all tables in a database. tables = [\"nc_info\"] [[rule]] schema = \"virt_dashboard\" table = \"nc_info\" index = \"nc_info\" type = \"_doc\" (virt-dashboard) ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:4","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"执行监控 ./bin/go-mysql-elasticsearch --config=./etc/river.toml # 加 \u0026 为后台运行 注意 在go-mysql-elasticsearch 目录下会 生成 var 文件夹. 里面有 监测mysql binlog 日志的记录, 当 go-mysql-elasticsearch 意外停止后 启动后会从停止的节点开始继续同步, 不必担心数据的丢失. ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:5:5","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"elasticsearch-head 的使用 此工具需要npm ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:0","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"下载 ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:1","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"安装依赖 npm install ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:2","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"运行 npm run start 运行成功后 会出现此界面 ![image-20201215151450248](C:\\Users\\zhang\\Desktop\\工作记录\\Elasticsearch 集成 django(传统数据库).assets\\image-20201215151450248.png) ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:3","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"Kibana 安装及使用 Kibana 应该与 es 保持版本的一致 自己百度吧. 很简单 不想写了. ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:4","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"Kibana的配置 # Kibana is served by a back end server. This setting specifies the port to use. server.port: 5601 server.host: \"0.0.0.0\" elasticsearch.hosts: [\"http://localhost:9200\"] xpack.monitoring.ui.container.elasticsearch.enabled: false ","date":"2023-08-31","objectID":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/:6:5","tags":["文档操作"],"title":"ElasticSearch集成Django","uri":"/posts/21-elasticsearch-%E9%9B%86%E6%88%90-django%E4%BC%A0%E7%BB%9F%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"categories":["ElasticSearch"],"content":"es使用两种不同的方式来发现对方： 广播 单播 也可以同时使用两者，但默认的广播，单播需要已知节点列表来完成 ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:0:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"一 广播方式 当es实例启动的时候，它发送了广播的ping请求到地址224.2.2.4:54328。而其他的es实例使用同样的集群名称响应了这个请求。 一般这个默认的集群名称就是上面的cluster_name对应的elasticsearch。通常而言，广播是个很好地方式。想象一下，广播发现就像你大吼一声：别说话了，再说话我就发红包了！然后所有听见的纷纷响应你。 但是，广播也有不好之处，过程不可控。 #1 在本地单独的目录中，再复制一份elasticsearch文件 # 2 分别启动bin目录中的启动文件 # 3 在浏览器里输入：http://127.0.0.1:9200/_cluster/health?pretty -通过number_of_nodes可以看到，目前集群中已经有了两个节点了 ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:1:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"二 单播方式 当节点的ip(想象一下我们的ip地址是不是一直在变)不经常变化的时候，或者es只连接特定的节点。单播发现是个很理想的模式。使用单播时，我们告诉es集群其他节点的ip及（可选的）端口及端口范围。我们在elasticsearch.yml配置文件中设置： discovery.zen.ping.unicast.hosts: [\"10.0.0.1\", \"10.0.0.3:9300\", \"10.0.0.6[9300-9400]\"] 大家就像交换微信名片一样，相互传传就加群了….. 一般的，我们没必要关闭单播发现，如果你需要广播发现的话，配置文件中的列表保持空白即可。 #现在，我们为这个集群增加一些单播配置，打开各节点内的\\config\\elasticsearch.yml文件。每个节点的配置如下（原配置文件都被注释了，可以理解为空，我写好各节点的配置，直接粘贴进去，没有动注释的，出现问题了好恢复）： #1 elasticsearch1节点，,集群名称是my_es1,集群端口是9300；节点名称是node1，监听本地9200端口，可以有权限成为主节点和读写磁盘（不写就是默认的）。 cluster.name: my_es1 node.name: node1 network.host: 127.0.0.1 http.port: 9200 transport.tcp.port: 9300 discovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\", \"127.0.0.1:9302\", \"127.0.0.1:9303\", \"127.0.0.1:9304\"] # 2 elasticsearch2节点,集群名称是my_es1,集群端口是9302；节点名称是node2，监听本地9202端口，可以有权限成为主节点和读写磁盘。 cluster.name: my_es1 node.name: node2 network.host: 127.0.0.1 http.port: 9202 transport.tcp.port: 9302 node.master: true node.data: true discovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\", \"127.0.0.1:9302\", \"127.0.0.1:9303\", \"127.0.0.1:9304\"] # 3 elasticsearch3节点，集群名称是my_es1,集群端口是9303；节点名称是node3，监听本地9203端口，可以有权限成为主节点和读写磁盘。 cluster.name: my_es1 node.name: node3 network.host: 127.0.0.1 http.port: 9203 transport.tcp.port: 9303 discovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\", \"127.0.0.1:9302\", \"127.0.0.1:9303\", \"127.0.0.1:9304\"] # 4 elasticsearch4节点，集群名称是my_es1,集群端口是9304；节点名称是node4，监听本地9204端口，仅能读写磁盘而不能被选举为主节点。 cluster.name: my_es1 node.name: node4 network.host: 127.0.0.1 http.port: 9204 transport.tcp.port: 9304 node.master: false node.data: true discovery.zen.ping.unicast.hosts: [\"127.0.0.1:9300\", \"127.0.0.1:9302\", \"127.0.0.1:9303\", \"127.0.0.1:9304\"] 由上例的配置可以看到，各节点有一个共同的名字my_es1,但由于是本地环境，所以各节点的名字不能一致，我们分别启动它们，它们通过单播列表相互介绍，发现彼此，然后组成一个my_es1集群。谁是老大则是要看谁先启动了！ ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:2:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"三 选取主节点 无论是广播发现还是到单播发现，一旦集群中的节点发生变化，它们就会协商谁将成为主节点，elasticsearch认为所有节点都有资格成为主节点。如果集群中只有一个节点，那么该节点首先会等一段时间，如果还是没有发现其他节点，就会任命自己为主节点。 对于节点数较少的集群，我们可以设置主节点的最小数量，虽然这么设置看上去集群可以拥有多个主节点。实际上这么设置是告诉集群有多少个节点有资格成为主节点。怎么设置呢？修改配置文件中的： discovery.zen.minimum_master_nodes: 3 一般的规则是集群节点数除以2（向下取整）再加一。比如3个节点集群要设置为2。这么着是为了防止脑裂（split brain）问题。 ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:3:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"四 什么是脑裂 脑裂这个词描述的是这样的一个场景：（通常是在重负荷或网络存在问题时）elasticsearch集群中一个或者多个节点失去和主节点的通信，然后各节点就开始选举新的主节点，继续处理请求。这个时候，可能有两个不同的集群在相互运行着，这就是脑裂一词的由来，因为单一集群被分成了两部分。为了防止这种情况的发生，我们就需要设置集群节点的总数，规则就是节点总数除以2再加一（半数以上）。这样，当一个或者多个节点失去通信，小老弟们就无法选举出新的主节点来形成新的集群。因为这些小老弟们无法满足设置的规则数量。 我们通过下图来说明如何防止脑裂。比如现在，有这样一个5个节点的集群，并且都有资格成为主节点： 为了防止脑裂，我们对该集群设置参数： discovery.zen.minimum_master_nodes: 3 # 3=5/2+1 之前原集群的主节点是node1，由于网络和负荷等原因，原集群被分为了两个switch：node1 、2和node3、4、5。因为minimum_master_nodes参数是3，所以node3、4、5可以组成集群，并且选举出了主节点node3。而node1、2节点因为不满足minimum_master_nodes条件而无法选举，只能一直寻求加入集群（还记得单播列表吗？），要么网络和负荷恢复正常后加入node3、4、5组成的集群中，要么就是一直处于寻找集群状态，这样就防止了集群的脑裂问题。 除了设置minimum_master_nodes参数，有时候还需要设置node_master参数，比如有两个节点的集群，如果出现脑裂问题，那么它们自己都无法选举，因为都不符合半数以上。这时我们可以指定node_master，让其中一个节点有资格成为主节点，另外一个节点只能做存储用。当然这是特殊情况。 那么，主节点是如何知道某个节点还活着呢？这就要说到错误识别了。 ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:4:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"五 错误识别 其实错误识别，就是当主节点被确定后，建立起内部的ping机制来确保每个节点在集群中保持活跃和健康，这就是错误识别。 主节点ping集群中的其他节点，而且每个节点也会ping主节点来确认主节点还活着，如果没有响应，则宣布该节点失联。想象一下，老大要时不常的看看（循环）小弟们是否还活着，而小老弟们也要时不常的看看老大还在不在，不在了就赶紧再选举一个出来！ 但是，怎么看？多久没联系算是失联？这些细节都是可以设置的，不是一拍脑门子，就说某个小老弟挂了！在配置文件中，可以设置： discovery.zen.fd.ping_interval: 1 discovery.zen.fd.ping_timeout: 30 discovery_zen.fd.ping_retries: 3 每个节点每隔discovery.zen.fd.ping_interval的时间（默认1秒）发送一个ping请求，等待discovery.zen.fd.ping_timeout的时间（默认30秒），并尝试最多discovery.zen.fd.ping_retries次（默认3次），无果的话，宣布节点失联，并且在需要的时候进行新的分片和主节点选举。 根据开发环境，适当修改这些值。 ","date":"2023-08-31","objectID":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/:5:0","tags":["文档操作"],"title":"ElasticSearch集群搭建, 数据分片","uri":"/posts/14-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"},{"categories":["ElasticSearch"],"content":"一 前言 在elasticsearch\\config目录下，有三个核心的配置文件： elasticsearch.yml，es相关的配置。 jvm.options，Java jvm相关参数的配置。 log4j2.properties，日志相关的配置，因为es采用了log4j的日志框架。 这里以elasticsearch6.5.4版本为例，并且由于版本不同，配置也不太也一样，仅作参考！ ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:1:0","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"二 elasticsearch.yml ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:0","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.1 Cluster 配置集群名称，由多个es实例组成的集群，有一个共同的名称。 cluster.name: my-application 集群端口设置。 transport.tcp.port: 9300 防止同一个shard的主副本存在同一个物理机上。 cluster.routing.allocation.same_shard.host:true 初始化数据恢复时，并发恢复线程的个数，默认是4个。 cluster.routing.allocation.node_initial_primaries_recoveries: 4 添加删除节点或者负载均衡时并发恢复线程的个数。默认是4个。 cluster.routing.allocation.node_concurrent_recoveries: 4 ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:1","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.2 Node 节点名称配置，一个es实例其实是一个es进程，在集群中被称为节点。如果一个服务器上配置集群，各节点的名称不能重复。 node.name: node-1 为节点添加自定义属性， node.attr.rack: r1 该节点是否有资格成为主节点，默认为true。 node.master: true 设置节点是否存储数据。 node.data: true 设置默认主分片的个数，默认为5片，需要说明的是，主分片一经分配则无法更改。 index.number_of_shards: 5 设置默认复制分片的个数，默认一个主分片对应一个复制分片，需要说明的是，复制分片可以手动调整。 index.number_of_replicas: 1 设置数据恢复时限制的带宽，默认0及不限制。 indices.recovery.max_size_per_ser: 0 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 indices.recovery.concurrent_streams: 5 设置数据恢复时限制的带宽，默认0及不限制。 indices.recovery.max_size_per_ser: 0 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 indices.recovery.concurrent_streams: 5 ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:2","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.3 Paths 存储数据路径设置，多个路径以英文状态的逗号分隔，默认根目录下的conf目录。 path.data: /path/to/data # path.data: /path/to/data1,/path/to/data1 设置临时文件存储路径，默认是es目录下的work目录。 path.work: /path/to/work 日志文件路径，默认为根目录下的logs目录。 path.logs: /path/to/logs 设置日志文件的存储路径，默认是es目录下的logs目录。 path.logs: /path/to/logs 设置插件的存放路径，默认是es目录下的plugins目录。 path.plugins: /path/to/plugins ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:3","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.4 Network 为es实例绑定特定的IP地址。 network.host: 192.168.0.1 上面的设置可以拆分为两个参数。 network.bind_host: 192.168.0.1 # 设置绑定的ip地址，ipv4或ipv6都可以 network.publish_host: 192.168.0.1 # 设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址 为es实例设置特定的端口，默认为9200端口。 http.port: 9200 ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:4","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.5 Discovery 设置是否打开多播发现节点，默认是true。 discovery.zen.ping.multicast.enabled: true 配置es单播发现列表，在es启动时，通过这个列表发现别的es实例，从而加入集群。 discovery.zen.ping.unicast.hosts: [\"host1\", \"host2\"] discovery.zen.ping.unicast.hosts: [\"10.0.0.1\", \"10.0.0.3:9300\", \"10.0.0.6[9300-9400]\"] discovery.zen.minimum_master_nodes设置是告诉集群有多少个节点有资格成为主节点，一般的规则是集群节点数除以2（向下取整）再加一。比如3个节点集群要设置为2，这个试着是为了防止脑裂问题。 设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。 discovery.zen.ping.timeout: 3s ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:5","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.6 Memory 启动时锁定内存，默认为true，因为当jvm开始swapping时es的效率 会降低，所以要保证它不swap，可以把ES_MIN_MEM和ES_MAX_MEM两个环境变量设置成同一个值，并且保证机器有足够的内存分配给es。 同时也要允许elasticsearch的进程可以锁住内存，linux下可以通过ulimit -l unlimited命令 bootstrap.memory_lock: true 禁止swapping交换。 bootstrap.mlockall: true ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:6","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.7 Gateway 设置是否压缩tcp传输时的数据。默认是false不压缩。 transport.tcp.compress: true 设置内容的最大容量，默认是100mb。 http.max_content_length: 100mb 是否使用http协议对外提供服务。默认为true。 http.enabled: false 设置gateway的类型，默认为本地文件系统，也可以设置分布式文件系统、Hadoop的HDFS或者AWS的都可以。 gateway.type: local 在完全重新启动集群之后阻塞初始恢复，直到启动N个节点为止，详情参见Recovery gateway.recover_after_nodes: 3 设置初始化数据恢复进程的超时时间。默认是5分钟。 gateway.recover_after_time: 5m 设置该集群中节点的数量，默认为2个，一旦这N个节点启动，就会立即进行数据恢复。 gateway.expected_nodes: 2 ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:7","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"2.8 Various 删除索引时需要显式名称。 action.destructive_requires_name: true ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:2:8","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"三 jvm.options 设置jvm堆的大小，最大值和最小值，应该是一致的，并且应该根据你的物理内存决定。 -Xms1g # 设置最小堆为1g -Xmx1g # 设置最大堆为1g ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:3:0","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"四 log4j2.properties 这个配置文件，我们一般不修改其配置。 ","date":"2023-08-31","objectID":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/:4:0","tags":["文档操作"],"title":"ElasticSearch配置文件","uri":"/posts/19-elasticsearch%E4%B9%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"},{"categories":["ElasticSearch"],"content":"一 前言 官方解释：https://www.elastic.co/guide/en/elasticsearch/reference/6.0/removal-of-types.html 在elasticsearch6.0.0或更高的版本中创建索引仅能包含单个映射类型。在具有多种映射类型的5.x版本中创建的索引将继续像以前一样在elasticsearch6.x中运行。类型将在elasticsearch7.0.0中的API中弃用，并在8.0.0中完全删除。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:1:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"二 什么是映射类型？ 从elasticsearch发布以来，每个文档都存储在单个索引中并分配了单个映射类型。映射类型用于表示要编制索引的文档或实体的类型。例如微博（twitter）索引可能具有用户（user）类型和推文（tweet）两个类型。 每种映射类型都可以有自己的字段，因此用户（user）类型可能有full_name、user_name、email字段；而推文（tweet）类型可能有content、tweet_at字段和用户（user）类型的user_name字段。 每个文档都有一个_type包含类型名称的元字段，通过在URL中指定类型名称，搜索可以限制为一种或多种类型： GET twitter/user,tweet/_search { \"query\":{ \"match\":{ \"user_name\":\"kimchy\" } } } 该_type字段与文档组合_id以生成_uid字段，因此具有相同类型的文档_id可以存储在单个索引中。 映射类型也用于在文档中建立父子关系，因此类型的文档question可以是类型文档的父类answer。 扯了半天淡，一切不都是挺好的嘛？那还为啥要删除映射类型呢？ ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:2:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"三 为什么要删除映射类型？ 最初（其实到现在），为了便于理解elasticsearch的数据组织，通常拿elasticsearch和关系型数据库做对比，比如我们谈到一个es索引（index）时，通常将它比喻为类似于SQL数据库中的database，而类型（type）等同于SQL数据库中的表。 这真是一个糟糕的比喻！让我们有了错误理解。因为在SQL数据库中，表彼此独立，一个表中的字段与另一个表中具有相同名称的字段无关，而映射类型中的字段不是这种情况。 在elasticsearch的索引中，不同映射类型具有相同名称的字段在内部由相同的Lucene字段支持。换句话说，使用上面的示例，用户（user）类型中的user_name字段存储在和推文（tweet）类型中的user_name字段完全相同的字段中，而且两种类型中的user_name字段必须具有相同的映射（定义）。 当我们希望删除一个类型的日期字段和同一个索引中另一个类型的布尔字段时，这可能会导致挫败感（可以理解为删除失败）。 最重要的是，在同一索引中存储具有很少或没有共同字段的不同实体会导致稀疏数据并干扰Lucene有效压缩文档的能力。 出于这些原因，我们决定从elasticsearch中删除映射类型的概念。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:3:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"四 映射类型的替代方法 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:4:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"4.1 将映射类型分开存储在索引中 第一种方法是每个文档类型都有一个索引，例如微博（twitter）索引中，我们可以将推文（tweet）类型和用户（user）类型分开，分别存储在独立的索引中。这样两个相互的索引就不会引起字段冲突了。 这中方法有两个好处： 数据更可能是密集的，因此受益于Lucene中使用的压缩技术。 用于全文搜索评分的词条统计将会更精确，应为同一索引中的所有文档都代表单个实体。 每个索引的大小可以根据其包含的文档数量进行适当的调整，比如我们为用户（user）类型分配较少的主分片，而为推文（tweet）类型分配较多的主分片。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:4:1","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"4.2 自定义类型字段回到顶部 当然了，集群中可以存储多少个主分片是有限制的，我们不希望仅为几千个文档的集合而浪费整个分片。在这种情况下，我们可以实现自己的自定义type字段，该字段的工作方式与旧的_type相似。 还是上面微博（twitter）例子，最初，它的映射类型看起来是这样的： PUT twitter { \"mappings\": { \"user\":{ \"properties\":{ \"name\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"email\":{ \"type\":\"keyword\" } } }, \"tweet\":{ \"properties\":{ \"content\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"tweet_at\":{ \"type\":\"date\" } } } } } PUT twitter/user/kimchy { \"name\":\"狗子\", \"user_name\":\"二狗子\", \"email\":\"dog@twodog.com\" } PUT twitter/tweet/1 { \"name\":\"kimchy\", \"tweet_ad\":\"2019-04-30T10:26:20Z\", \"content\":\"单身狗求包养\" } GET twitter/tweet/_search { \"query\": { \"match\": { \"user_name\": \"kimchy\" } } } 如上示例，请在5.x及以下版本测试 我们也可以通过添加自定义type字段来实现相同目的： PUT twitter { \"mappings\": { \"doc\":{ \"properties\":{ \"type\":{ \"type\":\"keyword\" }, \"name\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"email\":{ \"type\":\"text\" }, \"content\":{ \"type\":\"text\" }, \"tweet_at\":{ \"type\":\"date\" } } } } } PUT twitter/doc/user-kimchy { \"type\":\"user\", \"name\":\"狗子\", \"user_name\":\"二狗子\", \"email\":\"dog@twodog.com\" } PUT twitter/doc/tweet-1 { \"type\":\"tweet\", \"user_name\":\"kimchy\", \"tweet_at\":\"2019-04-30T10:26:20Z\", \"content\":\"单身狗求包养\" } GET twitter/_search { \"query\": { \"bool\": { \"must\":[ { \"match\": { \"user_name\": \"kimchy\" } } ], \"filter\": { \"match\":{ \"type\":\"tweet\" } } } } } 上述示例6.5.4版本运行无误。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:4:2","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"五 没有映射类型的父/子 以前，通过将一个映射类型设置为父级，将一个或多个其他映射类型设置为子级来表示父子关系。现在，没有了多类型，我们就不能再使用这种语法了。除了表示文档之间的关系方式已改为使用新的join字段之外，父子特征将继续像以前一样运行。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:5:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"六 删除映射类型的计划 这个删除映射类型的计划，对于用户来说是一个很大的变化，所以我们试图让它尽可能轻松，更改将如下所示： 在elasticsearch5.6.0中： index.mapping.single_type:true在索引上设置将启用在6.0中强制执行的单索引类型。 父子的join字段替换可用于在5.6中创建索引。 在elasticsearch6.x中： 在5.x中创建的索引将继续在6.x中运行，就像在5.x中一样。 在6.x中创建的索引仅允许每个索引使用单一类型，任何字段都可以用于该类型，但必须是唯一的。 该_type名称可以不再与_id组合形成_uid字段，_uid字段已成为_id字段的别名。 新索引不再支持旧的父/子关系，而是应该使用连接字段。 不推荐使用_default_mapping类型。 在6.7中，索引创建、索引模板和映射API支持查询字符串参数（include_type_name），该参数仅表示请求和响应是否应该包含类型名称，默认为true，应该设置为一个显式值，以便准备升级到7.0。未设置include_type_name将导致一个弃用警告，没有显式类型的索引将使用默认的类型名称_doc。 在elasticsearch7.x中： 不推荐在请求中指定类型。例如，索引文档不再需要文档类型。对于自动生成的id，新的索引API在显式ids和POST {index_name}/_doc的情况下是PUT {index_name}/_doc/{id}。 索引创建，索引模板和映射API中的include_type_name参数将默认为false，未设置参数将导致启动警告。 删除了_default_mapping类型。 在elasticsearch8.x中： 不在支持在请求中指定类型。 include_type_name参数已删除。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:6:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"七将多类型索引迁移到单一类型 Reindex API可用于将多类型索引转换为单类型索引。下面的例子可以在Elasticsearch 5.6或Elasticsearch 6.x中使用。在6.x中，不需要指定index.mapping。默认为单一类型。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:7:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"7.1 每种文档类型的索引 第一个示例将微博（twitter）索引拆分为推文（tweets）索引和用户（users）索引： PUT users { \"mappings\": { \"user\":{ \"properties\":{ \"name\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"email\":{ \"type\":\"keyword\" } } } } } PUT tweets { \"mappings\": { \"tweet\":{ \"properties\":{ \"content\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"tweet_at\":{ \"type\":\"date\" } } } } } POST _reindex { \"source\": { \"index\":\"twitter\", \"type\":\"user\" }, \"dest\": { \"index\":\"users\" } } POST _reindex { \"source\": { \"index\":\"twitter\", \"type\":\"tweet\" }, \"dest\": { \"index\": \"tweets\" } } 上述代码在6.5.4版本中运行无误。 上述的示例意思是，在之前我们在微博（twitter）索引中，有两个类型（tweet和user）。现在要将两个类型分开，成为独立的索引。所以，首先先创建出各自的索引（tweets和users），然后通过POST _reindex来完成迁移工作。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:7:1","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"7.2 自定义类型字段 第二个示例添加自自定义的type字段，并将其设置为原始值_type。它还添加了类型到id，以防有任何不同类型的文档具有冲突的id： PUT new_twitter { \"mappings\": { \"doc\":{ \"properties\":{ \"type\":{ \"type\":\"keyword\" }, \"name\":{ \"type\":\"text\" }, \"user_name\":{ \"type\":\"keyword\" }, \"email\":{ \"type\":\"keyword\" }, \"content\":{ \"type\":\"text\" }, \"tweet_at\":{ \"type\":\"date\" } } } } } POST _reindex { \"source\": { \"index\":\"twitter\" }, \"dest\":{ \"index\": \"new_twitter\" }, \"script\": { \"source\": \"\"\" ctx._source.type = ctx._type; ctx._id = ctx._type + \"-\" + ctx._id; ctx._type = \"doc\"; \"\"\" } } 上述代码在6.5.4版本运行无误。 ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:7:2","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"八 总结 总之，通篇看下来，如果对elasticsearch，尤其是各版本不太了解的话，这篇文档看着索然无味！重要的是看不懂，如果我们是新手，接触elasticsearch的时候，就是从6.x版本开始的，那只要记得，一个索引下面只能创建一个类型就行了，其中各字段都具有唯一性，如果在创建映射的时候，如果没有指定文档类型，那么该索引的默认索引类型是_doc，不指定文档id则会内部帮我们生成一个id字符串。其他的，who care？ ","date":"2023-08-31","objectID":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/:8:0","tags":["文档操作"],"title":"ElasticSearch删除映射类型","uri":"/posts/17-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB-%E5%88%A0%E9%99%A4%E6%98%A0%E5%B0%84%E7%B1%BB%E5%9E%8B/"},{"categories":["ElasticSearch"],"content":"一 创建mapping PUT test { \"mappings\": { \"test\":{ \"properties\": { \"location\":{ \"type\": \"geo_point\" } } } } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:1:0","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"二 导入数据 POST test/test { \"location\":{ \"lat\":12, \"lon\":24 } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:2:0","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"三 查询 ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:3:0","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"3.1根据给定两个点组成的矩形，查询矩形内的点 GET test/test/_search { \"query\": { \"geo_bounding_box\": { \"location\": { \"top_left\": { \"lat\": 28, \"lon\": 10 }, \"bottom_right\": { \"lat\": 10, \"lon\": 30 } } } } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:3:1","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"3.2根据给定的多个点组成的多边形，查询范围内的点 GET test/test/_search { \"query\": { \"geo_polygon\": { \"location\": { \"points\": [ { \"lat\": 11, \"lon\": 25 }, { \"lat\": 13, \"lon\": 25 }, { \"lat\": 13, \"lon\": 23 }, { \"lat\": 11, \"lon\": 23 } ] } } } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:3:2","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"3.3查询给定1000KM距离范围内的点 GET test/test/_search { \"query\": { \"geo_distance\": { \"distance\": \"1000km\", \"location\": { \"lat\": 12, \"lon\": 23 } } } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:3:3","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"3.4查询距离范围区间内的点的数量 GET test/test/_search { \"size\": 0, \"aggs\": { \"myaggs\": { \"geo_distance\": { \"field\": \"location\", \"origin\": { \"lat\": 52.376, \"lon\": 4.894 }, \"unit\": \"km\", \"ranges\": [ { \"from\": 50, \"to\": 30000 } ] } } } } ","date":"2023-08-31","objectID":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/:3:4","tags":["文档操作"],"title":"ElasticSearch位置做不及附近的人搜索","uri":"/posts/15-elasticsearch%E9%AB%98%E7%BA%A7%E4%B9%8B-%E4%BD%8D%E7%BD%AE%E5%9D%90%E6%A0%87%E5%AE%9E%E7%8E%B0%E9%99%84%E8%BF%91%E7%9A%84%E4%BA%BA%E6%90%9C%E7%B4%A2/"},{"categories":["ElasticSearch"],"content":"一 Kibana介绍 Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。 您、可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。 可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现 详情可见用户手册： https://www.elastic.co/guide/cn/kibana/current/index.html 注意跟Elasticsearch版本兼容情况，详情见： https://www.elastic.co/cn/support/matrix#matrix_compatibility 下载地址为： https://www.elastic.co/cn/downloads/past-releases ","date":"2023-08-31","objectID":"/posts/04-elasticsearch%E4%B9%8B-kibana/:1:0","tags":["Kibana"],"title":"Kibana介绍","uri":"/posts/04-elasticsearch%E4%B9%8B-kibana/"},{"categories":["ElasticSearch"],"content":"二 下载Kibana 到相应地址，下载即可 解压下载后的文件 ","date":"2023-08-31","objectID":"/posts/04-elasticsearch%E4%B9%8B-kibana/:2:0","tags":["Kibana"],"title":"Kibana介绍","uri":"/posts/04-elasticsearch%E4%B9%8B-kibana/"},{"categories":["ElasticSearch"],"content":"三 修改配置文件 修改配置文件：vim 安装目录/config/kibana.yml # 更多配置信息，详见 https://www.elastic.co/guide/cn/kibana/current/settings.html server.port: 5601 server.host: \"127.0.0.1\" server.name: lqz elasticsearch.hosts: [\"http://localhost:9200/\"] ","date":"2023-08-31","objectID":"/posts/04-elasticsearch%E4%B9%8B-kibana/:3:0","tags":["Kibana"],"title":"Kibana介绍","uri":"/posts/04-elasticsearch%E4%B9%8B-kibana/"},{"categories":["ElasticSearch"],"content":"四 启动 到安装目录下： ./bin/kibana #正常启动 ##六 查看 在浏览器里访问：http://localhost:5601/app/kibana （如访问不到，尝试删除es中跟kibana相关的索引） 选择Dev Tools 在console中输入GET _settings ,查询可以看到如下 ","date":"2023-08-31","objectID":"/posts/04-elasticsearch%E4%B9%8B-kibana/:4:0","tags":["Kibana"],"title":"Kibana介绍","uri":"/posts/04-elasticsearch%E4%B9%8B-kibana/"},{"categories":["ElasticSearch"],"content":"一 nodejs介绍 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 为什么要安装Node.js呢，下面用到的Grunt 工具是基于Node.js 使用的 下载地址：https://nodejs.org/en/download/releases/ 选择版本下载， 一直下一步确定即可，安装后进入命令行中 输入 : node -v # 显示版本号即安装成功 ","date":"2023-08-31","objectID":"/posts/03-%E5%AE%89%E8%A3%85nodejs/:1:0","tags":["nodejs"],"title":"nodejs 安装","uri":"/posts/03-%E5%AE%89%E8%A3%85nodejs/"},{"categories":["ElasticSearch"],"content":"二 查看原来的镜像地址 npm（node package manager）：nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等） npm get registry # 输出：https://registry.npmjs.org/ ","date":"2023-08-31","objectID":"/posts/03-%E5%AE%89%E8%A3%85nodejs/:2:0","tags":["nodejs"],"title":"nodejs 安装","uri":"/posts/03-%E5%AE%89%E8%A3%85nodejs/"},{"categories":["ElasticSearch"],"content":"三 npm切换阿里源 #切换阿里源 npm config set registry https://registry.npm.taobao.org/ #查看是否成功 npm config get registry #或者 npm get registry #可以看到输出 #https://registry.npm.taobao.org/ ","date":"2023-08-31","objectID":"/posts/03-%E5%AE%89%E8%A3%85nodejs/:3:0","tags":["nodejs"],"title":"nodejs 安装","uri":"/posts/03-%E5%AE%89%E8%A3%85nodejs/"},{"categories":["ElasticSearch"],"content":"四 安装cmpm cnpm:因为npm安装插件是从国外服务器下载，受网络的影响比较大，可能会出现异常，如果npm的服务器在中国就好了，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” npm install -g cnpm --registry=https://registry.npm.taobao.org #查看是否安装成功 cnpm -v #成功后可以使用cnpm代替npm命令 ","date":"2023-08-31","objectID":"/posts/03-%E5%AE%89%E8%A3%85nodejs/:4:0","tags":["nodejs"],"title":"nodejs 安装","uri":"/posts/03-%E5%AE%89%E8%A3%85nodejs/"},{"categories":["ElasticSearch"],"content":"五 改变原有的环境变量 1、首先配置npm的全局模块的存放路径、cache的路径 npm config set prefix \"路径\" npm config set cache \"路径\" ","date":"2023-08-31","objectID":"/posts/03-%E5%AE%89%E8%A3%85nodejs/:5:0","tags":["nodejs"],"title":"nodejs 安装","uri":"/posts/03-%E5%AE%89%E8%A3%85nodejs/"},{"categories":["ElasticSearch"],"content":"一 倒排索引是什么 倒排索引源于实际应用中需要根据属性的值来查找记录，这种索引表中的每一个项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而成为倒排索引。带有倒排索引的文件我们称之为倒排索引文件，简称倒排文件 ","date":"2023-08-31","objectID":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/:1:0","tags":["倒排索引"],"title":"倒排索引","uri":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"},{"categories":["ElasticSearch"],"content":"二 举例 例如有如下三个文件： 文件A：通过Python django搭建网站 文件B：通过Python scrapy爬取网站数据 文件C：scrapy-redis分布式爬虫 现在我们要查询，带有Python的文件，正常是对每个文件进行遍历，每个文件遍历一次，如果文件特别大，每个文件有一亿个字符，总共有一亿各文件，每个我们都要遍历，非常消耗资源 在存储文件之前，先对文件进行分析，将文件分词，对分词建立索引，例如下面一句话 1 今天是星期天我们出去玩 2 明天是星期天，放假 3 今天天气很晴朗 4 xxx 5 他们出去玩了 关键词 文章 今天 文章1，文章3 星期天 文章2 出去玩 文章5，文章1 实际上es在做存储的时候，更详细，如下表 关键词 文章 今天 (文章1,\u003c2，10\u003e,2) (文章3,\u003c8\u003e,1) 星期天 (文章2,\u003c12,25,100\u003e,3) 出去玩 (文章5,\u003c11,24,89\u003e,3)(文章1,\u003c8，19\u003e,2) 今天出现在哪个文章，出现的位置和出现的次数 ","date":"2023-08-31","objectID":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/:2:0","tags":["倒排索引"],"title":"倒排索引","uri":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"},{"categories":["ElasticSearch"],"content":"三 倒排索引待解决的问题 1 大小写转换问题，如python和Python应该为同一个词 2 词干抽取，looking和look应该处理为同一个词 3 分词，如 屏蔽系统 是屏蔽 和系统两个词还是 为屏蔽系统一个词 4 倒排索引文件过大，需要压缩编码 ","date":"2023-08-31","objectID":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/:3:0","tags":["倒排索引"],"title":"倒排索引","uri":"/posts/06-elasticsearch%E4%B9%8B-%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95/"},{"categories":["ElasticSearch"],"content":"具体操作可以查看官方文档 https://www.elastic.co/guide/en/elasticsearch/reference/7.5/indices.html\u003e 官方2版本的中文文档 https://www.elastic.co/guide/cn/elasticsearch/guide/current/index-settings.html ","date":"2023-08-31","objectID":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/:0:0","tags":["索引操作"],"title":"索引操作","uri":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"一 索引初始化 #新建一个lqz2的索引，索引分片数量为5，索引副本数量为1 PUT lqz2 { \"settings\": { \"index\":{ \"number_of_shards\":5, \"number_of_replicas\":1 } } } ''' number_of_shards 每个索引的主分片数，默认值是 5 。这个配置在索引创建后不能修改。 number_of_replicas 每个主分片的副本数，默认值是 1 。对于活动的索引库，这个配置可以随时修改。 ''' ","date":"2023-08-31","objectID":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/:1:0","tags":["索引操作"],"title":"索引操作","uri":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"二 查询索引配置 #获取lqz2索引的配置信息 GET lqz2/_settings #获取所有索引的配置信息 GET _all/_settings #同上 GET _settings #获取lqz和lqz2索引的配置信息 GET lqz,lqz2/_settings ","date":"2023-08-31","objectID":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/:2:0","tags":["索引操作"],"title":"索引操作","uri":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"三 更新索引 #修改索引副本数量为2 PUT lqz/_settings { \"number_of_replicas\": 2 } #如遇到报错：cluster_block_exception，因为 #这是由于ES新节点的数据目录data存储空间不足，导致从master主节点接收同步数据的时候失败，此时ES集群为了保护数据，会自动把索引分片index置为只读read-only PUT _all/_settings { \"index\": { \"blocks\": { \"read_only_allow_delete\": false } } } ","date":"2023-08-31","objectID":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/:3:0","tags":["索引操作"],"title":"索引操作","uri":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"四 删除索引 #删除lqz索引 DELETE lqz ","date":"2023-08-31","objectID":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/:4:0","tags":["索引操作"],"title":"索引操作","uri":"/posts/07-elasticsearch%E4%B9%8B-%E7%B4%A2%E5%BC%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"一 新增文档 #新增一个id为1的书籍（POST和PUT都可以） POST lqz/_doc/1/_create #POST lqz/_doc/1 #POST lqz/_doc 会自动创建id,必须用Post { \"title\":\"红楼梦\", \"price\":12, \"publish_addr\":{ \"province\":\"黑龙江\", \"city\":\"鹤岗\" }, \"publish_date\":\"2013-11-11\", \"read_num\":199, \"tag\":[\"古典\",\"名著\"] } ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:1:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"二 查询文档 #查询lqz索引下id为7的文档 GET lqz/_doc/7 #查询lqz索引下id为7的文档，只要title字段 GET lqz/_doc/7?_source=title #查询lqz索引下id为7的文档，只要title和price字段 GET lqz/_doc/7?_source=title,price #查询lqz索引下id为7的文档，要全部字段 GET lqz/_doc/7?_source ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:2:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"三 修改文档 #修改文档(覆盖修改) PUT lqz/_doc/10 { \"title\":\"xxxx\", \"price\":333, \"publish_addr\":{ \"province\":\"黑龙江\", \"city\":\"福州\" } } #修改文档，增量修改，只修改某个字段(注意是post) POST lqz/_update/10 { \"doc\":{ \"title\":\"修改\" } } ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:3:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"四 删除文档 #删除文档id为10的 DELETE lqz/_doc/10 ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:4:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"五 批量操作之_mget #批量获取lqz索引_doc类型下id为2的数据和lqz2索引_doc类型下id为1的数据 GET _mget { \"docs\":[ { \"_index\":\"lqz\", \"_type\":\"_doc\", \"_id\":2 }, { \"_index\":\"lqz2\", \"_type\":\"_doc\", \"_id\":1 } ] } #批量获取lqz索引下id为1和2的数据 GET lqz/_mget { \"docs\":[ { \"_id\":2 }, { \"_id\":1 } ] } #同上 GET lqz/_mget { \"ids\":[1,2] } ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:5:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"六 批量操作之 bulk PUT test/_doc/2/_create { \"field1\" : \"value22\" } POST _bulk { \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } } { \"field1\" : \"value1\" } { \"delete\" : { \"_index\" : \"test\", \"_id\" : \"2\" } } { \"create\" : { \"_index\" : \"test\", \"_id\" : \"3\" } } { \"field1\" : \"value3\" } { \"update\" : {\"_id\" : \"1\", \"_index\" : \"test\"} } { \"doc\" : {\"field2\" : \"value2\"} } ","date":"2023-08-31","objectID":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/:6:0","tags":["文档操作"],"title":"文档操作","uri":"/posts/09-0-elasticsearch%E4%B9%8B-%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"一 前言 在知名的中分分词器中，ik中文分词器的大名可以说是无人不知，elasticsearch有了ik分词器的加持，就像男人有了神油…….要了解ik中文分词器，就首先要了解一下它的由来。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:1:0","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"二 ik分词器的由来 IK Analyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， IK Analyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 IK Analyzer 2012特性： 采用了特有的正向迭代最细粒度切分算法，支持细粒度和智能分词两种切分模式。在系统环境：Core2 i7 3.4G双核，4G内存，window 7 64位， Sun JDK 1.6_29 64位 普通pc环境测试，IK2012具有160万字/秒（3000KB/S）的高速处理能力。 2012版本的智能分词模式支持简单的分词排歧义处理和数量词合并输出。 采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符 优化的词典存储，更小的内存占用。支持用户词典扩展定义。特别的，在2012版本，词典支持中文，英文，数字混合词语。 后来，被一个叫medcl（曾勇 elastic开发工程师与布道师，elasticsearch开源社区负责人，2015年加入elastic）的人集成到了elasticsearch中， 并支持自定义字典……. ps：elasticsearch的ik中文分词器插件由medcl的github上下载，而 IK Analyzer 这个分词器，如果百度搜索的，在开源中国中的提交者是林良益，由此推断之下，才有了上面的一番由来……….. 才有了接下来一系列的扯淡………. ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:2:0","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"三 IK分词器插件的安装 打开Github官网，搜索elasticsearch-analysis-ik，单击medcl/elasticsearch-analysis-ik。或者直接点击 在readme.md文件中，下拉选择历史版本连接。 由于ik与elasticsearch存在兼容问题。所以在下载ik时要选择和elasticsearch版本一致的，也就是选择v6.5.4版本，单击elasticsearch-analysis-ik-6.5.4.zip包，自动进入下载到本地。 本地下载成功后，是个zip包。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:3:0","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"3.1 安装 首先打开C:\\Program Files\\elasticseach-6.5.4\\plugins目录，新建一个名为ik的子目录，并将elasticsearch-analysis-ik-6.5.4.zip包解压到该ik目录内也就是C:\\Program Files\\elasticseach-6.5.4\\plugins\\ik目录。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:3:1","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"3.2 测试 首先将elascticsearch和kibana服务重启。 然后地址栏输入http://localhost:5601，在Dev Tools中的Console界面的左侧输入命令，再点击绿色的执行按钮执行。 GET _analyze { \"analyzer\": \"ik_max_word\", \"text\": \"上海自来水来自海上\" } 右侧就显示出结果了如下所示： { \"tokens\" : [ { \"token\" : \"上海\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"自来水\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"自来\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 }, { \"token\" : \"水\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"CN_CHAR\", \"position\" : 3 }, { \"token\" : \"来自\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"海上\", \"start_offset\" : 7, \"end_offset\" : 9, \"type\" : \"CN_WORD\", \"position\" : 5 } ] } OK，安装完毕，非常的简单。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:3:2","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"3.3 ik目录简介 我们简要的介绍一下ik分词配置文件： IKAnalyzer.cfg.xml，用来配置自定义的词库 main.dic，ik原生内置的中文词库，大约有27万多条，只要是这些单词，都会被分在一起。 surname.dic，中国的姓氏。 suffix.dic，特殊（后缀）名词，例如乡、江、所、省等等。 preposition.dic，中文介词，例如不、也、了、仍等等。 stopword.dic，英文停用词库，例如a、an、and、the等。 quantifier.dic，单位名词，如厘米、件、倍、像素等。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:3:3","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"四 ik分词器的使用 before 首先将elascticsearch和kibana服务重启，让插件生效。 然后地址栏输入http://localhost:5601，在Dev Tools中的Console界面的左侧输入命令，再点击绿色的执行按钮执行。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:0","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"4.1 第一个ik示例 来个简单的示例。 GET _analyze { \"analyzer\": \"ik_max_word\", \"text\": \"上海自来水来自海上\" } 右侧就显示出结果了如下所示： { \"tokens\" : [ { \"token\" : \"上海\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"自来水\", \"start_offset\" : 2, \"end_offset\" : 5, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"自来\", \"start_offset\" : 2, \"end_offset\" : 4, \"type\" : \"CN_WORD\", \"position\" : 2 }, { \"token\" : \"水\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"CN_CHAR\", \"position\" : 3 }, { \"token\" : \"来自\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"海上\", \"start_offset\" : 7, \"end_offset\" : 9, \"type\" : \"CN_WORD\", \"position\" : 5 } ] } 那么你可能对开始的analyzer：ik_max_word有一丝的疑惑，这个家伙是干嘛的呀？我们就来看看这个家伙到底是什么鬼！ ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:1","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"4.2 ik_max_word 现在有这样的一个索引： PUT ik1 { \"mappings\": { \"doc\": { \"dynamic\": false, \"properties\": { \"name\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" } } } } } 上例中，ik_max_word参数会将文档做最细粒度的拆分，以穷尽尽可能的组合。 接下来为该索引添加几条数据： PUT ik1/doc/1 { \"content\":\"今天是个好日子\" } PUT ik1/doc/2 { \"content\":\"心想的事儿都能成\" } PUT ik1/doc/3 { \"content\":\"我今天不活了\" } 现在让我们开始查询，随便查！ GET ik1/_search { \"query\": { \"match\": { \"content\": \"心想\" } } } 查询结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"心想的事儿都能成\" } } ] } } 成功的返回了一条数据。我们再来以今天为条件来查询。 GET ik1/_search { \"query\": { \"match\": { \"content\": \"今天\" } } } 结果如下： { \"took\" : 2, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"今天是个好日子\" } }, { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"我今天不活了\" } } ] } } 上例的返回中，成功的查询到了两条结果。 与ik_max_word对应还有另一个参数。让我们一起来看下。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:2","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"4.3 ik_smart 与ik_max_word对应的是ik_smart参数，该参数将文档作最粗粒度的拆分。 GET _analyze { \"analyzer\": \"ik_smart\", \"text\": \"今天是个好日子\" } 上例中，我们以最粗粒度的拆分文档。 结果如下： { \"tokens\" : [ { \"token\" : \"今天是\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"个\", \"start_offset\" : 3, \"end_offset\" : 4, \"type\" : \"CN_CHAR\", \"position\" : 1 }, { \"token\" : \"好日子\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 2 } ] } 再来看看以最细粒度的拆分文档。 GET _analyze { \"analyzer\": \"ik_max_word\", \"text\": \"今天是个好日子\" } 结果如下： { \"tokens\" : [ { \"token\" : \"今天是\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"CN_WORD\", \"position\" : 0 }, { \"token\" : \"今天\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"CN_WORD\", \"position\" : 1 }, { \"token\" : \"是\", \"start_offset\" : 2, \"end_offset\" : 3, \"type\" : \"CN_CHAR\", \"position\" : 2 }, { \"token\" : \"个\", \"start_offset\" : 3, \"end_offset\" : 4, \"type\" : \"CN_CHAR\", \"position\" : 3 }, { \"token\" : \"好日子\", \"start_offset\" : 4, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 4 }, { \"token\" : \"日子\", \"start_offset\" : 5, \"end_offset\" : 7, \"type\" : \"CN_WORD\", \"position\" : 5 } ] } 由上面的对比可以发现，两个参数的不同，所以查询结果也肯定不一样，视情况而定用什么粒度。 在基本操作方面，除了粗细粒度，别的按照之前的操作即可，就像下面两个短语查询和短语前缀查询一样。 ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:3","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"4.4 ik之短语查询 ik中的短语查询参照之前的短语查询即可。 GET ik1/_search { \"query\": { \"match_phrase\": { \"content\": \"今天\" } } } 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"今天是个好日子\" } }, { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"我今天不活了\" } } ] } } ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:4","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"4.5 ik之短语前缀查询 同样的，我们第2部分的快速上手部分的操作在ik中同样适用。 GET ik1/_search { \"query\": { \"match_phrase_prefix\": { \"content\": { \"query\": \"今天好日子\", \"slop\": 2 } } } } 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"今天是个好日子\" } }, { \"_index\" : \"ik1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"content\" : \"我今天不活了\" } } ] } } ","date":"2023-08-31","objectID":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/:4:5","tags":["文档操作","分词器"],"title":"文档操作- ik分词器","uri":"/posts/09-15-elasticsearch-ik%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"一 前言 我们应该知道，在关系型数据库中，必须先定义表结构，才能插入数据，并且，表结构不会轻易改变。而我们呢，我们怎么玩elasticsearch的呢： PUT t1/doc/1 { \"name\": \"小黑\" } PUT t1/doc/2 { \"name\": \"小白\", \"age\": 18 } 文档的字段可以是任意的，原本都是name字段，突然来个age。还要elasticsearch自动去猜，哦，可能是个long类型，然后加个映射！之后发什么什么？肯定是：猜猜猜，猜你妹！ 难道你不想知道elasticsearch内部是怎么玩的吗？ 当我们执行上述第一条PUT命令后，elasticsearch到底是怎么做的： GET t1 结果： { \"t1\" : { \"aliases\" : { }, \"mappings\" : { \"doc\" : { \"properties\" : { \"name\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } }, \"settings\" : { \"index\" : { \"creation_date\" : \"1553334893136\", \"number_of_shards\" : \"5\", \"number_of_replicas\" : \"1\", \"uuid\" : \"lHfujZBbRA2K7QDdsX4_wA\", \"version\" : { \"created\" : \"6050499\" }, \"provided_name\" : \"t1\" } } } } 由返回结果可以看到，分为两大部分，第一部分关于t1索引类型相关的，包括该索引是否有别名aliases，然后就是mappings信息，包括索引类型doc，各字段的详细映射关系都收集在properties中。 另一部分是关于索引t1的settings设置。包括该索引的创建时间，主副分片的信息，UUID等等。 我们再执行第二条PUT命令，再查看该索引是否有什么变化，返回结果如下： { \"t1\" : { \"aliases\" : { }, \"mappings\" : { \"doc\" : { \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } }, \"settings\" : { \"index\" : { \"creation_date\" : \"1553334893136\", \"number_of_shards\" : \"5\", \"number_of_replicas\" : \"1\", \"uuid\" : \"lHfujZBbRA2K7QDdsX4_wA\", \"version\" : { \"created\" : \"6050499\" }, \"provided_name\" : \"t1\" } } } } 由返回结果可以看到，settings没有变化，只是mappings中多了一条关于age的映射关系，这一切都是elasticsearch自动的，但特定的场景下，需要我们更多的设置。 所以，接下来，我们研究一下mappings到底是怎么回事！ ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:1:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"二 映射是什么？ 其实，映射mappings没那么神秘！说白了，就相当于原来由elasticsearch自动帮我们定义表结构。现在，我们要自己来了，旨在创建索引的时候，有更多定制的内容，更加的贴合业务场景。OK，坐好了，开车！ elasticsearch中的映射用来定义一个文档及其包含的字段如何存储和索引的过程。例如，我们可以使用映射来定义： 哪些字符串应该被视为全文字段。 哪些字段包含数字、日期或者地理位置。 定义日期的格式。 自定义的规则，用来控制动态添加字段的的映射。 ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:2:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"三 映射类型 每个索引都有一个映射类型（这话必须放在elasticsearch6.x版本后才能说，之前版本一个索引下有多个类型），它决定了文档将如何被索引。 映射类型有： 元字段（meta-fields）：元字段用于自定义如何处理文档关联的元数据，例如包括文档的_index、_type、_id和_source字段。 字段或属性（field or properties）：映射类型包含与文档相关的字段或者属性的列表。 继续往下走！ ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:3:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"四 字段的数据类型 简单类型，如文本（text）、关键字（keyword）、日期（date）、整形（long）、双精度（double）、布尔（boolean）或ip。 可以是支持JSON的层次结构性质的类型，如对象或嵌套。 或者一种特殊类型，如geo_point、geo_shape或completion。 为了不同的目的，以不同的方式索引相同的字段通常是有用的。例如，字符串字段可以作为全文搜索的文本字段进行索引，也可以作为排序或聚合的关键字字段进行索引。或者，可以使用标准分析器、英语分析器和法语分析器索引字符串字段。 这就是多字段的目的。大多数数据类型通过fields参数支持多字段。 ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:4:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"五 映射约束 在索引中定义太多的字段有可能导致映射爆炸！因为这可能会导致内存不足以及难以恢复的情况，为此。我们可以手动或动态的创建字段映射的数量： index.mapping.total_fields.limit：索引中的最大字段数。字段和对象映射以及字段别名都计入此限制。默认值为1000。 index.mapping.depth.limit：字段的最大深度，以内部对象的数量来衡量。例如，如果所有字段都在根对象级别定义，则深度为1.如果有一个子对象映射，则深度为2，等等。默认值为20。 index.mapping.nested_fields.limit：索引中嵌套字段的最大数量，默认为50.索引1个包含100个嵌套字段的文档实际上索引101个文档，因为每个嵌套文档都被索引为单独的隐藏文档。 ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:5:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"六 一个简单的映射示例 PUT mapping_test1 { \"mappings\": { \"test1\":{ \"properties\":{ \"name\":{\"type\": \"text\"}, \"age\":{\"type\":\"long\"} } } } } 上例中，我们在创建索引PUT mapping_test1的过程中，为该索引定制化类型（设计表结构），添加一个映射类型test1；指定字段或者属性都在properties内完成。 GET mapping_test1 通过GET来查看。 { \"mapping_test1\" : { \"aliases\" : { }, \"mappings\" : { \"test1\" : { \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\" } } } }, \"settings\" : { \"index\" : { \"creation_date\" : \"1550469220778\", \"number_of_shards\" : \"5\", \"number_of_replicas\" : \"1\", \"uuid\" : \"7I_m_ULRRXGzWcvhIZoxnQ\", \"version\" : { \"created\" : \"6050499\" }, \"provided_name\" : \"mapping_test1\" } } } } 返回的结果中你肯定很熟悉！映射类型是test1，具体的属性都被封装在properties中。而关于settings的配置，我们暂时不管它。 我们为这个索引添加一些数据： put mapping_test1/test1/1 { \"name\":\"张开嘴\", \"age\":16 } 上例中，mapping_test1是之前创建的索引，test1为之前自定义的mappings类型。字段是之前创建好的name和age。 GET mapping_test1/test1/_search { \"query\": { \"match\": { \"age\": 16 } } } 上例中，我们通过age条件查询。 { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"mapping_test1\", \"_type\" : \"test1\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"张开嘴\", \"age\" : 16 } } ] } } 返回了预期的结果信息。 ","date":"2023-08-31","objectID":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/:6:0","tags":["文档操作"],"title":"文档操作-mapping","uri":"/posts/09-10-elasticsearch%E4%B9%8Bmappings/"},{"categories":["ElasticSearch"],"content":"一 ignore_above 长度超过ignore_above设置的字符串将不会被索引或存储（个人认为会存储，但不会为该字段建立索引，也就是该字段不能被检索）。 对于字符串数组，ignore_above将分别应用于每个数组元素，并且不会索引或存储比ignore_above更长的字符串元素。 PUT w1 { \"mappings\": { \"doc\":{ \"properties\":{ \"t1\":{ \"type\":\"keyword\", \"ignore_above\": 5 }, \"t2\":{ \"type\":\"keyword\", \"ignore_above\": 10 ① } } } } } PUT w1/doc/1 { \"t1\":\"elk\", ② \"t2\":\"elasticsearch\" ③ } GET w1/doc/_search ④ { \"query\":{ \"term\": { \"t1\": \"elk\" } } } GET w1/doc/_search ⑤ { \"query\": { \"term\": { \"t2\": \"elasticsearch\" } } } ①，该字段将忽略任何超过10个字符的字符串。 ②，此文档已成功建立索引，也就是说能被查询，并且有结果返回。 ③，该字段将不会建立索引，也就是说，以该字段作为查询条件，将不会有结果返回。 ④，有结果返回。 ⑤，则将不会有结果返回，因为t2字段对应的值长度超过了ignove_above设置的值。 该参数对于防止Lucene的术语字节长度限制也很有用，限制长度是32766。 注意，该ignore_above设置可以利用现有的领域进行更新PUT地图API。 对于值ignore_above是字符数，但Lucene的字节数为单位。如果您使用带有许多非ASCII字符的UTF-8文本，您可能需要设置限制，32766 / 4 = 8191因为UTF-8字符最多可占用4个字节。 如果我们观察上述示例中，我们可以看到在设置映射类型时，字段的类型是keyword，也就是说ignore_above参数仅针对于keyword类型有用。 那么如果字符串的类型是text时能用ignore_above吗，答案是能，但要特殊设置： PUT w2 { \"mappings\": { \"doc\":{ \"properties\":{ \"t1\":{ \"type\":\"keyword\", \"ignore_above\":5 }, \"t2\":{ \"type\":\"text\", \"fields\":{ \"keyword\":{ \"type\":\"keyword\", \"ignore_above\": 10 } } } } } } } PUT w2/doc/1 { \"t1\":\"beautiful\", \"t2\":\"beautiful girl\" } GET w2/doc/_search ① { \"query\": { \"term\": { \"t1\": { \"value\": \"beautiful\" } } } } GET w2/doc/_search ② { \"query\": { \"term\": { \"t2\": \"beautiful\" } } } ①，不会有返回结果。 ②，有返回结果，因为该字段的类型是text。 但是，当字段类型设置为text之后，ignore_above参数的限制就失效了。 ","date":"2023-08-31","objectID":"/posts/09-13-elasticsearch%E4%B9%8Bmappings-parameters/:1:0","tags":["文档操作"],"title":"文档操作-mappings parameters","uri":"/posts/09-13-elasticsearch%E4%B9%8Bmappings-parameters/"},{"categories":["ElasticSearch"],"content":"一 前言 上一小节中，根据dynamic的状态不同，我们对字段有了更多可自定义的操作。现在再来补充一个参数，使自定义的属性更加的灵活。 ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:1:0","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"二 index 首先来创建一个mappings： PUT m4 { \"mappings\": { \"doc\": { \"dynamic\": false, \"properties\": { \"name\": { \"type\": \"text\", \"index\": true }, \"age\": { \"type\": \"long\", \"index\": false } } } } } 可以看到，我们在创建索引的时候，为每个属性添加一个index参数。那会有什么效果呢？ 先来添加一篇文档： PUT m4/doc/1 { \"name\": \"小黑\", \"age\": 18 } 再来查询看效果： GET m4/doc/_search { \"query\": { \"match\": { \"name\": \"小黑\" } } } GET m4/doc/_search { \"query\": { \"match\": { \"age\": 18 } } } 以name查询没问题，但是，以age作为查询条件就有问题了： { \"error\": { \"root_cause\": [ { \"type\": \"query_shard_exception\", \"reason\": \"failed to create query: {\\n \\\"match\\\" : {\\n \\\"age\\\" : {\\n \\\"query\\\" : 18,\\n \\\"operator\\\" : \\\"OR\\\",\\n \\\"prefix_length\\\" : 0,\\n \\\"max_expansions\\\" : 50,\\n \\\"fuzzy_transpositions\\\" : true,\\n \\\"lenient\\\" : false,\\n \\\"zero_terms_query\\\" : \\\"NONE\\\",\\n \\\"auto_generate_synonyms_phrase_query\\\" : true,\\n \\\"boost\\\" : 1.0\\n }\\n }\\n}\", \"index_uuid\": \"GHBPeT5pRnSi3g6DkpIkow\", \"index\": \"m4\" } ], \"type\": \"search_phase_execution_exception\", \"reason\": \"all shards failed\", \"phase\": \"query\", \"grouped\": true, \"failed_shards\": [ { \"shard\": 0, \"index\": \"m4\", \"node\": \"dhkqLLTsRemm7qEgRdpvTg\", \"reason\": { \"type\": \"query_shard_exception\", \"reason\": \"failed to create query: {\\n \\\"match\\\" : {\\n \\\"age\\\" : {\\n \\\"query\\\" : 18,\\n \\\"operator\\\" : \\\"OR\\\",\\n \\\"prefix_length\\\" : 0,\\n \\\"max_expansions\\\" : 50,\\n \\\"fuzzy_transpositions\\\" : true,\\n \\\"lenient\\\" : false,\\n \\\"zero_terms_query\\\" : \\\"NONE\\\",\\n \\\"auto_generate_synonyms_phrase_query\\\" : true,\\n \\\"boost\\\" : 1.0\\n }\\n }\\n}\", \"index_uuid\": \"GHBPeT5pRnSi3g6DkpIkow\", \"index\": \"m4\", \"caused_by\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Cannot search on field [age] since it is not indexed.\" } } } ] }, \"status\": 400 } 返回的是报错结果，这其中就是index参数在起作用。 小结：index属性默认为true，如果该属性设置为false，那么，elasticsearch不会为该属性创建索引，也就是说无法当做主查询条件。 ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:2:0","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"三 copy_to 现在，再来学习一个copy_to属性，该属性允许我们将多个字段的值复制到组字段中，然后将组字段作为单个字段进行查询。 PUT m5 { \"mappings\": { \"doc\": { \"dynamic\":false, \"properties\": { \"first_name\":{ \"type\": \"text\", \"copy_to\": \"full_name\" }, \"last_name\": { \"type\": \"text\", \"copy_to\": \"full_name\" }, \"full_name\": { \"type\": \"text\" } } } } } PUT m5/doc/1 { \"first_name\":\"tom\", \"last_name\":\"ben\" } PUT m5/doc/2 { \"first_name\":\"john\", \"last_name\":\"smith\" } GET m5/doc/_search { \"query\": { \"match\": { \"first_name\": \"tom\" } } } GET m5/doc/_search { \"query\": { \"match\": { \"full_name\": \"tom\" } } } 上例中，我们将first_name和last_name都复制到full_name中。并且使用full_name查询也返回了结果： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"m5\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"first_name\" : \"tom\", \"last_name\" : \"ben\" } } ] } } 返回结果表示查询成功。那么想要查询tom或者smith该怎么办？ GET m5/doc/_search { \"query\": { \"match\": { \"full_name\": { \"query\": \"tom smith\", \"operator\": \"or\" } } } } 将查询条件以空格隔开并封装在query内，operator参数为多个条件的查询关系也可以是and，也有简写方式： GET m5/doc/_search { \"query\": { \"match\": { \"full_name\": \"tom smith\" } } } copy_to还支持将相同的属性值复制给不同的字段。 PUT m6 { \"mappings\": { \"doc\": { \"dynamic\":false, \"properties\": { \"first_name\":{ \"type\": \"text\", \"copy_to\": \"full_name\" }, \"last_name\": { \"type\": \"text\", \"copy_to\": [\"field1\", \"field2\"] }, \"field1\": { \"type\": \"text\" }, \"field2\": { \"type\": \"text\" } } } } } PUT m6/doc/1 { \"first_name\":\"tom\", \"last_name\":\"ben\" } PUT m6/doc/2 { \"first_name\":\"john\", \"last_name\":\"smith\" } 上例中，只需要将copy_to的字段以数组的形式封装即可。无论是通过field1还是field2都可以查询。 小结： copy_to复制的是属性值而不是属性 copy_to如果要应用于聚合请将filddata设置为true 如果要将属性值复制给多个字段，请用数组，比如copy_to:[\"field1\", \"field2\"] ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:3:0","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"四 对象属性 现在，有一个个人信息文档如下： PUT m7/doc/1 { \"name\":\"tom\", \"age\":18, \"info\":{ \"addr\":\"北京\", \"tel\":\"10010\" } } 首先，这样嵌套多层的mappings该如何设计呢？ PUT m7 { \"mappings\": { \"doc\": { \"dynamic\": false, \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"text\" }, \"info\": { \"properties\": { \"addr\": { \"type\": \"text\" }, \"tel\": { \"type\" : \"text\" } } } } } } } 那么，如果要以name或者age属性作为查询条件查询难不倒我们。 现在如果要以info中的tel为条件怎么写查询语句呢？ GET mapping_test9/doc/_search { \"query\": { \"match\": { \"info.tel\": \"10086\" } } } 上例中，info既是一个属性，也是一个对象，我们称为info这类字段为对象型字段。该对象内又包含addr和tel两个字段，如上例这种以嵌套内的字段为查询条件的话，查询语句可以以字段点子字段的方式来写即可。 ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:4:0","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"五 settings设置 ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:5:0","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"5.1 设置主、复制分片 在创建一个索引的时候，我们可以在settings中指定分片信息： PUT s1 { \"mappings\": { \"doc\": { \"properties\": { \"name\": { \"type\": \"text\" } } } }, \"settings\": { \"number_of_replicas\": 1, \"number_of_shards\": 5 } } number_of_shards是主分片数量（每个索引默认5个主分片），而number_of_replicas是复制分片，默认一个主分片搭配一个复制分片。 ","date":"2023-08-31","objectID":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/:5:1","tags":["文档操作"],"title":"文档操作-mappings的其他设置","uri":"/posts/09-12-elasticsearch%E4%B9%8Bmappings%E7%9A%84%E5%85%B6%E4%BB%96%E8%AE%BE%E7%BD%AEindexcopy_to%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7settings/"},{"categories":["ElasticSearch"],"content":"一 前言 一般的，mapping则又可以分为动态映射（dynamic mapping）和静态（显式）映射（explicit mapping）和精确（严格）映射（strict mappings），具体由dynamic属性控制。 ","date":"2023-08-31","objectID":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/:1:0","tags":["文档操作"],"title":"文档操作-mappings之dynamic的三种状态","uri":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"},{"categories":["ElasticSearch"],"content":"二 动态映射（dynamic：true） 现在有这样的一个索引： PUT m1 { \"mappings\": { \"doc\":{ \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"long\" } } } } } 通过GET m1/_mapping看一下mappings信息： { \"m1\" : { \"mappings\" : { \"doc\" : { \"dynamic\" : \"true\", \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\" } } } } } } 添加一些数据，并且新增一个sex字段： PUT m1/doc/1 { \"name\": \"小黑\", \"age\": 18, \"sex\": \"不详\" } 当然，新的字段查询也没问题： GET m1/doc/_search { \"query\": { \"match\": { \"sex\": \"不详\" } } } 返回结果： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.5753642, \"hits\" : [ { \"_index\" : \"m1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.5753642, \"_source\" : { \"name\" : \"小黑\", \"age\" : 18, \"sex\" : \"不详\" } } ] } } 现在，一切都很正常，跟elasticsearch自动创建时一样。那是因为，当 Elasticsearch 遇到文档中以前未遇到的字段，它用动态映射来确定字段的数据类型并自动把新的字段添加到类型映射。我们再来看mappings你就明白了： { \"m1\" : { \"mappings\" : { \"doc\" : { \"dynamic\" : \"true\", \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\" }, \"sex\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } } } } 通过上例可以发下，elasticsearch帮我们新增了一个sex的映射。所以。这一切看起来如此自然。这一切的功劳都要归功于dynamic属性。我们知道在关系型数据库中，字段创建后除非手动修改，则永远不会更改。但是，elasticsearch默认是允许添加新的字段的，也就是dynamic：true。 其实创建索引的时候，是这样的： PUT m1 { \"mappings\": { \"doc\":{ \"dynamic\":true, \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"long\" } } } } } 上例中，当dynamic设置为true的时候，elasticsearch就会帮我们动态的添加映射属性。也就是等于啥都没做！ 这里有一点需要注意的是：mappings一旦创建，则无法修改。因为Lucene生成倒排索引后就不能改了。 ","date":"2023-08-31","objectID":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/:2:0","tags":["文档操作"],"title":"文档操作-mappings之dynamic的三种状态","uri":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"},{"categories":["ElasticSearch"],"content":"三 静态映射（dynamic：false） 现在，我们将dynamic值设置为false： PUT m2 { \"mappings\": { \"doc\":{ \"dynamic\":false, \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"long\" } } } } } 现在再来测试一下false和true有什么区别： PUT m2/doc/1 { \"name\": \"小黑\", \"age\":18 } PUT m2/doc/2 { \"name\": \"小白\", \"age\": 16, \"sex\": \"不详\" } 第二条数据相对于第一条数据来说，多了一个sex属性，我们以sex为条件来查询一下： GET m2/doc/_search { \"query\": { \"match\": { \"sex\": \"不详\" } } } 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 0, \"max_score\" : null, \"hits\" : [ ] } } 结果是空的，也就是什么都没查询到，那是为什呢？来GET m2/_mapping一下此时m2的mappings信息： ``{ “m2” : { “mappings” : { “doc” : { “dynamic” : “false”, “properties” : { “age” : { “type” : “long” }, “name” : { “type” : “text” } } } } } }可以看到elasticsearch并没有为新增的sex建立映射关系。所以查询不到。 当elasticsearch察觉到有新增字段时，因为dynamic:false的关系，会忽略该字段，但是仍会存储该字段。 在有些情况下，dynamic:false`依然不够，所以还需要更严谨的策略来进一步做限制。 ","date":"2023-08-31","objectID":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/:3:0","tags":["文档操作"],"title":"文档操作-mappings之dynamic的三种状态","uri":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"},{"categories":["ElasticSearch"],"content":"四 严格模式（dynamic：strict） 让我们再创建一个mappings，并且将dynamic的状态改为strict： PUT m3 { \"mappings\": { \"doc\": { \"dynamic\": \"strict\", \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"long\" } } } } } 现在，添加两篇文档： PUT m3/doc/1 { \"name\": \"小黑\", \"age\": 18 } PUT m3/doc/2 { \"name\": \"小白\", \"age\": 18, \"sex\": \"不详\" } 第一篇文档添加和查询都没问题。但是，当添加第二篇文档的时候，你会发现报错了： { \"error\": { \"root_cause\": [ { \"type\": \"strict_dynamic_mapping_exception\", \"reason\": \"mapping set to strict, dynamic introduction of [sex] within [doc] is not allowed\" } ], \"type\": \"strict_dynamic_mapping_exception\", \"reason\": \"mapping set to strict, dynamic introduction of [sex] within [doc] is not allowed\" }, \"status\": 400 } 错误提示，严格动态映射异常！说人话就是，当dynamic:strict的时候，elasticsearch如果遇到新字段，会抛出异常。 上述这种严谨的作风洒家称为——严格模式！ 小结： 动态映射（dynamic：true）：动态添加新的字段（或缺省）。 静态映射（dynamic：false）：忽略新的字段。在原有的映射基础上，当有新的字段时，不会主动的添加新的映射关系，只作为查询结果出现在查询中。 严格模式（dynamic： strict）：如果遇到新的字段，就抛出异常。 一般静态映射用的较多。就像HTML的img标签一样，src为自带的属性，你可以在需要的时候添加id或者class属性。 当然，如果你非常非常了解你的数据，并且未来很长一段时间不会改变，strict不失为一个好选择。 ","date":"2023-08-31","objectID":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/:4:0","tags":["文档操作"],"title":"文档操作-mappings之dynamic的三种状态","uri":"/posts/09-11-elasticsearch-mappings%E4%B9%8Bdynamic%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"},{"categories":["ElasticSearch"],"content":"一 前言 Python中关于elasticsearch的操作，主要集中一下几个方面： 结果过滤，对于返回结果做过滤，主要是优化返回内容。 Elasticsearch（简称es），直接操作elasticsearch对象，处理一些简单的索引信息。一下几个方面都是建立在es对象的基础上。 Indices，关于索引的细节操作，比如创建自定义的mappings。 Cluster，关于集群的相关操作。 Nodes，关于节点的相关操作。 Cat API，换一种查询方式，一般的返回都是json类型的，cat提供了简洁的返回结果。 Snapshot，快照相关，快照是从正在运行的Elasticsearch集群中获取的备份。我们可以拍摄单个索引或整个群集的快照，并将其存储在共享文件系统的存储库中，并且有一些插件支持S3，HDFS，Azure，Google云存储等上的远程存储库。 Task Management API，任务管理API是新的，仍应被视为测试版功能。API可能以不向后兼容的方式更改。 ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:1:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"二 结果过滤 print(es.search(index='py2', filter_path=['hits.total', 'hits.hits._source'])) # 可以省略type类型 print(es.search(index='w2', doc_type='doc')) # 可以指定type类型 print(es.search(index='w2', doc_type='doc', filter_path=['hits.total'])) filter_path参数用于减少elasticsearch返回的响应，比如仅返回hits.total和hits.hits._source内容。 除此之外，filter_path参数还支持*通配符以匹配字段名称、任何字段或者字段部分： print(es.search(index='py2', filter_path=['hits.*'])) print(es.search(index='py2', filter_path=['hits.hits._*'])) print(es.search(index='py2', filter_path=['hits.to*'])) # 仅返回响应数据的total print(es.search(index='w2', doc_type='doc', filter_path=['hits.hits._*'])) # 可以加上可选的type类型 ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:2:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"三 Elasticsearch（es对象） es.index，向指定索引添加或更新文档，如果索引不存在，首先会创建该索引，然后再执行添加或者更新操作。 # print(es.index(index='w2', doc_type='doc', id='4', body={\"name\":\"可可\", \"age\": 18})) # 正常 # print(es.index(index='w2', doc_type='doc', id=5, body={\"name\":\"卡卡西\", \"age\":22})) # 正常 # print(es.index(index='w2', id=6, body={\"name\": \"鸣人\", \"age\": 22})) # 会报错，TypeError: index() missing 1 required positional argument: 'doc_type' print(es.index(index='w2', doc_type='doc', body={\"name\": \"鸣人\", \"age\": 22})) # 可以不指定id，默认生成一个id es.get，查询索引中指定文档。 print(es.get(index='w2', doc_type='doc', id=5)) # 正常 print(es.get(index='w2', doc_type='doc')) # TypeError: get() missing 1 required positional argument: 'id' print(es.get(index='w2', id=5)) # TypeError: get() missing 1 required positional argument: 'doc_type' es.search，执行搜索查询并获取与查询匹配的搜索匹配。这个用的最多，可以跟复杂的查询条件。 index要搜索的以逗号分隔的索引名称列表; 使用_all 或空字符串对所有索引执行操作。 doc_type 要搜索的以逗号分隔的文档类型列表; 留空以对所有类型执行操作。 body 使用Query DSL（QueryDomain Specific Language查询表达式）的搜索定义。 _source 返回_source字段的true或false，或返回的字段列表，返回指定字段。 _source_exclude要从返回的_source字段中排除的字段列表，返回的所有字段中，排除哪些字段。 _source_include从_source字段中提取和返回的字段列表，跟_source差不多。 print(es.search(index='py3', doc_type='doc', body={\"query\": {\"match\":{\"age\": 20}}})) # 一般查询 print(es.search(index='py3', doc_type='doc', body={\"query\": {\"match\":{\"age\": 19}}},_source=['name', 'age'])) # 结果字段过滤 print(es.search(index='py3', doc_type='doc', body={\"query\": {\"match\":{\"age\": 19}}},_source_exclude =[ 'age'])) print(es.search(index='py3', doc_type='doc', body={\"query\": {\"match\":{\"age\": 19}}},_source_include =[ 'age'])) es.get_source，通过索引、类型和ID获取文档的来源，其实，直接返回想要的字典。 print(es.get_source(index='py3', doc_type='doc', id='1')) # {'name': '王五', 'age': 19} es.count，执行查询并获取该查询的匹配数。比如查询年龄是18的文档。 body = { \"query\": { \"match\": { \"age\": 18 } } } print(es.count(index='py2', doc_type='doc', body=body)) # {'count': 1, '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0}} print(es.count(index='py2', doc_type='doc', body=body)['count']) # 1 print(es.count(index='w2')) # {'count': 6, '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0}} print(es.count(index='w2', doc_type='doc')) # {'count': 6, '_shards': {'total': 5, 'successful': 5, 'skipped': 0, 'failed': 0}} es.create，创建索引（索引不存在的话）并新增一条数据，索引存在仅新增（只能新增，重复执行会报错）。 print(es.create(index='py3', doc_type='doc', id='1', body={\"name\": '王五', \"age\": 20})) print(es.get(index='py3', doc_type='doc', id='3')) 在内部，调用了index，等价于： print(es.index(index='py3', doc_type='doc', id='4', body={\"name\": \"麻子\", \"age\": 21})) 但个人觉得没有index好用！ es.delete，删除指定的文档。比如删除文章id为4的文档，但不能删除索引，如果想要删除索引，还需要es.indices.delete来处理 print(es.delete(index='py3', doc_type='doc', id='4')) es.delete_by_query，删除与查询匹配的所有文档。 index 要搜索的以逗号分隔的索引名称列表; 使用_all 或空字符串对所有索引执行操作。 doc_type 要搜索的以逗号分隔的文档类型列表; 留空以对所有类型执行操作。 body使用Query DSL的搜索定义。 print(es.delete_by_query(index='py3', doc_type='doc', body={\"query\": {\"match\":{\"age\": 20}}})) es.exists，查询elasticsearch中是否存在指定的文档，返回一个布尔值。 print(es.exists(index='py3', doc_type='doc', id='1')) es.info，获取当前集群的基本信息。 print(es.info()) es.ping，如果群集已启动，则返回True，否则返回False。 print(es.ping()) ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:3:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"四 Indices（es.indices） **es.indices.create，在Elasticsearch中创建索引，用的最多。**比如创建一个严格模式、有4个字段、并为title字段指定ik_max_word查询粒度的mappings。并应用到py4索引中。这也是常用的创建自定义索引的方式。 body = { \"mappings\": { \"doc\": { \"dynamic\": \"strict\", \"properties\": { \"title\": { \"type\": \"text\", \"analyzer\": \"ik_max_word\" }, \"url\": { \"type\": \"text\" }, \"action_type\": { \"type\": \"text\" }, \"content\": { \"type\": \"text\" } } } } } es.indices.create('py4', body=body) es.indices.analyze，返回分词结果。 es.indices.analyze(body={'analyzer': \"ik_max_word\", \"text\": \"皮特和茱丽当选“年度模范情侣”Brad Pitt and Angelina Jolie\"}) es.indices.delete，在Elasticsearch中删除索引。 print(es.indices.delete(index='py4')) print(es.indices.delete(index='w3')) # {'acknowledged': True} es.indices.put_alias，为一个或多个索引创建别名，查询多个索引的时候，可以使用这个别名。 index 别名应指向的逗号分隔的索引名称列表（支持通配符），使用_all对所有索引执行操作。 name要创建或更新的别名的名称。 body别名的设置，例如路由或过滤器。 print(es.indices.put_alias(index='py4', name='py4_alias')) # 为单个索引创建别名 print(es.indices.put_alias(index=['py3', 'py2'], name='py23_alias')) # 为多个索引创建同一个别名，联查用 es.indices.delete_alias，删除一个或多个别名。 print(es.indices.delete_alias(index='alias1')) print(es.indices.delete_alias(index=['alias1, alias2'])) es.indices.get_mapping，检索索引或索引/类型的映射定义。 print(es.indices.get_mapping(index='py4')) es.indices.get_settings，检索一个或多个（或所有）索引的设置。 print(es.indices.get_settings(index='py4')) es.indices.get，允许检索有关一个或多个索引的信息。 print(es.indices.get(index='py2')) # 查询指定索引是否存在 print(es.indices.get(index=['py2', 'py3'])) es.indices.get_alias，检索一个或多个别名。 print(es.indices.get_alias(index='py2')) print(es.indices.get_alias(index=['py2', 'py3'])) es.indices.get_field_mapping，检索特定字段的映射信息。 print(es.indices.get_field_mapping(fields='url', index='py4', doc_type='doc')) print(es.indices.get_field_mapping(fields=['url', 'title'], index='py4', doc_type='doc')) es.indices.delete_alias，删除特定别名。 es.indices.exists，返回一个布尔值，指示给定的索引是否存在。 es.indices.exists_type，检查索引/索引中是否存在类型/类型。 es.indices.flus，明确的刷新一个或多个索引。 es.indices.get_field_mapping，检索特定字段的映射。 es.indices.get_template，按名称检索索引模板。 es.indices.open，打开一个封闭的索引以使其可用于搜索。 es.indices.close，关闭索引以从群集中删除它的开销。封闭索引被阻止进行读/写操作。 es.indices.clear_cache，清除与一个或多个索引关联的所有缓存或特定缓存。 es.indices.put_alias，为特定索引/索引创建别名。 es.indices.get_uprade，监控一个或多个索引的升级程度。 es.indices.put_mapping，注册特定类型的特定映射定义。 es.indices.put_settings，实时更改特定索引级别设置。 es.indices.put_template，创建一个索引模板，该模板将自动应用于创建的新索引。 es.indices.rollove，当现有索引被认为太大或太旧时，翻转索引API将别名转移到新索引。API接受单个别名和条件列表。别名必须仅指向单个索引。如果索引满足指定条件，则创建新索引并切换别名以指向新别名。 es.indices.segments，提供构建Lucene索引（分片级别）的低级别段信息。 ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:4:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"五 Cluster（集群相关） es.cluster.get_settigns，获取集群设置。 print(es.cluster.get_settings()) es.cluster.health，获取有关群集运行状况的非常简单的状态。 print(es.cluster.health()) es.cluster.state，获取整个集群的综合状态信息。 print(es.cluster.state()) es.cluster.stats，返回群集的当前节点的信息。 print(es.cluster.stats()) ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:5:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"六 Node（节点相关） es.nodes.info，返回集群中节点的信息。 print(es.nodes.info()) # 返回所节点 print(es.nodes.info(node_id='node1')) # 指定一个节点 print(es.nodes.info(node_id=['node1', 'node2'])) # 指定多个节点列表 es.nodes.stats，获取集群中节点统计信息。 print(es.nodes.stats()) print(es.nodes.stats(node_id='node1')) print(es.nodes.stats(node_id=['node1', 'node2'])) es.nodes.hot_threads，获取指定节点的线程信息。 print(es.nodes.hot_threads(node_id='node1')) print(es.nodes.hot_threads(node_id=['node1', 'node2'])) es.nodes.usage，获取集群中节点的功能使用信息。 print(es.nodes.usage()) print(es.nodes.usage(node_id='node1')) print(es.nodes.usage(node_id=['node1', 'node2'])) ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:6:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"七 Cat（一种查询方式） es.cat.aliases，返回别名信息。 name要返回的以逗号分隔的别名列表。 formatAccept标头的简短版本，例如json，yaml print(es.cat.aliases(name='py23_alias')) print(es.cat.aliases(name='py23_alias', format='json')) es.cat.allocation，返回分片使用情况。 print(es.cat.allocation()) print(es.cat.allocation(node_id=['node1'])) print(es.cat.allocation(node_id=['node1', 'node2'], format='json')) es.cat.count，Count提供对整个群集或单个索引的文档计数的快速访问。 print(es.cat.count()) # 集群内的文档总数 print(es.cat.count(index='py3')) # 指定索引文档总数 print(es.cat.count(index=['py3', 'py2'], format='json')) # 返回两个索引文档和 es.cat.fielddata，基于每个节点显示有关当前加载的fielddata的信息。有些数据为了查询效率，会放在内存中，fielddata用来控制哪些数据应该被放在内存中，而这个es.cat.fielddata则查询现在哪些数据在内存中，数据大小等信息。 print(es.cat.fielddata()) print(es.cat.fielddata(format='json', bytes='b')) bytes显示字节值的单位，有效选项为：'b'，'k'，'kb'，'m'，'mb'，'g'，'gb'，'t'，'tb' ，'p'，'pb' formatAccept标头的简短版本，例如json，yaml es.cat.health，从集群中health里面过滤出简洁的集群健康信息。 print(es.cat.health()) print(es.cat.health(format='json')) es.cat.help，返回es.cat的帮助信息。 print(es.cat.help()) es.cat.indices，返回索引的信息；也可以使用此命令进行查询集群中有多少索引。 print(es.cat.indices()) print(es.cat.indices(index='py3')) print(es.cat.indices(index='py3', format='json')) print(len(es.cat.indices(format='json'))) # 查询集群中有多少索引 es.cat.master，返回集群中主节点的IP，绑定IP和节点名称。 print(es.cat.master()) print(es.cat.master(format='json')) es.cat.nodeattrs，返回节点的自定义属性。 print(es.cat.nodeattrs()) print(es.cat.nodeattrs(format='json')) es.cat.nodes，返回节点的拓扑，这些信息在查看整个集群时通常很有用，特别是大型集群。我有多少符合条件的节点？ print(es.cat.nodes()) print(es.cat.nodes(format='json')) es.cat.plugins，返回节点的插件信息。 print(es.cat.plugins()) print(es.cat.plugins(format='json')) es.cat.segments，返回每个索引的Lucene有关的信息。 print(es.cat.segments()) print(es.cat.segments(index='py3')) print(es.cat.segments(index='py3', format='json')) es.cat.shards，返回哪个节点包含哪些分片的信息。 print(es.cat.shards()) print(es.cat.shards(index='py3')) print(es.cat.shards(index='py3', format='json')) es.cat.thread_pool，获取有关线程池的信息。 print(es.cat.thread_pool()) ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:7:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"八 Snapshot（快照相关） es.snapshot.create，在存储库中创建快照。 repository 存储库名称。 snapshot快照名称。 body快照定义。 es.snapshot.delete，从存储库中删除快照。 es.snapshot.create_repository。注册共享文件系统存储库。 es.snapshot.delete_repository，删除共享文件系统存储库。 es.snapshot.get，检索有关快照的信息。 es.snapshot.get_repository，返回有关已注册存储库的信息。 es.snapshot.restore，恢复快照。 es.snapshot.status，返回有关所有当前运行快照的信息。通过指定存储库名称，可以将结果限制为特定存储库。 es.snapshot.verify_repository，返回成功验证存储库的节点列表，如果验证过程失败，则返回错误消息。 ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:8:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"九 Task（任务相关） es.tasks.get，检索特定任务的信息。 es.tasks.cancel，取消任务。 es.tasks.list，任务列表。 ","date":"2023-08-31","objectID":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/:9:0","tags":["文档操作"],"title":"文档操作-python操作","uri":"/posts/09-17-elasticsearch-for-python%E4%B9%8B%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"一 前言 现在，我们来学习Python如何操作elasticsearch。 ","date":"2023-08-31","objectID":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/:1:0","tags":["文档操作"],"title":"文档操作-python连接","uri":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"二 依赖下载 首先，我们必须拥有Python的环境，如何搭建Python环境，请参阅。 要用Python来操作elasticsearch，首先安装Python的elasticsearch包： pip install elasticsearch pip install elasticsearch==6.3.1 # 豆瓣源 pip install -i https://pypi.doubanio.com/simple/ elasticsearch ","date":"2023-08-31","objectID":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/:2:0","tags":["文档操作"],"title":"文档操作-python连接","uri":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"三 Python连接elasticsearch Python连接elasticsearch有以下几种连接方式： from elasticsearch import Elasticsearch # es = Elasticsearch() # 默认连接本地elasticsearch # es = Elasticsearch(['127.0.0.1:9200']) # 连接本地9200端口 es = Elasticsearch( [\"192.168.1.10\", \"192.168.1.11\", \"192.168.1.12\"], # 连接集群，以列表的形式存放各节点的IP地址 sniff_on_start=True, # 连接前测试 sniff_on_connection_fail=True, # 节点无响应时刷新节点 sniff_timeout=60 # 设置超时时间 ) ","date":"2023-08-31","objectID":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/:3:0","tags":["文档操作"],"title":"文档操作-python连接","uri":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"四 配置忽略响应状态码 es = Elasticsearch(['127.0.0.1:9200'],ignore=400) # 忽略返回的400状态码 es = Elasticsearch(['127.0.0.1:9200'],ignore=[400, 405, 502]) # 以列表的形式忽略多个状态码 ","date":"2023-08-31","objectID":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/:4:0","tags":["文档操作"],"title":"文档操作-python连接","uri":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"五 一个简单的示例 from elasticsearch import Elasticsearch es = Elasticsearch() # 默认连接本地elasticsearch print(es.index(index='py2', doc_type='doc', id=1, body={'name': \"张开\", \"age\": 18})) print(es.get(index='py2', doc_type='doc', id=1)) 第1个print为创建py2索引，并插入一条数据，第2个print查询指定文档。 查询结果如下： {'_index': 'py2', '_type': 'doc', '_id': '1', '_version': 1, 'result': 'created', '_shards': {'total': 2, 'successful': 1, 'failed': 0}, '_seq_no': 0, '_primary_term': 1} {'_index': 'py2', '_type': 'doc', '_id': '1', '_version': 1, 'found': True, '_source': {'name': '张开', 'age': 18}} ","date":"2023-08-31","objectID":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/:5:0","tags":["文档操作"],"title":"文档操作-python连接","uri":"/posts/09-16-elasticsearch-for-python%E4%B9%8B%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"一 match查询 ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.1 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:1","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.2 match系列之match（按条件查询） 我们查看来自顾家的都有哪些人。 GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } } } 上例，查询条件是一步步构建出来的，将查询条件添加到match中即可，而match则是查询所有from字段的值中含有gu的结果就会返回。 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:2","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.3 match系列之match_all（查询全部） 除了按条件查询之外，我们还可以查询lqz索引下的doc类型中的所有文档，那就是查询全部： GET lqz/doc/_search { \"query\": { \"match_all\": {} } } match_all的值为空，表示没有查询条件，那就是查询全部。就像select * from table_name一样。 查询结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"5\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"魏行首\", \"age\" : 25, \"from\" : \"广云台\", \"desc\" : \"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\" : [ \"闭月\", \"羞花\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 返回的是lqz索引下doc类型的所有文档！ ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:3","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.4 match系列之match_phrase（短语查询） 我们现在已经对match有了基本的了解，match查询的是散列映射，包含了我们希望搜索的字段和字符串。也就说，只要文档中只要有我们希望的那个关键字，但也因此带来了一些问题。 首先来创建一些示例： PUT t1/doc/1 { \"title\": \"中国是世界上人口最多的国家\" } PUT t1/doc/2 { \"title\": \"美国是世界上军事实力最强大的国家\" } PUT t1/doc/3 { \"title\": \"北京是中国的首都\" } 现在，当我们以中国作为搜索条件，我们希望只返回和中国相关的文档。我们首先来使用match查询： GET t1/doc/_search { \"query\": { \"match\": { \"title\": \"中国\" } } } 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.68324494, \"hits\" : [ { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.68324494, \"_source\" : { \"title\" : \"中国是世界上人口最多的国家\" } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.5753642, \"_source\" : { \"title\" : \"北京是中国的首都\" } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.39556286, \"_source\" : { \"title\" : \"美国是世界上军事实力最强大的国家\" } } ] } } 虽然如期的返回了中国的文档。但是却把和美国的文档也返回了，这并不是我们想要的。是怎么回事呢？因为这是elasticsearch在内部对文档做分词的时候，对于中文来说，就是一个字一个字分的，所以，我们搜中国，中和国都符合条件，返回，而美国的国也符合。 而我们认为中国是个短语，是一个有具体含义的词。所以elasticsearch在处理中文分词方面比较弱势。后面会讲针对中文的插件。 但目前我们还有办法解决，那就是使用短语查询： GET t1/doc/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"中国\" } } } } 这里match_phrase是在文档中搜索指定的词组，而中国则正是一个词组，所以愉快的返回了。 那么，现在我们要想搜索中国和世界相关的文档，但又忘记其余部分了，怎么做呢？用match也不行，那就继续用match_phrase试试： GET t1/doc/_search { \"query\": { \"match_phrase\": { \"title\": \"中国世界\" } } } 返回结果也是空的，因为没有中国世界这个短语。 我们搜索中国和世界这两个指定词组时，但又不清楚两个词组之间有多少别的词间隔。那么在搜的时候就要留有一些余地。这时就要用到了slop了。相当于正则中的中国.*?世界。这个间隔默认为0，导致我们刚才没有搜到,现在我们指定一个间隔。 GET t1/doc/_search { \"query\": { \"match_phrase\": { \"title\": { \"query\": \"中国世界\", \"slop\": 2 } } } } 现在，两个词组之间有了2个词的间隔，这个时候，就可以查询到结果了： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.7445889, \"hits\" : [ { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.7445889, \"_source\" : { \"title\" : \"中国是世界上人口最多的国家\" } } ] } } slop间隔你可以根据需要适当改动。 短语查询， 比如要查询：python系统 会把查询条件python和系统分词，放到列表中，再去搜索的时候，必须满足python和系统同时存在的才能搜出来 “slop”:6 ：python和系统这两个词之间最小的距离 ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:4","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.4 match系列之match_phrase_prefix（最左前缀查询） 现在凌晨2点半，单身狗小黑为了缓解寂寞，就准备搜索几个beautiful girl来陪伴自己。但是由于英语没过2级，但单词beautiful拼到bea就不知道往下怎么拼了。这个时候，我们的智能搜索要帮他啊，elasticsearch就看自己的词库有啥事bea开头的词，结果还真发现了两个： PUT t3/doc/1 { \"title\": \"maggie\", \"desc\": \"beautiful girl you are beautiful so\" } PUT t3/doc/2 { \"title\": \"sun and beach\", \"desc\": \"I like basking on the beach\" } 但这里用match和match_phrase都不太合适，因为小黑输入的不是完整的词。那怎么办呢？我们用match_phrase_prefix来搞： GET t3/doc/_search { \"query\": { \"match_phrase_prefix\": { \"desc\": \"bea\" } } } 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.39556286, \"hits\" : [ { \"_index\" : \"t3\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.39556286, \"_source\" : { \"title\" : \"maggie\", \"desc\" : \"beautiful girl,you are beautiful so\" } }, { \"_index\" : \"t3\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.2876821, \"_source\" : { \"title\" : \"sun and beach\", \"desc\" : \"I like basking on the beach\" } } ] } } 前缀查询是短语查询类似，但前缀查询可以更进一步的搜索词组，只不过它是和词组中最后一个词条进行前缀匹配（如搜这样的you are bea）。应用也非常的广泛，比如搜索框的提示信息，当使用这种行为进行搜索时，最好通过max_expansions来设置最大的前缀扩展数量，因为产生的结果会是一个很大的集合，不加限制的话，影响查询性能。 GET t3/doc/_search { \"query\": { \"match_phrase_prefix\": { \"desc\": { \"query\": \"bea\", \"max_expansions\": 1 } } } } 但是，如果此时你去尝试加上max_expansions测试后，你会发现并没有如你想想的一样，仅返回一条数据，而是返回了多条数据。 max_expansions执行的是搜索的编辑（Levenshtein）距离。那什么是编辑距离呢？编辑距离是一种计算两个字符串间的差异程度的字符串度量（string metric）。我们可以认为编辑距离就是从一个字符串修改到另一个字符串时，其中编辑单个字符（比如修改、插入、删除）所需要的最少次数。俄罗斯科学家Vladimir Levenshtein于1965年提出了这一概念。 我们再引用elasticsearch官网的一段话：该max_expansions设置定义了在停止搜索之前模糊查询将匹配的最大术语数，也可以对模糊查询的性能产生显着影响。但是，减少查询字词会产生负面影响，因为查询提前终止可能无法找到某些有效结果。重要的是要理解max_expansions查询限制在分片级别工作，这意味着即使设置为1，多个术语可能匹配，所有术语都来自不同的分片。此行为可能使其看起来好像max_expansions没有生效，因此请注意，计算返回的唯一术语不是确定是否有效的有效方法max_expansions。。 我想你也没看懂这句话是啥意思，但我们只需知道该参数工作于分片层，也就是Lucene部分，超出我们的研究范围了。 我们快刀斩乱麻的记住，使用前缀查询会非常的影响性能，要对结果集进行限制，就加上这个参数。 ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:5","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.5 match系列之multi_match（多字段查询） 现在，我们有一个50个字段的索引，我们要在多个字段中查询同一个关键字，该怎么做呢？ PUT t3/doc/1 { \"title\": \"maggie is beautiful girl\", \"desc\": \"beautiful girl you are beautiful so\" } PUT t3/doc/2 { \"title\": \"beautiful beach\", \"desc\": \"I like basking on the beach,and you? beautiful girl\" } 我们先用原来的方法查询： GET t3/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"title\": \"beautiful\" } }, { \"match\": { \"desc\": \"beautiful\" } } ] } } } 使用must来限制两个字段（值）中必须同时含有关键字。这样虽然能达到目的，但是当有很多的字段呢，我们可以用multi_match来做： GET t3/doc/_search { \"query\": { \"multi_match\": { \"query\": \"beautiful\", \"fields\": [\"title\", \"desc\"] } } } 我们将多个字段放到fields列表中即可。以达到匹配多个字段的目的。 除此之外，multi_match甚至可以当做match_phrase和match_phrase_prefix使用，只需要指定type类型即可： GET t3/doc/_search { \"query\": { \"multi_match\": { \"query\": \"gi\", \"fields\": [\"title\"], \"type\": \"phrase_prefix\" } } } GET t3/doc/_search { \"query\": { \"multi_match\": { \"query\": \"girl\", \"fields\": [\"title\"], \"type\": \"phrase\" } } } 小结： match：返回所有匹配的分词。 match_all：查询全部。 match_phrase：短语查询，在match的基础上进一步查询词组，可以指定slop分词间隔。 match_phrase_prefix：前缀查询，根据短语中最后一个词组做前缀匹配，可以应用于搜索提示，但注意和max_expanions搭配。其实默认是50……. multi_match：多字段查询，使用相当的灵活，可以完成match_phrase和match_phrase_prefix的工作。 ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:1:6","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 term查询 默认情况下，elasticsearch在对文档分析期间（将文档分词后保存到倒排索引中），会对文档进行分词，比如默认的标准分析器会对文档进行： 删除大多数的标点符号。 将文档分解为单个词条，我们称为token。 将token转为小写。 完事再保存到倒排索引上，当然，原文件还是要保存一分的，而倒排索引使用来查询的。 例如Beautiful girl!，在经过分析后是这样的了： POST _analyze { \"analyzer\": \"standard\", \"text\": \"Beautiful girl!\" } # 结果 [\"beautiful\", \"girl\"] 而当在使用match查询时，elasticsearch同样会对查询关键字进行分析： PUT w10 { \"mappings\": { \"doc\":{ \"properties\":{ \"t1\":{ \"type\": \"text\" } } } } } PUT w10/doc/1 { \"t1\": \"Beautiful girl!\" } PUT w10/doc/2 { \"t1\": \"sexy girl!\" } GET w10/doc/_search { \"query\": { \"match\": { \"t1\": \"Beautiful girl!\" } } } 也就是对查询关键字Beautiful girl!进行分析，得到[\"beautiful\", \"girl\"]，然后分别将这两个单独的token去索引w10中进行查询，结果就是将两篇文档都返回。 这在有些情况下是非常好用的，但是，如果我们想查询确切的词怎么办？也就是精确查询，将Beautiful girl!当成一个token而不是分词后的两个token。 这就要用到了term查询了，term查询的是没有经过分析的查询关键字。 但是，这同样需要限制，如果你要查询的字段类型（如上例中的字段t1类型是text）是text（因为elasticsearch会对文档进行分析，上面说过），那么你得到的可能是不尽如人意的结果或者压根没有结果： GET w10/doc/_search { \"query\": { \"term\": { \"t1\": \"Beautiful girl!\" } } } 如上面的查询，将不会有结果返回，因为索引w10中的两篇文档在经过elasticsearch分析后没有一个分词是Beautiful girl!，那此次查询结果为空也就好理解了。 所以，我们这里得到一个论证结果：不要使用term对类型是text的字段进行查询，要查询text类型的字段，请改用match查询。 学会了吗？那再来一个示例，你说一下结果是什么： GET w10/doc/_search { \"query\": { \"term\": { \"t1\": \"Beautiful\" } } } 答案是，没有结果返回！因为elasticsearch在对文档进行分析时，会经过小写！人家倒排索引上存的是小写的beautiful，而我们查询的是大写的Beautiful。 所以，要想有结果你这样： GET w10/doc/_search { \"query\": { \"term\": { \"t1\": \"beautiful\" } } } 那，term查询可以查询哪些类型的字段呢，例如elasticsearch会将keyword类型的字段当成一个token保存到倒排索引上，你可以将term和keyword结合使用。 最后，要想使用term查询多个精确的值怎么办？我只能说：亲，这里推荐卸载es呢！低调又不失尴尬的玩笑！ 这里推荐使用terms查询： GET w10/doc/_search { \"query\": { \"terms\": { \"t1\": [\"beautiful\", \"sexy\"] } } } ","date":"2023-08-31","objectID":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-term于match查询","uri":"/posts/09-3-term%E4%B8%8Ematch%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 前言 布尔查询是最常用的组合查询，根据子查询的规则，只有当文档满足所有子查询条件时，elasticsearch引擎才将结果返回。布尔查询支持的子查询条件共4中： must（and） should（or） must_not（not） filter 下面我们来看看每个子查询条件都是怎么玩的。 ","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"三 must 现在，我们用布尔查询所有from属性为gu的数据： GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"gu\" } } ] } } } 上例中，我们通过在bool属性（字段）内使用must来作为查询条件，那么条件是什么呢？条件同样被match包围，就是from为gu的所有数据。 这里需要注意的是must字段对应的是个列表，也就是说可以有多个并列的查询条件，一个文档满足各个子条件后才最终返回。 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 上例中，可以看到，所有from属性为gu的数据查询出来了。 那么，我们想要查询from为gu，并且age为30的数据怎么搞呢？ GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"gu\" } }, { \"match\": { \"age\": 30 } } ] } } } 上例中，在must列表中，在增加一个age为30的条件。 结果如下： { \"took\" : 8, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 1.287682, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 1.287682, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } } ] } } 上例，符合条件的数据被成功查询出来了。 注意：现在你可能慢慢发现一个现象，所有属性值为列表的，都可以实现多个条件并列存在 ","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:3:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"四 should 那么，如果要查询只要是from为gu或者tags为闭月的数据怎么搞？ GET lqz/doc/_search { \"query\": { \"bool\": { \"should\": [ { \"match\": { \"from\": \"gu\" } }, { \"match\": { \"tags\": \"闭月\" } } ] } } } 上例中，或关系的不能用must的了，而是要用should，只要符合其中一个条件就返回。 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 4, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"5\", \"_score\" : 0.5753642, \"_source\" : { \"name\" : \"魏行首\", \"age\" : 25, \"from\" : \"广云台\", \"desc\" : \"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\" : [ \"闭月\", \"羞花\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 返回了所有符合条件的结果。 ","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:4:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"五 must_not 那么，如果我想要查询from既不是gu并且tags也不是可爱，还有age不是18的数据怎么办？ GET lqz/doc/_search { \"query\": { \"bool\": { \"must_not\": [ { \"match\": { \"from\": \"gu\" } }, { \"match\": { \"tags\": \"可爱\" } }, { \"match\": { \"age\": 18 } } ] } } } 上例中，must和should都不能使用，而是使用must_not，又在内增加了一个age为18的条件。 结果如下： { \"took\" : 9, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"5\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"魏行首\", \"age\" : 25, \"from\" : \"广云台\", \"desc\" : \"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\" : [ \"闭月\", \"羞花\" ] } } ] } } 上例中，只有魏行首这一条数据，因为只有魏行首既不是顾家的人，标签没有可爱那一项，年龄也不等于18！ 这里有点需要补充，条件中age对应的18你写成整形还是字符串都没啥…… ","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:5:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"6 filter 那么，如果要查询from为gu，age大于25的数据怎么查？ GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"gu\" } } ], \"filter\": { \"range\": { \"age\": { \"gt\": 25 } } } } } } 这里就用到了filter条件过滤查询，过滤条件的范围用range表示，gt表示大于，大于多少呢？是25。 结果如下： { \"took\" : 2, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } } ] } } 上例中，age大于25的条件都已经筛选出来了。 那么要查询from是gu，age大于等于30的数据呢？ GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"gu\" } } ], \"filter\": { \"range\": { \"age\": { \"gte\": 30 } } } } } } 上例中，大于等于用gte表示。 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.2876821, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } } ] } } 那么，要查询age小于25的呢？ GET lqz/doc/_search { \"query\": { \"bool\": { \"filter\": { \"range\": { \"age\": { \"lt\": 25 } } } } } } 上例中，小于用lt表示，结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.0, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.0, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.0, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 在查询一个age小于等于18的怎么办呢？ GET lqz/doc/_search { \"query\": { \"bool\": { \"filter\": { \"range\": { \"age\": { \"lte\": 18 } } } } } } 上例中，小于等于用lte表示。结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.0, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.0, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] } } ] } } 要查询from是gu，age在25~30之间的怎么查？ GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"gu\" } } ], \"filter\": { \"range\": { \"age\": { \"gte\": 25, \"lte\": 30 } } } } } } 上例中，使用lte和gte来限定范围。结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 2, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } } ] } } 那么，要查询from是sheng，age小于等于25的怎么查呢？其实结果，我们可能已经想到了，只有一条，因为只有盛家小六符合结果。 GET lqz/doc/_search { \"query\": { \"bool\": { \"must\": [ { \"match\": { \"from\": \"sheng\" } } ], \"filter\": { \"range\": { \"age\": { \"lte\": 25 } } } } } } 结果果然不出洒家所料！ { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] } } ] } } 但是，洒家手一抖，将must换为should看看会发生什么？ GET lqz/doc/_search { \"query\": { \"bool\": { \"should\": [ { \"match\": { \"from\": \"sheng\" } } ], \"filter\": { \"range\": { \"age\": { \"lt","date":"2023-08-31","objectID":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/:6:0","tags":["文档操作"],"title":"文档操作-布尔查询","uri":"/posts/09-6-elasticsearch%E4%B9%8B%E5%B8%83%E5%B0%94%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":" 查询分类： 基本查询：使用es内置查询条件进行查询 组合查询：把多个查询组合在一起进行复合查询 过滤：查询的同时，通过filter条件在不影响打分的情况下筛选数据 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:0:0","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 基本查询 #添加映射 PUT lago { \"mappings\": { \"properties\":{ \"title\":{ \"stort\":true, \"type\":\"text\", \"analyzer\":\"ik_max_word\" }, \"company_name\":{ \"stort\":true, \"type\":\"keyword\", }, \"desc\":{ \"type\":\"text\" }, \"comments\":{ \"type\":\"integer\" }, \"add_time\":{ \"type\":\"date\", \"format\":\"yyy-MM-dd\" } } } } #测试数据 POST lago/job { \"title\":\"python django 开发工程师\", \"company_name\":\"美团科技有限公司\", \"desc\":\"对django熟悉，掌握mysql和非关系型数据库，网站开发\", \"comments:200, \"add_time\":\"2018-4-1\" } POST lago/job { \"title\":\"python数据分析\", \"company_name\":\"百度科技有限公司\", \"desc\":\"熟悉python基础语法，熟悉数据分析\", \"comments:5, \"add_time\":\"2018-10-1\" } POST lago/job { \"title\":\"python自动化运维\", \"company_name\":\"上海华为\", \"desc\":\"熟悉python基础语法，精通Linux\", \"comments:90, \"add_time\":\"2019-9-18\" } ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.1 match查询 GET lagou/job/_search { \"query\":{ \"match\":{ \"title\":\"python\" } } } #因为title字段做了分词，python都能搜索出来 #搜索python网站也能搜索出来，把python和网站分成两个词 #搜索爬取也能搜索到，把爬和取分词，去搜索 #只搜取 搜不到 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:1","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.2 term查询 GET lagou/_search { \"query\":{ \"term\":{ \"title\":\"python\" } } } #会拿着要查询的词不做任何处理，直接查询 #用python爬虫，查不到，用match就能查到 { \"query\":{ \"term\":{ \"company_name\":\"美团\" } } } #通过美团，就查询不到 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:2","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.3 terms查询 GET lagou/_search { \"query\":{ \"terms\":{ \"title\":[\"工程师\",\"django\",\"运维\"] } } } #三个词，只要有一个，就会查询出来 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:3","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.4 控制查询的返回数量（分页） GET lagou/_search { \"query\":{ \"match\":{ \"title\":\"python\" } }， \"form\":1, \"size\":2 } #从第一条开始，大小为2 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:4","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.5 match_all 查询 GET lagou/_search { \"query\":{ \"match_all\":{} } } #所有数据都返回 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:5","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.6 match_phrase查询 GET lagou/_search { \"query\":{ \"match_phrase\":{ \"title\":{ \"query\":\"python系统\", \"slop\":6 } } } } #短语查询， #会把查询条件python和系统分词，放到列表中，再去搜索的时候，必须满足python和系统同时存在的才能搜出来 #\"slop\":6 ：python和系统这两个词之间最小的距离 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:6","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.7 multi_match GET lagou/_search { \"query\":{ \"multy_match\":{ \"query\":\"python\", \"fields\":[\"title\",\"desc\"] } } } #可以指定多个字段 #比如查询title和desc这个两个字段中包含python关键词的文档 #\"fields\":[\"title^3\",\"desc\"]:权重，title中的python是desc中的三倍 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:7","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.8 指定返回的字段 GET lagou/_search { \"query\":{ \"stored_fields\":[\"title\",\"company_name\"] \"match\":{ \"title\":\"python\" } } } #只返回title和company_name字段 #\"stored_fields\":[\"title\",\"company_name\",'dsc'],不会返回dsc，因为我们要求stroed_fields，之前desc字段设为false（默认），不会显示 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:8","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.9 sort 结果排序 GET lagou/_search { \"query\":{ \"match_all\":{} }, \"sort\":[ { \"comments\":{ \"order\":\"desc\" } } ] } #查询所有文档，按comments按desc降序排序 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:9","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.10 range范围查询 GET lagou/_search { \"query\":{ \"range\":{ \"comments\":{ \"gte\":10, \"lte\":20, \"boost\":2.0 } } } } #指定comments字段大于等于10，小于等于20 #boost：权重 GET lagou/_search { \"query\":{ \"range\":{ \"add_time\":{ \"gte\":\"2019-10-11\", \"lte\":\"now\", } } } } #对时间进行查询 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:10","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.11 wildcard查询 GET lagou/_search { \"query\":{ \"wildcard\":{ \"title\":{ \"value\":\"pyth*n\", \"boost\":2.0 } } } } #模糊查询，title中，有pyth任意值n得都能查出来 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:1:11","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 组合查询 ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"2.1 bool查询 #bool查询包括must should must_not filter ''' bool:{ \"filter\":[], 字段过滤 \"must\":[], 所有查询条件都满足 \"should\":[], 满足一个或多个 \"must_not\":{} 都不满足于must相反 } ''' # 建立测试数据 POST lago/testjob/_bulk {\"index\":{\"_id\":1}} {\"salary\":10,\"title\":\"Python\"} {\"index\":{\"_id\":2}} {\"salary\":20,\"title\":\"Scrapy\"} {\"index\":{\"_id\":3}} {\"salary\":30,\"title\":\"Django\"} {\"index\":{\"_id\":4}} {\"salary\":30,\"title\":\"Elasticsearch\"} ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:2:1","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"2.2 简单过滤查询 #select * from testjob where salary=20 GET lagou/testjob/_search { \"query\":{ \"bool\":{ \"must\":{ \"match_all\":{} }, \"filter\":{ \"term\":{ \"salary\":20 } } } } } ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:2:2","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.3 查询多个值 #查询薪资是10k或20k的 GET lagou/testjob/_search { \"query\":{ \"bool\":{ \"must\":{ \"match_all\":{} }, \"filter\":{ \"terms\":{ \"salary\":[10,20] } } } } } #select * from testjob where title=\"python\" GET lagou/testjob/_search { \"query\":{ \"bool\":{ \"must\":{ \"match_all\":{} }, \"filter\":{ \"term\":{ \"title\":\"Python\" } } } } } #title 是text字段，会做大小写转换，term不会预处理，拿着大写Python去查查不到 #可以改成小写，或者用match来查询 ''' \"filter\":{ \"match\":{ \"title\":\"Python\" } } ''' #查看分析器解析结果 GET _analyze { \"analyzer\":\"ik_max_word\", \"text\":\"python网络开发工程师\" } ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:2:3","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"1.4 bool过滤查询，可以做组合过滤查询 #select * from testjob where (salary=20 or title=Python) and (salary!=30) #查询薪资等于20k或者工作为python的工作，排除价格为30k的 { \"query\":{ \"bool\":{ \"should\":[ {\"term\":{\"salary\":20}}, {\"term\":{\"title\":\"python\"}} ], \"must_not\":{ \"term\":{\"salary\":30} } } } } #select * from testjob where title=python or (title=django and salary=30) { \"query\":{ \"bool\":{ \"should\":[ {\"term\":{\"title\":\"python\"}}, { \"bool\":{ \"must\":[ {\"term\":{\"title\":\"django\"}}, {\"term\":{\"salary\":30}} ] } } ] } } } ","date":"2023-08-31","objectID":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/:2:4","tags":["文档操作"],"title":"文档操作-查询","uri":"/posts/10-elasticsearch%E4%B9%8B-%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 前言 简单的没挑战，来点复杂的，elasticsearch提供两种查询方式： 查询字符串(query string)，简单查询，就像是像传递URL参数一样去传递查询语句，被称为简单搜索或查询字符串(query string)搜索。 另外一种是通过DSL语句来进行查询，被称为DSL查询(Query DSL),DSL是Elasticsearch提供的一种丰富且灵活的查询语言，该语言以json请求体的形式出现，通过restful请求与Elasticsearch进行交互。 ","date":"2023-08-31","objectID":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:1:0","tags":["文档操作"],"title":"文档操作-查询的两种方式","uri":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["ElasticSearch"],"content":"二 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:2:0","tags":["文档操作"],"title":"文档操作-查询的两种方式","uri":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["ElasticSearch"],"content":"三 查询字符串 GET lqz/doc/_search?q=from:gu 还是使用GET命令，通过_serarch查询，查询条件是什么呢？条件是from属性是gu家的人都有哪些。最后，别忘了_search和from属性中间的英文分隔符? 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 我们来重点说下hits，hits是返回的结果集——所有from属性为gu的结果集。重点中的重点是_score得分，得分是什么呢？根据算法算出跟查询条件的匹配度，匹配度高得分就高。后面再说这个算法是怎么回事。 ","date":"2023-08-31","objectID":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:3:0","tags":["文档操作"],"title":"文档操作-查询的两种方式","uri":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["ElasticSearch"],"content":"四 结构化查询 我们现在使用DSL方式，来完成刚才的查询，查看来自顾家的都有哪些人。 GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } } } 上例，查询条件是一步步构建出来的，将查询条件添加到match中即可，而match则是查询所有from字段的值中含有gu的结果就会返回。 当然结果没啥变化： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } ","date":"2023-08-31","objectID":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/:4:0","tags":["文档操作"],"title":"文档操作-查询的两种方式","uri":"/posts/09-2-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":["ElasticSearch"],"content":"一 前言 在未来，一篇文档可能有很多的字段，每次查询都默认给我们返回全部，在数据量很大的时候，是的，比如我只想查姑娘的手机号，你一并给我个喜好啊、三围什么的算什么？ 所以，我们对结果做一些过滤，清清白白的告诉elasticsearch ","date":"2023-08-31","objectID":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/:1:0","tags":["文档操作"],"title":"文档操作-查询结果过滤","uri":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/"},{"categories":["ElasticSearch"],"content":"二 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } ","date":"2023-08-31","objectID":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/:2:0","tags":["文档操作"],"title":"文档操作-查询结果过滤","uri":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/"},{"categories":["ElasticSearch"],"content":"三 结果过滤：_source 现在，在所有的结果中，我只需要查看name和age两个属性，其他的不要怎么办？ GET lqz/doc/_search { \"query\": { \"match\": { \"name\": \"顾老二\" } }, \"_source\": [\"name\", \"age\"] } 如上例所示，在查询中，通过_source来控制仅返回name和age属性。 { \"took\" : 8, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.8630463, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.8630463, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30 } } ] } } 在数据量很大的时候，我们需要什么字段，就返回什么字段就好了，提高查询效率 ","date":"2023-08-31","objectID":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/:3:0","tags":["文档操作"],"title":"文档操作-查询结果过滤","uri":"/posts/09-7-elasticsearch%E4%B9%8B%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%87%E6%BB%A4/"},{"categories":["ElasticSearch"],"content":"一 前言 现在，我们已经了解了如何建立索引和搜索数据了。 那么，是时候来探索背后的故事了！当数据传递到elasticsearch后，到底发生了什么？ ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:1:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"二分析过程 当数据被发送到elasticsearch后并加入到倒排索引之前，elasticsearch会对该文档的进行一系列的处理步骤： 字符过滤：使用字符过滤器转变字符。 文本切分为分词：将文本（档）分为单个或多个分词。 分词过滤：使用分词过滤器转变每个分词。 分词索引：最终将分词存储在Lucene倒排索引中。 整体流程如下图所示： 接下来，我们简要的介绍elasticsearch中的分析器、分词器和分词过滤器。它们配置简单，灵活好用，我们可以通过不同的组合来获取我们想要的分词！ 是的，无论多么复杂的分析过程，都是为了获取更加人性化的分词！ 接下来，我们来看看其中，在整个分析过程的各个组件吧。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:2:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"三分析器 在elasticsearch中，一个分析器可以包括： 可选的字符过滤器 一个分词器 0个或多个分词过滤器 接下来简要的介绍各内置分词的大致情况。在介绍之前，为了方便演示。如果你已经按照之前的教程安装了ik analysis，现在请暂时将该插件移出plugins目录。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.1 标准分析器：standard analyzer 标准分析器（standard analyzer）：是elasticsearch的默认分析器，该分析器综合了大多数欧洲语言来说合理的默认模块，包括标准分词器、标准分词过滤器、小写转换分词过滤器和停用词分词过滤器。 POST _analyze { \"analyzer\": \"standard\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 分词结果如下： { \"tokens\" : [ { \"token\" : \"to\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 5 }, { \"token\" : \"that\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 9 }, { \"token\" : \"莎\", \"start_offset\" : 45, \"end_offset\" : 46, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 10 }, { \"token\" : \"士\", \"start_offset\" : 46, \"end_offset\" : 47, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 11 }, { \"token\" : \"比\", \"start_offset\" : 47, \"end_offset\" : 48, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 12 }, { \"token\" : \"亚\", \"start_offset\" : 48, \"end_offset\" : 49, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 13 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:1","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.2 简单分析器：simple analyzer 简单分析器（simple analyzer）：简单分析器仅使用了小写转换分词，这意味着在非字母处进行分词，并将分词自动转换为小写。这个分词器对于亚种语言来说效果不佳，因为亚洲语言不是根据空白来分词的，所以一般用于欧洲言中。 POST _analyze { \"analyzer\": \"simple\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 分词结果如下： { \"tokens\" : [ { \"token\" : \"to\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"that\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 10 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:2","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.3 空白分析器：whitespace analyzer 空白（格）分析器（whitespace analyzer）：这玩意儿只是根据空白将文本切分为若干分词，真是有够偷懒！ POST _analyze { \"analyzer\": \"whitespace\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 分词结果如下： { \"tokens\" : [ { \"token\" : \"To\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be,\", \"start_offset\" : 16, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"That\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"————\", \"start_offset\" : 40, \"end_offset\" : 44, \"type\" : \"word\", \"position\" : 10 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 11 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:3","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.4 停用词分析器：stop analyzer 停用词分析（stop analyzer）和简单分析器的行为很像，只是在分词流中额外的过滤了停用词。 POST _analyze { \"analyzer\": \"stop\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果也很简单： { \"tokens\" : [ { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 10 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:4","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.5 关键词分析器：keyword analyzer 关键词分析器（keyword analyzer）将整个字段当做单独的分词，如无必要，我们不在映射中使用关键词分析器。 POST _analyze { \"analyzer\": \"keyword\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To be or not to be, That is a question ———— 莎士比亚\", \"start_offset\" : 0, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 0 } ] } 说的一点没错，分析结果是将整段当做单独的分词。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:5","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.6 模式分析器：pattern analyzer 模式分析器（pattern analyzer）允许我们指定一个分词切分模式。但是通常更佳的方案是使用定制的分析器，组合现有的模式分词器和所需要的分词过滤器更加合适。 POST _analyze { \"analyzer\": \"pattern\", \"explain\": false, \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"to\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"that\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 } ] } 我们来自定制一个模式分析器，比如我们写匹配邮箱的正则。 PUT pattern_test { \"settings\": { \"analysis\": { \"analyzer\": { \"my_email_analyzer\":{ \"type\":\"pattern\", \"pattern\":\"\\\\W|_\", \"lowercase\":true } } } } } 上例中，我们在创建一条索引的时候，配置分析器为自定义的分析器。 需要注意的是，在json字符串中，正则的斜杠需要转义。 我们使用自定义的分析器来查询。 POST pattern_test/_analyze { \"analyzer\": \"my_email_analyzer\", \"text\": \"John_Smith@foo-bar.com\" } 结果如下： { \"tokens\" : [ { \"token\" : \"john\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"smith\", \"start_offset\" : 5, \"end_offset\" : 10, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"foo\", \"start_offset\" : 11, \"end_offset\" : 14, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"bar\", \"start_offset\" : 15, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"com\", \"start_offset\" : 19, \"end_offset\" : 22, \"type\" : \"word\", \"position\" : 4 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:6","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.7 语言和多语言分析器：chinese elasticsearch为很多世界流行语言提供良好的、简单的、开箱即用的语言分析器集合：阿拉伯语、亚美尼亚语、巴斯克语、巴西语、保加利亚语、加泰罗尼亚语、中文、捷克语、丹麦、荷兰语、英语、芬兰语、法语、加里西亚语、德语、希腊语、北印度语、匈牙利语、印度尼西亚、爱尔兰语、意大利语、日语、韩国语、库尔德语、挪威语、波斯语、葡萄牙语、罗马尼亚语、俄语、西班牙语、瑞典语、土耳其语和泰语。 我们可以指定其中之一的语言来指定特定的语言分析器，但必须是小写的名字！如果你要分析的语言不在上述集合中，可能还需要搭配相应的插件支持。 POST _analyze { \"analyzer\": \"chinese\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 9 }, { \"token\" : \"莎\", \"start_offset\" : 45, \"end_offset\" : 46, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 10 }, { \"token\" : \"士\", \"start_offset\" : 46, \"end_offset\" : 47, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 11 }, { \"token\" : \"比\", \"start_offset\" : 47, \"end_offset\" : 48, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 12 }, { \"token\" : \"亚\", \"start_offset\" : 48, \"end_offset\" : 49, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 13 } ] } 也可以是别语言： POST _analyze { \"analyzer\": \"french\", \"text\":\"Je suis ton père\" } POST _analyze { \"analyzer\": \"german\", \"text\":\"Ich bin dein vater\" } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:7","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"3.8 雪球分析器：snowball analyzer 雪球分析器（snowball analyzer）除了使用标准的分词和分词过滤器（和标准分析器一样）也是用了小写分词过滤器和停用词过滤器，除此之外，它还是用了雪球词干器对文本进行词干提取。 POST _analyze { \"analyzer\": \"snowball\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 9 }, { \"token\" : \"莎\", \"start_offset\" : 45, \"end_offset\" : 46, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 10 }, { \"token\" : \"士\", \"start_offset\" : 46, \"end_offset\" : 47, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 11 }, { \"token\" : \"比\", \"start_offset\" : 47, \"end_offset\" : 48, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 12 }, { \"token\" : \"亚\", \"start_offset\" : 48, \"end_offset\" : 49, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 13 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:3:8","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"四 字符过滤器 字符过滤器在``属性中定义，它是对字符流进行处理。字符过滤器种类不多。elasticearch只提供了三种字符过滤器： HTML字符过滤器（HTML Strip Char Filter） 映射字符过滤器（Mapping Char Filter） 模式替换过滤器（Pattern Replace Char Filter） 我们来分别看看都是怎么玩的吧！ ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:4:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"4.1 HTML字符过滤器 HTML字符过滤器（HTML Strip Char Filter）从文本中去除HTML元素。 POST _analyze { \"tokenizer\": \"keyword\", \"char_filter\": [\"html_strip\"], \"text\":\"\u003cp\u003eI\u0026apos;m so \u003cb\u003ehappy\u003c/b\u003e!\u003c/p\u003e\" } 结果如下： { \"tokens\" : [ { \"token\" : \"\"\" I'm so happy! \"\"\", \"start_offset\" : 0, \"end_offset\" : 32, \"type\" : \"word\", \"position\" : 0 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:4:1","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"4.2 映射字符过滤器 映射字符过滤器（Mapping Char Filter）接收键值的映射，每当遇到与键相同的字符串时，它就用该键关联的值替换它们。 PUT pattern_test4 { \"settings\": { \"analysis\": { \"analyzer\": { \"my_analyzer\":{ \"tokenizer\":\"keyword\", \"char_filter\":[\"my_char_filter\"] } }, \"char_filter\":{ \"my_char_filter\":{ \"type\":\"mapping\", \"mappings\":[\"苍井空 =\u003e 666\",\"武藤兰 =\u003e 888\"] } } } } } 上例中，我们自定义了一个分析器，其内的分词器使用关键字分词器，字符过滤器则是自定制的，将字符中的苍井空替换为666，武藤兰替换为888。 POST pattern_test4/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"苍井空热爱武藤兰，可惜后来苍井空结婚了\" } 结果如下： { \"tokens\" : [ { \"token\" : \"666热爱888，可惜后来666结婚了\", \"start_offset\" : 0, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 0 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:4:2","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"4.3 模式替换过滤器 模式替换过滤器（Pattern Replace Char Filter）使用正则表达式匹配并替换字符串中的字符。但要小心你写的抠脚的正则表达式。因为这可能导致性能变慢！ PUT pattern_test5 { \"settings\": { \"analysis\": { \"analyzer\": { \"my_analyzer\": { \"tokenizer\": \"standard\", \"char_filter\": [ \"my_char_filter\" ] } }, \"char_filter\": { \"my_char_filter\": { \"type\": \"pattern_replace\", \"pattern\": \"(\\\\d+)-(?=\\\\d)\", \"replacement\": \"$1_\" } } } } } 上例中，我们自定义了一个正则规则。 POST pattern_test5/_analyze { \"analyzer\": \"my_analyzer\", \"text\": \"My credit card is 123-456-789\" } 结果如下： { \"tokens\" : [ { \"token\" : \"My\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 0 }, { \"token\" : \"credit\", \"start_offset\" : 3, \"end_offset\" : 9, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"card\", \"start_offset\" : 10, \"end_offset\" : 14, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"is\", \"start_offset\" : 15, \"end_offset\" : 17, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 }, { \"token\" : \"123_456_789\", \"start_offset\" : 18, \"end_offset\" : 29, \"type\" : \"\u003cNUM\u003e\", \"position\" : 4 } ] } 我们大致的了解elasticsearch分析处理数据的流程。但可以看到的是，我们极少地在例子中演示中文处理。因为elasticsearch内置的分析器处理起来中文不是很好。所以，后续会介绍一个重量级的插件就是elasticsearch analysis ik（一般习惯称呼为ik分词器）。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:4:3","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"五 分词器 由于elasticsearch内置了分析器，它同样也包含了分词器。分词器，顾名思义，主要的操作是将文本字符串分解为小块，而这些小块这被称为分词token。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.1 标准分词器：standard tokenizer 标准分词器（standard tokenizer）是一个基于语法的分词器，对于大多数欧洲语言来说还是不错的，它同时还处理了Unicode文本的分词，但分词默认的最大长度是255字节，它也移除了逗号和句号这样的标点符号。 POST _analyze { \"tokenizer\": \"standard\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 5 }, { \"token\" : \"That\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 9 }, { \"token\" : \"莎\", \"start_offset\" : 45, \"end_offset\" : 46, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 10 }, { \"token\" : \"士\", \"start_offset\" : 46, \"end_offset\" : 47, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 11 }, { \"token\" : \"比\", \"start_offset\" : 47, \"end_offset\" : 48, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 12 }, { \"token\" : \"亚\", \"start_offset\" : 48, \"end_offset\" : 49, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 13 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:1","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.2 关键词分词器：keyword tokenizer 关键词分词器（keyword tokenizer）是一种简单的分词器，将整个文本作为单个的分词，提供给分词过滤器，当你只想用分词过滤器，而不做分词操作时，它是不错的选择。 POST _analyze { \"tokenizer\": \"keyword\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To be or not to be, That is a question ———— 莎士比亚\", \"start_offset\" : 0, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 0 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:2","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.3 字母分词器：letter tokenizer 字母分词器（letter tokenizer）根据非字母的符号，将文本切分成分词。 POST _analyze { \"tokenizer\": \"letter\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"That\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 10 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:3","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.4 小写分词器：lowercase tokenizer 小写分词器（lowercase tokenizer）结合了常规的字母分词器和小写分词过滤器（跟你想的一样，就是将所有的分词转化为小写）的行为。通过一个单独的分词器来实现的主要原因是，一次进行两项操作会获得更好的性能。 POST _analyze { \"tokenizer\": \"lowercase\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"to\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be\", \"start_offset\" : 16, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"that\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 10 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:4","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.5 空白分词器：whitespace tokenizer 空白分词器（whitespace tokenizer）通过空白来分隔不同的分词，空白包括空格、制表符、换行等。但是，我们需要注意的是，空白分词器不会删除任何标点符号。 POST _analyze { \"tokenizer\": \"whitespace\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To\", \"start_offset\" : 0, \"end_offset\" : 2, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"be\", \"start_offset\" : 3, \"end_offset\" : 5, \"type\" : \"word\", \"position\" : 1 }, { \"token\" : \"or\", \"start_offset\" : 6, \"end_offset\" : 8, \"type\" : \"word\", \"position\" : 2 }, { \"token\" : \"not\", \"start_offset\" : 9, \"end_offset\" : 12, \"type\" : \"word\", \"position\" : 3 }, { \"token\" : \"to\", \"start_offset\" : 13, \"end_offset\" : 15, \"type\" : \"word\", \"position\" : 4 }, { \"token\" : \"be,\", \"start_offset\" : 16, \"end_offset\" : 19, \"type\" : \"word\", \"position\" : 5 }, { \"token\" : \"That\", \"start_offset\" : 21, \"end_offset\" : 25, \"type\" : \"word\", \"position\" : 6 }, { \"token\" : \"is\", \"start_offset\" : 26, \"end_offset\" : 28, \"type\" : \"word\", \"position\" : 7 }, { \"token\" : \"a\", \"start_offset\" : 29, \"end_offset\" : 30, \"type\" : \"word\", \"position\" : 8 }, { \"token\" : \"question\", \"start_offset\" : 31, \"end_offset\" : 39, \"type\" : \"word\", \"position\" : 9 }, { \"token\" : \"————\", \"start_offset\" : 40, \"end_offset\" : 44, \"type\" : \"word\", \"position\" : 10 }, { \"token\" : \"莎士比亚\", \"start_offset\" : 45, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 11 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:5","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.6 模式分词器：pattern tokenizer 模式分词器（pattern tokenizer）允许指定一个任意的模式，将文本切分为分词。 POST _analyze { \"tokenizer\": \"pattern\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 现在让我们手动定制一个以逗号分隔的分词器。 PUT pattern_test2 { \"settings\": { \"analysis\": { \"analyzer\": { \"my_analyzer\":{ \"tokenizer\":\"my_tokenizer\" } }, \"tokenizer\": { \"my_tokenizer\":{ \"type\":\"pattern\", \"pattern\":\",\" } } } } } 上例中，在settings下的自定义分析器my_analyzer中，自定义的模式分词器名叫my_tokenizer；在与自定义分析器同级，为新建的自定义模式分词器设置一些属性，比如以逗号分隔。 POST pattern_test2/_analyze { \"tokenizer\": \"my_tokenizer\", \"text\":\"To be or not to be, That is a question ———— 莎士比亚\" } 结果如下： { \"tokens\" : [ { \"token\" : \"To be or not to be\", \"start_offset\" : 0, \"end_offset\" : 18, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \" That is a question ———— 莎士比亚\", \"start_offset\" : 19, \"end_offset\" : 49, \"type\" : \"word\", \"position\" : 1 } ] } 根据结果可以看到，文档被逗号分割为两部分。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:6","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.7 UAX URL电子邮件分词器：UAX RUL email tokenizer 在处理单个的英文单词的情况下，标准分词器是个非常好的选择，但是现在很多的网站以网址或电子邮件作为结尾，比如我们现在有这样的一个文本： 作者：张开 来源：未知 原文：https://www.cnblogs.com/Neeo/articles/10402742.html 邮箱：xxxxxxx@xx.com 版权声明：本文为博主原创文章，转载请附上博文链接！ 现在让我们使用标准分词器查看一下： POST _analyze { \"tokenizer\": \"standard\", \"text\":\"作者：张开来源：未知原文：https://www.cnblogs.com/Neeo/articles/10402742.html邮箱：xxxxxxx@xx.com版权声明：本文为博主原创文章，转载请附上博文链接！\" } 结果很长： { \"tokens\" : [ { \"token\" : \"作\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 0 }, { \"token\" : \"者\", \"start_offset\" : 1, \"end_offset\" : 2, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 1 }, { \"token\" : \"张\", \"start_offset\" : 3, \"end_offset\" : 4, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 2 }, { \"token\" : \"开\", \"start_offset\" : 4, \"end_offset\" : 5, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 3 }, { \"token\" : \"来\", \"start_offset\" : 5, \"end_offset\" : 6, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 4 }, { \"token\" : \"源\", \"start_offset\" : 6, \"end_offset\" : 7, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 5 }, { \"token\" : \"未\", \"start_offset\" : 8, \"end_offset\" : 9, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 6 }, { \"token\" : \"知\", \"start_offset\" : 9, \"end_offset\" : 10, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 7 }, { \"token\" : \"原\", \"start_offset\" : 10, \"end_offset\" : 11, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 8 }, { \"token\" : \"文\", \"start_offset\" : 11, \"end_offset\" : 12, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 9 }, { \"token\" : \"https\", \"start_offset\" : 13, \"end_offset\" : 18, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 10 }, { \"token\" : \"www.cnblogs.com\", \"start_offset\" : 21, \"end_offset\" : 36, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 11 }, { \"token\" : \"Neeo\", \"start_offset\" : 37, \"end_offset\" : 41, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 12 }, { \"token\" : \"articles\", \"start_offset\" : 42, \"end_offset\" : 50, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 13 }, { \"token\" : \"10402742\", \"start_offset\" : 51, \"end_offset\" : 59, \"type\" : \"\u003cNUM\u003e\", \"position\" : 14 }, { \"token\" : \"html\", \"start_offset\" : 60, \"end_offset\" : 64, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 15 }, { \"token\" : \"邮\", \"start_offset\" : 64, \"end_offset\" : 65, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 16 }, { \"token\" : \"箱\", \"start_offset\" : 65, \"end_offset\" : 66, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 17 }, { \"token\" : \"xxxxxxx\", \"start_offset\" : 67, \"end_offset\" : 74, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 18 }, { \"token\" : \"xx.com\", \"start_offset\" : 75, \"end_offset\" : 81, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 19 }, { \"token\" : \"版\", \"start_offset\" : 81, \"end_offset\" : 82, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 20 }, { \"token\" : \"权\", \"start_offset\" : 82, \"end_offset\" : 83, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 21 }, { \"token\" : \"声\", \"start_offset\" : 83, \"end_offset\" : 84, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 22 }, { \"token\" : \"明\", \"start_offset\" : 84, \"end_offset\" : 85, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 23 }, { \"token\" : \"本\", \"start_offset\" : 86, \"end_offset\" : 87, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 24 }, { \"token\" : \"文\", \"start_offset\" : 87, \"end_offset\" : 88, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 25 }, { \"token\" : \"为\", \"start_offset\" : 88, \"end_offset\" : 89, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 26 }, { \"token\" : \"博\", \"start_offset\" : 89, \"end_offset\" : 90, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 27 }, { \"token\" : \"主\", \"start_offset\" : 90, \"end_offset\" : 91, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 28 }, { \"token\" : \"原\", \"start_offset\" : 91, \"end_offset\" : 92, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 29 }, { \"token\" : \"创\", \"start_offset\" : 92, \"end_offset\" : 93, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 30 }, { \"token\" : \"文\", \"start_offset\" : 93, \"end_offset\" : 94, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 31 }, { \"token\" : \"章\", \"start_offset\" : 94, \"end_offset\" : 95, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 32 }, { \"token\" : \"转\", \"start_offset\" : 96, \"end_offset\" : 97, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 33 }, { \"token\" : \"载\", \"start_offset\" : 97, \"end_offset\" : 98, \"type\" : \"\u003cIDEOGRAPHIC\u003e\", \"position\" : 34 }, { \"token\" : \"请\",","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:7","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"5.8 路径层次分词器：path hierarchy tokenizer 路径层次分词器（path hierarchy tokenizer）允许以特定的方式索引文件系统的路径，这样在搜索时，共享同样路径的文件将被作为结果返回。 POST _analyze { \"tokenizer\": \"path_hierarchy\", \"text\":\"/usr/local/python/python2.7\" } 返回结果如下： { \"tokens\" : [ { \"token\" : \"/usr\", \"start_offset\" : 0, \"end_offset\" : 4, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"/usr/local\", \"start_offset\" : 0, \"end_offset\" : 10, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"/usr/local/python\", \"start_offset\" : 0, \"end_offset\" : 17, \"type\" : \"word\", \"position\" : 0 }, { \"token\" : \"/usr/local/python/python2.7\", \"start_offset\" : 0, \"end_offset\" : 27, \"type\" : \"word\", \"position\" : 0 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:5:8","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"六 分词过滤器 asticsearch内置很多（真是变态多啊！但一般用不到，美滋滋！！！）的分词过滤器。其中包含分词过滤器和字符过滤器。 常见分词过滤器 这里仅列举几个常见的分词过滤器（token filter）包括： 标准分词过滤器（Standard Token Filter）在6.5.0版本弃用。此筛选器已被弃用，将在下一个主要版本中删除。在之前的版本中其实也没干啥，甚至在更老版本的Lucene中，它用于去除单词结尾的s字符，还有不必要的句点字符，但是现在， 连这些小功能都被其他的分词器和分词过滤器顺手干了，真可怜！ ASCII折叠分词过滤器（ASCII Folding Token Filter）将前127个ASCII字符(基本拉丁语的Unicode块)中不包含的字母、数字和符号Unicode字符转换为对应的ASCII字符(如果存在的话）。 扁平图形分词过滤器（Flatten Graph Token Filter）接受任意图形标记流。例如由同义词图形标记过滤器生成的标记流，并将其展平为适合索引的单个线性标记链。这是一个有损的过程，因为单独的侧路径被压扁在彼此之上，但是如果在索引期间使用图形令牌流是必要的，因为Lucene索引当前不能表示图形。 出于这个原因，最好只在搜索时应用图形分析器，因为这样可以保留完整的图形结构，并为邻近查询提供正确的匹配。该功能在Lucene中为实验性功能。 长度标记过滤器（Length Token Filter）会移除分词流中太长或者太短的标记，它是可配置的，我们可以在settings中设置。 小写分词过滤器（Lowercase Token Filter）将分词规范化为小写，它通过language参数支持希腊语、爱尔兰语和土耳其语小写标记过滤器。 大写分词过滤器（Uppercase Token Filter）将分词规范为大写。 其余分词过滤器不一一列举。详情参见官网。 ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:6:0","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"6.1 自定义分词过滤器 接下来我们简单的来学习自定义两个分词过滤器。首先是长度分词过滤器。 PUT pattern_test3 { \"settings\": { \"analysis\": { \"filter\": { \"my_test_length\":{ \"type\":\"length\", \"max\":8, \"min\":2 } } } } } 上例中，我们自定义了一个长度过滤器，过滤掉长度大于8和小于2的分词。 需要补充的是，max参数表示最大分词长度。默认为Integer.MAX_VALUE，就是2147483647（231−1 ），而min则表示最小长度，默认为0。 POST pattern_test3/_analyze { \"tokenizer\": \"standard\", \"filter\": [\"my_test_length\"], \"text\":\"a Small word and a longerword\" } 结果如下： { \"tokens\" : [ { \"token\" : \"Small\", \"start_offset\" : 2, \"end_offset\" : 7, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"word\", \"start_offset\" : 8, \"end_offset\" : 12, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"and\", \"start_offset\" : 13, \"end_offset\" : 16, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:6:1","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"6.2 自定义小写分词过滤器 自定义一个小写分词过滤器，过滤希腊文： PUT lowercase_example { \"settings\": { \"analysis\": { \"analyzer\": { \"standard_lowercase_example\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"filter\": [\"lowercase\"] }, \"greek_lowercase_example\": { \"type\": \"custom\", \"tokenizer\": \"standard\", \"filter\": [\"greek_lowercase\"] } }, \"filter\": { \"greek_lowercase\": { \"type\": \"lowercase\", \"language\": \"greek\" } } } } } 过滤内容是： POST lowercase_example/_analyze { \"tokenizer\": \"standard\", \"filter\": [\"greek_lowercase\"], \"text\":\"Ένα φίλτρο διακριτικού τύπου πεζά s ομαλοποιεί το κείμενο διακριτικού σε χαμηλότερη θήκη\" } 结果如下： { \"tokens\" : [ { \"token\" : \"ενα\", \"start_offset\" : 0, \"end_offset\" : 3, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 0 }, { \"token\" : \"φιλτρο\", \"start_offset\" : 4, \"end_offset\" : 10, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"διακριτικου\", \"start_offset\" : 11, \"end_offset\" : 22, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"τυπου\", \"start_offset\" : 23, \"end_offset\" : 28, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 }, { \"token\" : \"πεζα\", \"start_offset\" : 29, \"end_offset\" : 33, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 4 }, { \"token\" : \"s\", \"start_offset\" : 34, \"end_offset\" : 35, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 5 }, { \"token\" : \"ομαλοποιει\", \"start_offset\" : 36, \"end_offset\" : 46, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 6 }, { \"token\" : \"το\", \"start_offset\" : 47, \"end_offset\" : 49, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 7 }, { \"token\" : \"κειμενο\", \"start_offset\" : 50, \"end_offset\" : 57, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 8 }, { \"token\" : \"διακριτικου\", \"start_offset\" : 58, \"end_offset\" : 69, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 9 }, { \"token\" : \"σε\", \"start_offset\" : 70, \"end_offset\" : 72, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 10 }, { \"token\" : \"χαμηλοτερη\", \"start_offset\" : 73, \"end_offset\" : 83, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 11 }, { \"token\" : \"θηκη\", \"start_offset\" : 84, \"end_offset\" : 88, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 12 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:6:2","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"6.3 多个分词过滤器 除此之外，我们可以使用多个分词过滤器。例如我们在使用长度过滤器时，可以同时使用小写分词过滤器或者更多。 POST _analyze { \"tokenizer\": \"standard\", \"filter\": [\"length\",\"lowercase\"], \"text\":\"a Small word and a longerword\" } 上例中，我们用列表来管理多个分词过滤器。 结果如下： { \"tokens\" : [ { \"token\" : \"a\", \"start_offset\" : 0, \"end_offset\" : 1, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 0 }, { \"token\" : \"small\", \"start_offset\" : 2, \"end_offset\" : 7, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 1 }, { \"token\" : \"word\", \"start_offset\" : 8, \"end_offset\" : 12, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 2 }, { \"token\" : \"and\", \"start_offset\" : 13, \"end_offset\" : 16, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 3 }, { \"token\" : \"a\", \"start_offset\" : 17, \"end_offset\" : 18, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 4 }, { \"token\" : \"longerword\", \"start_offset\" : 19, \"end_offset\" : 29, \"type\" : \"\u003cALPHANUM\u003e\", \"position\" : 5 } ] } ","date":"2023-08-31","objectID":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/:6:3","tags":["文档操作"],"title":"文档操作-分析过程","uri":"/posts/09-14-elasticsearch-%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B/"},{"categories":["ElasticSearch"],"content":"一 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-5-elasticsearch%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-分页查询","uri":"/posts/09-5-elasticsearch%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 分页查询：from/size 我们来看看elasticsearch是怎么将结果分页的： GET lqz/doc/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"age\": { \"order\": \"desc\" } } ], \"from\": 2, \"size\": 1 } 上例，首先以age降序排序，查询所有。并且在查询的时候，添加两个属性from和size来控制查询结果集的数据条数。 from：从哪开始查 size：返回几条结果 如上例的结果： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : null, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"5\", \"_score\" : null, \"_source\" : { \"name\" : \"魏行首\", \"age\" : 25, \"from\" : \"广云台\", \"desc\" : \"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\" : [ \"闭月\", \"羞花\" ] }, \"sort\" : [ 25 ] } ] } } 上例中，在返回的结果集中，从第2条开始，返回1条数据。 那如果想要从第2条开始，返回2条结果怎么做呢？ GET lqz/doc/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"age\": { \"order\": \"desc\" } } ], \"from\": 2, \"size\": 2 } 上例中，我们指定from为2，意为从第2条开始返回，返回多少呢？size意为2条。 还可以这样： GET lqz/doc/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"age\": { \"order\": \"desc\" } } ], \"from\": 4, \"size\": 2 } 上例中，从第4条开始返回2条数据。 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : null, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : null, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] }, \"sort\" : [ 18 ] } ] } } 上例中仅有一条数据，那是为啥呢？因为我们现在只有5条数据，从第4条开始查询，就只有1条符合条件，所以，就返回了1条数据。 学到这里，我们也可以看到，我们的查询条件越来越多，开始仅是简单查询，慢慢增加条件查询，增加排序，对返回结果进行限制。所以，我们可以说：对于elasticsearch来说，所有的条件都是可插拔的，彼此之间用,分割。比如说，我们在查询中，仅对返回结果进行限制： GET lqz/doc/_search { \"query\": { \"match_all\": {} }, \"from\": 4, \"size\": 2 } 上例中，在所有的返回结果中，结果从4开始返回2条数据。 { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] } } ] } } 但我们只有1条符合条件的数据。 ","date":"2023-08-31","objectID":"/posts/09-5-elasticsearch%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-分页查询","uri":"/posts/09-5-elasticsearch%E4%B9%8B%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 前言 如果返回的结果集中很多符合条件的结果，那怎么能一眼就能看到我们想要的那个结果呢？比如下面网站所示的那样，我们搜索elasticsearch，在结果集中，将所有elasticsearch高亮显示？ 我们该怎么做呢？ ","date":"2023-08-31","objectID":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-高亮查询","uri":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 准备数据 PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } ","date":"2023-08-31","objectID":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-高亮查询","uri":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"三 默认高亮显示 我们来查询： GET lqz/doc/_search { \"query\": { \"match\": { \"name\": \"石头\" } }, \"highlight\": { \"fields\": { \"name\": {} } } } 上例中，我们使用highlight属性来实现结果高亮显示，需要的字段名称添加到fields内即可，elasticsearch会自动帮我们实现高亮。 结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 1.5098256, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 1.5098256, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] }, \"highlight\" : { \"name\" : [ \"\u003cem\u003e石\u003c/em\u003e\u003cem\u003e头\u003c/em\u003e\" ] } } ] } } 上例中，elasticsearch会自动将检索结果用标签包裹起来，用于在页面中渲染。 ","date":"2023-08-31","objectID":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/:3:0","tags":["文档操作"],"title":"文档操作-高亮查询","uri":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"四 自定义高亮显示 但是，你可能会问，我不想用em标签， 我这么牛逼，应该用个b标签啊！好的，elasticsearch同样考虑到你很牛逼，所以，我们可以自定义标签。 GET lqz/chengyuan/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"highlight\": { \"pre_tags\": \"\u003cb class='key' style='color:red'\u003e\", \"post_tags\": \"\u003c/b\u003e\", \"fields\": { \"from\": {} } } } 上例中，在highlight中，pre_tags用来实现我们的自定义标签的前半部分，在这里，我们也可以为自定义的标签添加属性和样式。post_tags实现标签的后半部分，组成一个完整的标签。至于标签中的内容，则还是交给fields来完成。 { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 1, \"max_score\" : 0.5753642, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"chengyuan\", \"_id\" : \"1\", \"_score\" : 0.5753642, \"_source\" : { \"name\" : \"老二\", \"age\" : 30, \"sex\" : \"male\", \"birth\" : \"1070-10-11\", \"from\" : \"gu\", \"desc\" : \"皮肤黑，武器长，性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] }, \"highlight\" : { \"name\" : [ \"\u003cb class='key' style='color:red'\u003e老\u003c/b\u003e\u003cb class='key' style='color:red'\u003e二\u003c/b\u003e\" ] } } ] } } 需要注意的是：自定义标签中属性或样式中的逗号一律用英文状态的单引号表示，应该与外部elasticsearch语法的双引号区分开。 ","date":"2023-08-31","objectID":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/:4:0","tags":["文档操作"],"title":"文档操作-高亮查询","uri":"/posts/09-8-elasticsearch%E4%B9%8B%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 前言 聚合函数大家都不陌生，elasticsearch中也没玩出新花样，所以，这一章相对简单，只需要记得： avg max min sum 以及各自的用法即可。先来看求平均。 ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:1:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"二 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:2:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"三 avg 现在的需求是查询from是gu的人的平均年龄。 select max(age) as my_avg GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"aggs\": { \"my_avg\": { \"avg\": { \"field\": \"age\" } } }, \"_source\": [\"name\", \"age\"] } 上例中，首先匹配查询from是gu的数据。在此基础上做查询平均值的操作，这里就用到了聚合函数，其语法被封装在aggs中，而my_avg则是为查询结果起个别名，封装了计算出的平均值。那么，要以什么属性作为条件呢？是age年龄，查年龄的什么呢？是avg，查平均年龄。 返回结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.6931472, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : 0.6931472, \"_source\" : { \"name\" : \"石头\", \"age\" : 29 } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30 } }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 0.2876821, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22 } } ] }, \"aggregations\" : { \"my_avg\" : { \"value\" : 27.0 } } } 上例中，在查询结果的最后是平均值信息，可以看到是27岁。 虽然我们已经使用_source对字段做了过滤，但是还不够。我不想看都有哪些数据，只想看平均值怎么办？别忘了size! GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"aggs\": { \"my_avg\": { \"avg\": { \"field\": \"age\" } } }, \"size\": 0, \"_source\": [\"name\", \"age\"] } 上例中，只需要在原来的查询基础上，增加一个size就可以了，输出几条结果，我们写上0，就是输出0条查询结果。 查询结果如下： { \"took\" : 8, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"my_avg\" : { \"value\" : 27.0 } } } 查询结果中，我们看hits下的total值是3，说明有三条符合结果的数据。最后面返回平均值是27。 ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:3:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"四 max 那怎么查最大值呢？ GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"aggs\": { \"my_max\": { \"max\": { \"field\": \"age\" } } }, \"size\": 0 } 上例中，只需要在查询条件中将avg替换成max即可。 返回结果如下： { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"my_max\" : { \"value\" : 30.0 } } } 在返回的结果中，可以看到年龄最大的是30岁。 ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:4:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"五 min 那怎么查最小值呢？ GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"aggs\": { \"my_min\": { \"min\": { \"field\": \"age\" } } }, \"size\": 0 } 最小值则用min表示。 返回结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"my_min\" : { \"value\" : 22.0 } } } 返回结果中，年龄最小的是22岁。 ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:5:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"六 sum 那么，要是想知道它们的年龄总和是多少怎么办呢？ GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"aggs\": { \"my_sum\": { \"sum\": { \"field\": \"age\" } } }, \"size\": 0 } 上例中，求和用sum表示。 { \"took\" : 2, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"my_sum\" : { \"value\" : 81.0 } } } 从返回的结果可以发现，年龄总和是81岁。 ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:6:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"七 分组查询 现在我想要查询所有人的年龄段，并且按照15~20，20~25,25~30分组，并且算出每组的平均年龄。 分析需求，首先我们应该先把分组做出来。 GET lqz/doc/_search { \"size\": 0, \"query\": { \"match_all\": {} }, \"aggs\": { \"age_group\": { \"range\": { \"field\": \"age\", \"ranges\": [ { \"from\": 15, \"to\": 20 }, { \"from\": 20, \"to\": 25 }, { \"from\": 25, \"to\": 30 } ] } } } } 上例中，在aggs的自定义别名age_group中，使用range来做分组，field是以age为分组，分组使用ranges来做，from和to是范围，我们根据需求做出三组。 { \"took\" : 3, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"age_group\" : { \"buckets\" : [ { \"key\" : \"15.0-20.0\", \"from\" : 15.0, \"to\" : 20.0, \"doc_count\" : 1 }, { \"key\" : \"20.0-25.0\", \"from\" : 20.0, \"to\" : 25.0, \"doc_count\" : 1 }, { \"key\" : \"25.0-30.0\", \"from\" : 25.0, \"to\" : 30.0, \"doc_count\" : 2 } ] } } } 返回的结果中可以看到，已经拿到了三个分组。doc_count为该组内有几条数据，此次共分为三组，查询出4条内容。还有一条数据的age属性值是30，不在分组的范围内！ 那么接下来，我们就要对每个小组内的数据做平均年龄处理。 GET lqz/doc/_search { \"size\": 0, \"query\": { \"match_all\": {} }, \"aggs\": { \"age_group\": { \"range\": { \"field\": \"age\", \"ranges\": [ { \"from\": 15, \"to\": 20 }, { \"from\": 20, \"to\": 25 }, { \"from\": 25, \"to\": 30 } ] }, \"aggs\": { \"my_avg\": { \"avg\": { \"field\": \"age\" } } } } } } 上例中，在分组下面，我们使用aggs对age做平均数处理，这样就可以了。 { \"took\" : 1, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : 0.0, \"hits\" : [ ] }, \"aggregations\" : { \"age_group\" : { \"buckets\" : [ { \"key\" : \"15.0-20.0\", \"from\" : 15.0, \"to\" : 20.0, \"doc_count\" : 1, \"my_avg\" : { \"value\" : 18.0 } }, { \"key\" : \"20.0-25.0\", \"from\" : 20.0, \"to\" : 25.0, \"doc_count\" : 1, \"my_avg\" : { \"value\" : 22.0 } }, { \"key\" : \"25.0-30.0\", \"from\" : 25.0, \"to\" : 30.0, \"doc_count\" : 2, \"my_avg\" : { \"value\" : 27.0 } } ] } } } 在结果中，我们可以清晰的看到每组的平均年龄（my_avg的value中）。 注意：聚合函数的使用，一定是先查出结果，然后对结果使用聚合函数做处理 小结： avg：求平均 max：最大值 min：最小值 sum：求和 欢迎斧正，that’s all ","date":"2023-08-31","objectID":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/:7:0","tags":["文档操作"],"title":"文档操作-聚合函数","uri":"/posts/09-9-elasticsearch%E4%B9%8B%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/"},{"categories":["ElasticSearch"],"content":"一 准备数据 PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2023-08-31","objectID":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/:1:0","tags":["文档操作"],"title":"文档操作-排序查询","uri":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"二 排序查询：sort ","date":"2023-08-31","objectID":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/:2:0","tags":["文档操作"],"title":"文档操作-排序查询","uri":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"2.1 降序：desc 想到排序，出现在脑海中的无非就是升（正）序和降（倒）序。比如我们查询顾府都有哪些人，并根据age字段按照降序，并且，我只想看nmae和age字段： GET lqz/doc/_search { \"query\": { \"match\": { \"from\": \"gu\" } }, \"sort\": [ { \"age\": { \"order\": \"desc\" } } ] } 上例，在条件查询的基础上，我们又通过sort来做排序，根据age字段排序，是降序呢还是升序，由order字段控制，desc是降序。 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : null, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : null, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] }, \"sort\" : [ 30 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : null, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] }, \"sort\" : [ 29 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : null, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] }, \"sort\" : [ 22 ] } ] } } 上例中，结果是以降序排列方式返回的。 ","date":"2023-08-31","objectID":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/:2:1","tags":["文档操作"],"title":"文档操作-排序查询","uri":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"2.2 升序：asc 那么想要升序怎么搞呢？ GET lqz/doc/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"age\": { \"order\": \"asc\" } } ] } 上例，想要以升序的方式排列，只需要将order值换为asc就可以了。 结果如下： { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 5, \"max_score\" : null, \"hits\" : [ { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : null, \"_source\" : { \"name\" : \"大娘子\", \"age\" : 18, \"from\" : \"sheng\", \"desc\" : \"肤白貌美，娇憨可爱\", \"tags\" : [ \"白\", \"富\", \"美\" ] }, \"sort\" : [ 18 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : null, \"_source\" : { \"name\" : \"龙套偏房\", \"age\" : 22, \"from\" : \"gu\", \"desc\" : \"mmp，没怎么看，不知道怎么形容\", \"tags\" : [ \"造数据\", \"真\", \"难\" ] }, \"sort\" : [ 22 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"5\", \"_score\" : null, \"_source\" : { \"name\" : \"魏行首\", \"age\" : 25, \"from\" : \"广云台\", \"desc\" : \"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\" : [ \"闭月\", \"羞花\" ] }, \"sort\" : [ 25 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_score\" : null, \"_source\" : { \"name\" : \"石头\", \"age\" : 29, \"from\" : \"gu\", \"desc\" : \"粗中有细，狐假虎威\", \"tags\" : [ \"粗\", \"大\", \"猛\" ] }, \"sort\" : [ 29 ] }, { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : null, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] }, \"sort\" : [ 30 ] } ] } } 上例，可以看到结果是以age从小到大的顺序返回结果。 ","date":"2023-08-31","objectID":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/:2:2","tags":["文档操作"],"title":"文档操作-排序查询","uri":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"三 不是什么数据类型都能排序 那么，你可能会问，除了age，能不能以别的属性作为排序条件啊？来试试： GET lqz/chengyuan/_search { \"query\": { \"match_all\": {} }, \"sort\": [ { \"name\": { \"order\": \"asc\" } } ] } 上例，我们以name属性来排序，来看结果： { \"error\": { \"root_cause\": [ { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [name] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } ], \"type\": \"search_phase_execution_exception\", \"reason\": \"all shards failed\", \"phase\": \"query\", \"grouped\": true, \"failed_shards\": [ { \"shard\": 0, \"index\": \"lqz\", \"node\": \"wrtr435jSgi7_naKq2Y_zQ\", \"reason\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [name] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } } ], \"caused_by\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [name] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\", \"caused_by\": { \"type\": \"illegal_argument_exception\", \"reason\": \"Fielddata is disabled on text fields by default. Set fielddata=true on [name] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory. Alternatively use a keyword field instead.\" } } }, \"status\": 400 } 结果跟我们想象的不一样，报错了！ 注意：在排序的过程中，只能使用可排序的属性进行排序。那么可以排序的属性有哪些呢？ 数字 日期 其他的都不行！ ","date":"2023-08-31","objectID":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/:3:0","tags":["文档操作"],"title":"文档操作-排序查询","uri":"/posts/09-4-elasticsearch%E4%B9%8B%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2/"},{"categories":["ElasticSearch"],"content":"一 CURD之Create PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } 他明处貌似还有俩老婆： PUT lqz/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT lqz/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } 家里红旗不倒，家外彩旗飘摇： PUT lqz/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT lqz/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } 注意：当执行PUT命令时，如果数据不存在，则新增该条数据，如果数据存在则修改该条数据。 咱们通过GET命令查询一下： GET lqz/doc/1 结果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 1, \"found\" : true, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤黑、武器长、性格直\", \"tags\" : [ \"黑\", \"长\", \"直\" ] } } 查询也没啥问题，但是你可能说了，人家老二是黄种人，怎么是黑的呢？好吧咱改改desc和tags： PUT lqz/doc/1 { \"desc\":\"皮肤很黄，武器很长，性格很直\", \"tags\":[\"很黄\",\"很长\", \"很直\"] } 上例，我们仅修改了desc和tags两处，而name、age和from三个属性没有变化，我们可以忽略不写吗？查查看： GET lqz/doc/1 结果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 3, \"found\" : true, \"_source\" : { \"desc\" : \"皮肤很黄，武器很长，性格很直\", \"tags\" : [ \"很黄\", \"很长\", \"很直\" ] } } 哎呀，出事故了！修改是修改了，但结果不太理想啊，因为name、age和from属性都没啦！ 注意：**PUT命令，在做修改操作时，如果未指定其他的属性，则按照指定的属性进行修改操作。**也就是如上例所示的那样，我们修改时只修改了desc和tags两个属性，其他的属性并没有一起添加进去。 很明显，这是病！dai治！怎么治？上车，咱们继续往下走！ ","date":"2023-08-31","objectID":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/:1:0","tags":["文档操作"],"title":"文档操作-增删改查","uri":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/"},{"categories":["ElasticSearch"],"content":"二 CURD之Update 让我们首先恢复一下事故现场： PUT lqz/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } 我们要将黑修改成黄： POST lqz/doc/1/_update { \"doc\": { \"desc\": \"皮肤很黄，武器很长，性格很直\", \"tags\": [\"很黄\",\"很长\", \"很直\"] } } 上例中，我们使用POST命令，在id后面跟_update，要修改的内容放到doc文档（属性）中即可。 我们再来查询一次： GET lqz/doc/1 结果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 5, \"found\" : true, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤很黄，武器很长，性格很直\", \"tags\" : [ \"很黄\", \"很长\", \"很直\" ] } } 结果如上例所示，现在其他的属性没有变化，只有desc和tags属性被修改。 注意：POST命令，这里可用来执行修改操作（还有其他的功能），POST命令配合_update完成修改操作，指定修改的内容放到doc中。 写了这么多，我也发现我上面有讲的不对的地方——石头不是跟顾老二不清不楚，石头是跟小桃不清不楚！好吧，刚才那个数据是一个错误示范！我们这就把它干掉！ ","date":"2023-08-31","objectID":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/:2:0","tags":["文档操作"],"title":"文档操作-增删改查","uri":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/"},{"categories":["ElasticSearch"],"content":"三CURD之Delete DELETE lqz/doc/4 很简单，通过DELETE命令，就可以删除掉那个错误示范了！ 删除效果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"_version\" : 4, \"result\" : \"deleted\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 4, \"_primary_term\" : 1 } 我们再来查询一遍： GET lqz/doc/4 结果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"4\", \"found\" : false } 上例中，found：false表示查询数据不存在。 ","date":"2023-08-31","objectID":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/:3:0","tags":["文档操作"],"title":"文档操作-增删改查","uri":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/"},{"categories":["ElasticSearch"],"content":"四 CURD之Retrieve 我们上面已经不知不觉的使用熟悉这种简单查询方式，通过 GET命令查询指定文档： GET lqz/doc/1 结果如下： { \"_index\" : \"lqz\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 5, \"found\" : true, \"_source\" : { \"name\" : \"顾老二\", \"age\" : 30, \"from\" : \"gu\", \"desc\" : \"皮肤很黄，武器很长，性格很直\", \"tags\" : [ \"很黄\", \"很长\", \"很直\" ] } } ","date":"2023-08-31","objectID":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/:4:0","tags":["文档操作"],"title":"文档操作-增删改查","uri":"/posts/09-1-elasticsearch%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9curd/"},{"categories":["ElasticSearch"],"content":"在Elasticsearch 6.0.0或更高版本中创建的索引只包含一个mapping type。 在5.x中使用multiple mapping types创建的索引将继续像以前一样在Elasticsearch 6.x中运行。 Mapping types将在Elasticsearch 7.0.0中完全删除 ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:0:0","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"一 映射介绍 在创建索引的时候，可以预先定义字段的类型及相关属性 Es会根据Json数据源的基础类型，猜测你想要映射的字段，将输入的数据转变成可以搜索的索引项。 Mapping是我们自己定义的字段数据类型，同时告诉es如何索引数据及是否可以被搜索 作用：会让索引建立的更加细致和完善 ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:1:0","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"1.1 字段数据类型 string类型：text，keyword 数字类型：long，integer，short，byte，double，float 日期类型：data 布尔类型：boolean binary类型：binary 复杂类型：object（实体，对象），nested（列表） geo类型：geo-point，geo-shape（地理位置） 专业类型：ip，competion（搜索建议） ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:1:1","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"1.2 映射参数 属性 描述 适合类型 store 值为yes表示存储，no表示不存储，默认为no all index yes表示分析，no表示不分析，默认为true text null_value 如果字段为空，可以设置一个默认值，比如\"NA\"（传过来为空，不能搜索，na可以搜索） all analyzer 可以设置索引和搜索时用的分析器，默认使用的是standard分析器，还可以使用whitespace，simple。都是英文分析器 all include_in_all 默认es为每个文档定义一个特殊域_all,它的作用是让每个字段都被搜索到，如果想让某个字段不被搜索到，可以设置为false all format 时间格式字符串模式 date ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:1:2","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"二 创建索引 text类型会取出词做倒排索引,keyword不会被分词，原样存储，原样匹配 mapping类型一旦确定，以后就不能修改了 #6.x的版本没问题 PUT books { \"mappings\": { \"book\":{ \"properties\":{ \"title\":{ \"type\":\"text\", \"analyzer\": \"ik_max_word\" }, \"price\":{ \"type\":\"integer\" }, \"addr\":{ \"type\":\"keyword\" }, \"company\":{ \"properties\":{ \"name\":{\"type\":\"text\"}, \"company_addr\":{\"type\":\"text\"}, \"employee_count\":{\"type\":\"integer\"} } }, \"publish_date\":{\"type\":\"date\",\"format\":\"yyy-MM-dd\"} } } } } 7.x版本以后 PUT books { \"mappings\": { \"properties\":{ \"title\":{ \"type\":\"text\", \"analyzer\": \"ik_max_word\" }, \"price\":{ \"type\":\"integer\" }, \"addr\":{ \"type\":\"keyword\" }, \"company\":{ \"properties\":{ \"name\":{\"type\":\"text\"}, \"company_addr\":{\"type\":\"text\"}, \"employee_count\":{\"type\":\"integer\"} } }, \"publish_date\":{\"type\":\"date\",\"format\":\"yyy-MM-dd\"} } } } 插入数据测试： PUT books/_doc/1 { \"title\":\"大头儿子小偷爸爸\", \"price\":100, \"addr\":\"北京天安门\", \"company\":{ \"name\":\"我爱北京天安门\", \"company_addr\":\"我的家在东北松花江傻姑娘\", \"employee_count\":10 }, \"publish_date\":\"2019-08-19\" } #测试数据2 PUT books/_doc/2 { \"title\":\"白雪公主和十个小矮人\", \"price\":\"99\", #写字符串会自动转换 \"addr\":\"黑暗森里\", \"company\":{ \"name\":\"我的家乡在上海\", \"company_addr\":\"朋友一生一起走\", \"employee_count\":10 }, \"publish_date\":\"2018-05-19\" } ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:2:0","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"三 查看索引 #查看books索引的mapping GET books/_mapping #获取所有的mapping GET _all/_mapping ","date":"2023-08-31","objectID":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/:3:0","tags":["映射"],"title":"映射介绍","uri":"/posts/08-elasticsearch%E4%B9%8B-%E6%98%A0%E5%B0%84%E7%AE%A1%E7%90%86/"},{"categories":["ElasticSearch"],"content":"一 中文分词介绍 elasticsearch提供了几个内置的分词器：standard analyzer(标准分词器)、simple analyzer(简单分词器)、whitespace analyzer（空格分词器）、language analyzer（语言分词器） 而如果我们不指定分词器类型的话，elasticsearch默认是使用标准分词器的 我们需要下载中文分词插件，来实现中文分词 ","date":"2023-08-31","objectID":"/posts/05-elasticsearch%E4%B9%8B-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/:1:0","tags":["分词器"],"title":"中文分词介绍","uri":"/posts/05-elasticsearch%E4%B9%8B-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"二 下载 地址为：https://github.com/medcl/elasticsearch-analysis-ik 安装方式参照【02-ElasticSearch之-插件介绍】 #我们采用第二种，url安装 ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip ","date":"2023-08-31","objectID":"/posts/05-elasticsearch%E4%B9%8B-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/:2:0","tags":["分词器"],"title":"中文分词介绍","uri":"/posts/05-elasticsearch%E4%B9%8B-%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8/"},{"categories":["ElasticSearch"],"content":"一 Elasticsearch插件介绍 es插件是一种增强Elasticsearch核心功能的途径。它们可以为es添加自定义映射类型、自定义分词器、原生脚本、自伸缩等等扩展功能。 es插件包含JAR文件，也可能包含脚本和配置文件，并且必须在集群中的每个节点上安装。安装之后，需要重启集群中的每个节点才能使插件生效。 es插件包含核心插件和第三方插件两种 ","date":"2021-08-31","objectID":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/:1:0","tags":["Elasticsearch插件"],"title":"Elasticsearch插件介绍","uri":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"二 核心插件 核心插件是elasticsearch项目提供的官方插件,都是开源项目。这些插件会跟着elasticsearch版本升级进行升级,总能匹配到对应版本的elasticsearch,这些插件是有官方团队和社区成员共同开发的。 官方插件地址： https://github.com/elastic/elasticsearch/tree/master/plugins ","date":"2021-08-31","objectID":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/:2:0","tags":["Elasticsearch插件"],"title":"Elasticsearch插件介绍","uri":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"三 第三方插件 第三方插件是有开发者或者第三方组织自主开发便于扩展elasticsearch功能,它们拥有自己的许可协议,在使用它们之前需要清除插件的使用协议,不一定随着elasticsearch版本升级, 所以使用者自行辨别插件和es的兼容性。 ","date":"2021-08-31","objectID":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/:3:0","tags":["Elasticsearch插件"],"title":"Elasticsearch插件介绍","uri":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"四 插件安装 elasticsearch的插件安装方式还是很方便易用的。 它包含了命令行和离线安装几种方式。 它包含了命令行,url,离线安装三种方式。 核心插件随便选择一种方式安装均可，第三方插件建议使用离线安装方式 第一种：命令行 bin/elasticsearch-plugin install [plugin_name] # bin/elasticsearch-plugin install analysis-smartcn 安装中文分词器 第二种：url安装 bin/elasticsearch-plugin install [url] #bin/elasticsearch-plugin install https://artifacts.elastic.co/downloads/elasticsearch-plugins/analysis-smartcn/analysis-smartcn-6.4.0.zip 第三种：离线安装 #https://artifacts.elastic.co/downloads/elasticsearch-plugins/analysis-smartcn/analysis-smartcn-6.4.0.zip #点击下载analysis-smartcn离线包 #将离线包解压到ElasticSearch 安装目录下的 plugins 目录下 #重启es。新装插件必须要重启es 注意：插件的版本要与 ElasticSearch 版本要一致 ","date":"2021-08-31","objectID":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/:4:0","tags":["Elasticsearch插件"],"title":"Elasticsearch插件介绍","uri":"/posts/02-elasticsearch%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"一 Elasticsearch介绍 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:0","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"1.1 大规模数据如何检索 如：当系统数据量上了10亿、100亿条的时候，我们在做系统架构的时候通常会从以下角度去考虑问题： 1）用什么数据库好？(mysql、oracle、mongodb、hbase…) 2）如何解决单点故障；(lvs、F5、A10、Zookeeper、MQ) 3）如何保证数据安全性；(热备、冷备、异地多活) 4）如何解决检索难题；(数据库代理中间件：mysql-proxy、Cobar、MaxScale等;) 5）如何解决统计分析问题；(离线、近实时) ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:1","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"1.2 传统数据库的应对解决方案 对于关系型数据，我们通常采用以下或类似架构去解决查询瓶颈和写入瓶颈： 解决要点： 1）通过主从备份解决数据安全性问题； 2）通过数据库代理中间件心跳监测，解决单点故障问题； 3）通过代理中间件将查询语句分发到各个slave节点进行查询，并汇总结果 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:2","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"1.3 非关系型数据库解决方案 对于Nosql数据库，以mongodb为例，其它原理类似： 解决要点： 1）通过副本备份保证数据安全性； 2）通过节点竞选机制解决单点问题； 3）先从配置库检索分片信息，然后将请求分发到各个节点，最后由路由节点合并汇总结果 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:3","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"1.4 内存数据库解决方案 完全把数据放在内存中是不可靠的，实际上也不太现实，当我们的数据达到PB级别时，按照每个节点96G内存计算，在内存完全装满的数据情况下，我们需要的机器是：1PB=1024T=1048576G 节点数=1048576/96=10922个 实际上，考虑到数据备份，节点数往往在2.5万台左右。成本巨大决定了其不现实！ 所以把数据放在内存也好，不放在内存也好，都不能完完全全解决问题。 全部放在内存速度问题是解决了，但成本问题上来了。 为解决以上问题，从源头着手分析，通常会从以下方式来寻找方法： 1、存储数据时按有序存储； 2、将数据和索引分离； 3、压缩数据； 这就引出了Elasticsearch ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:1:4","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"二 Elasticsearch介绍 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:0","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.1Elasticsearch是什么 Elasticsearch 是一个基于Lucene的分布式搜索和分析引擎。 ES是elaticsearch简写， Elasticsearch是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。 Elasticsearch使用Java开发，在Apache许可条款下开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便 使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，使得全文检索变得简单 设计用途：用于分布式全文检索，通过HTTP使用JSON进行数据索引，速度快 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:1","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.2 Lucene与Elasticsearch关系 1）Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 2）Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:2","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.3 Elasticsearch vs solr 1）Solr是Apache Lucene项目的开源企业搜索平台。其主要功能包括全文检索、命中标示、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理。 2）Solr是高度可扩展的，并提供了分布式搜索和索引复制。Solr是最流行的企业级搜索引擎，Solr4 还增加了NoSQL支持。 3）Solr是用Java编写、运行在Servlet容器（如 Apache Tomcat 或Jetty）的一个独立的全文搜索服务器。 Solr采用了 Lucene Java 搜索库为核心的全文索引和搜索，并具有类似REST的HTTP/XML和JSON的API。 4）Solr强大的外部配置功能使得无需进行Java编码，便可对 其进行调整以适应多种类型的应用程序。Solr有一个插件架构，以支持更多的高级定制 Elasticsearch 与 Solr 的比较总结 二者安装都很简单 Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能 Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式 Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供 Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:3","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.4 Elasticsearch核心概念 2.4.1 Cluster：集群 ES可以作为一个独立的单个搜索服务器。不过，为了处理大型数据集，实现容错和高可用性，ES可以运行在许多互相合作的服务器上。这些服务器的集合称为集群。 2.4.2 Node：节点 形成集群的每个服务器称为节点。 2.4.3 Shard：分片 当有大量的文档时，由于内存的限制、磁盘处理能力不足、无法足够快的响应客户端的请求等，一个节点可能不够。这种情况下，数据可以分为较小的分片。每个分片放到不同的服务器上。 当你查询的索引分布在多个分片上时，ES会把查询发送给每个相关的分片，并将结果组合在一起，而应用程序并不知道分片的存在。即：这个过程对用户来说是透明的。 2.4.4 Replia：副本 为提高查询吞吐量或实现高可用性，可以使用分片副本。 副本是一个分片的精确复制，每个分片可以有零个或多个副本。ES中可以有许多相同的分片，其中之一被选择更改索引操作，这种特殊的分片称为主分片。 当主分片丢失时，如：该分片所在的数据不可用时，集群将副本提升为新的主分片。 2.4.5 全文检索 全文检索就是对一篇文章进行索引，可以根据关键字搜索，类似于mysql里的like语句。 全文索引就是把内容根据词的意义进行分词，然后分别创建索引，例如”今日是周日我们出去玩” 可能会被分词成：“今天“，”周日“，“我们“，”出去玩“ 等token，这样当你搜索“周日” 或者 “出去玩” 都会把这句搜出来。 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:4","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.5 与关系型数据库Mysql对比 1）关系型数据库中的数据库（DataBase），等价于ES中的索引（Index） 2）一个数据库下面有N张表（Table），等价于1个索引Index下面有N多类型（Type）， 3）一个数据库表（Table）下的数据由多行（ROW）多列（column，属性）组成，等价于1个Type由多个文档（Document）和多Field组成。 4）在一个关系型数据库里面，schema定义了表、每个表的字段，还有表和字段之间的关系。 与之对应的，在ES中：Mapping定义索引下的Type的字段处理规则，即索引如何建立、索引类型、是否保存原始索引JSON文档、是否压缩原始JSON文档、是否需要分词处理、如何进行分词处理等。 5）在数据库中的增insert、删delete、改update、查search操作等价于ES中的增PUT/POST、删Delete、改_update、查GET.1.7 2.6 ES逻辑设计（文档–\u003e类型–\u003e索引） 一个索引类型中，包含多个文档，比如说文档1，文档2。 当我们索引一篇文档时，可以通过这样的顺序找到它：索引▷类型▷文档ID，通过这个组合我们就能索引到某个具体的文档。 注意：ID不必是整数，实际上它是个字符串。 文档 之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档，elasticsearch中，文档有几个重要属性： 自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key:value 可以是层次型的，一个文档中包含自文档，复杂的逻辑实体就是这么来的 灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。 文档是无模式的，也就是说，字段对应值的类型可以是不限类型的。 尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型（详见扩展阅读：17-扩展阅读-删除映射类型.md），这也是为什么在elasticsearch中，类型有时候也称为映射类型。 类型 类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。 类型中对于字段的定义称为映射，比如name映射为字符串类型。 我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢？elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch会认为它是整型。 但是elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用，别整什么幺蛾子。后面在讨论更多关于映射的东西。 索引 索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。 2.7 ES物理设计 一个集群包含至少一个节点，而一个节点就是一个elasticsearch进程。节点内可以有多个索引。 默认的，如果你创建一个索引，那么这个索引将会有5个分片（primary shard，又称主分片）构成，而每个分片又有一个副本（replica shard，又称复制分片），这样，就有了10个分片。 那么这个索引是如何存储在集群中的呢？ 图中有3个节点的集群，可以看到主分片和对应的复制分片都不会在同一个节点内，这样有利于某个节点挂掉了，数据也不至于丢失。 实际上，一个分片是一个Lucene索引，一个包含倒排索引的文件目录，倒排索引的结构使得elasticsearch在不扫描全部文档的情况下，就能告诉你哪些文档包含特定的关键字 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:5","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.6 ELK是什么 ELK=elasticsearch+Logstash+kibana elasticsearch：后台分布式存储以及全文检索 logstash: 日志加工、“搬运工” kibana：数据可视化展示。 ELK架构为数据分布式存储、可视化查询和日志解析创建了一个功能强大的管理链。 三者相互配合，取长补短，共同完成分布式大数据处理工作。 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:6","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"2.7 Elasticsearch特点和优势 1）分布式实时文件存储，可将每一个字段存入索引，使其可以被检索到。 2）实时分析的分布式搜索引擎。 分布式：索引分拆成多个分片，每个分片可有零个或多个副本。集群中的每个数据节点都可承载一个或多个分片，并且协调和处理各种操作； 负载再平衡和路由在大多数情况下自动完成。 3）可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。也可以运行在单台PC上（已测试） 4）支持插件机制，分词插件、同步插件、Hadoop插件、可视化插件等。 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:2:7","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"三 为什么使用Elasticsearch ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:0","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"3.1 国内外优秀案例 1） 2013年初，GitHub抛弃了Solr，采取ElasticSearch 来做PB级的搜索。 “GitHub使用ElasticSearch搜索20TB的数据，包括13亿文件和1300亿行代码”。 2）维基百科：启动以elasticsearch为基础的核心搜索架构。 3）SoundCloud：“SoundCloud使用ElasticSearch为1.8亿用户提供即时而精准的音乐搜索服务”。 4）百度：百度目前广泛使用ElasticSearch作为文本数据分析，采集百度所有服务器上的各类指标数据及用户自定义数据，通过对各种数据进行多维分析展示，辅助定位分析实例异常或业务层面异常。目前覆盖百度内部20多个业务线（包括casio、云分析、网盟、预测、文库、直达号、钱包、风控等），单集群最大100台机器，200个ES节点，每天导入30TB+数据。 5）新浪ES 如何分析处理32亿条实时日志 6）阿里ES 构建挖财自己的日志采集和分析体系 7）有赞ES 业务日志处理 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:1","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"3.2 我们的业务场景 实际项目开发实战中，几乎每个系统都会有一个搜索的功能，当搜索做到一定程度时，维护和扩展起来难度就会慢慢变大，所以很多公司都会把搜索单独独立出一个模块，用ElasticSearch等来实现。 近年ElasticSearch发展迅猛，已经超越了其最初的纯搜索引擎的角色，现在已经增加了数据聚合分析（aggregation）和可视化的特性，如果你有数百万的文档需要通过关键词进行定位时，ElasticSearch肯定是最佳选择。当然，如果你的文档是JSON的，你也可以把ElasticSearch当作一种“NoSQL数据库”， 应用ElasticSearch数据聚合分析（aggregation）的特性，针对数据进行多维度的分析。 尝试使用ES来替代传统的NoSQL，它的横向扩展机制太方便了 应用场景： 1）新系统开发尝试使用ES作为存储和检索服务器； 2）现有系统升级需要支持全文检索服务，需要使用ES ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:3:2","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"四 Elasticsearch索引到底能处理多大数据 单一索引的极限取决于存储索引的硬件、索引的设计、如何处理数据以及你为索引备份了多少副本。 通常来说，一个Lucene索引（也就是一个elasticsearch分片，一个es索引默认5个分片）不能处理多于21亿篇文档，或者多于2740亿的唯一词条。但达到这个极限之前，我们可能就没有足够的磁盘空间了！ 当然，一个分片如何很大的话，读写性能将会变得非常差 ","date":"2021-08-31","objectID":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/:4:0","tags":["Elasticsearch介绍"],"title":"Elasticsearch介绍","uri":"/posts/00-elasticsearch%E4%B9%8B%E4%BB%8B%E7%BB%8D/"},{"categories":["ElasticSearch"],"content":"一 安装JDK环境 因为ElasticSearch是用Java语言编写的，所以必须安装JDK的环境，并且是JDK 1.8以上，具体操作步骤自行百度 安装完成查看java版本 java -version ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:1:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"二 官网下载最新版本 下载地址[https://www.elastic.co/cn/downloads/elasticsearch],选择相应版本下载即可 ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:2:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"三 下载其他版本 直接点击https://www.elastic.co/cn/downloads/past-releases#elasticsearch ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:3:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"三 下载完成，启动 解压文件，切换到解压文件路径下，执行 cd elasticsearch-\u003cversion\u003e #切换到路径下 ./bin/elasticsearch #启动es #如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d 。 #如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\\elasticsearch.bat 而不是 bin\\elasticsearch ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:4:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"四 测试启动是否成功 在浏览器输入以下地址：http://127.0.0.1:9200/ 即可看到如下内容： { \"name\" : \"lqzMacBook.local\", \"cluster_name\" : \"elasticsearch\", \"cluster_uuid\" : \"G1DFg-u6QdGFvz8Z-XMZqQ\", \"version\" : { \"number\" : \"7.5.0\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"e9ccaed468e2fac2275a3761849cbee64b39519f\", \"build_date\" : \"2019-11-26T01:06:52.518245Z\", \"build_snapshot\" : false, \"lucene_version\" : \"8.3.0\", \"minimum_wire_compatibility_version\" : \"6.8.0\", \"minimum_index_compatibility_version\" : \"6.0.0-beta1\" }, \"tagline\" : \"You Know, for Search\" } ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:5:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"五 关闭es #查看进程 ps -ef | grep elastic #干掉进程 kill -9 2382（进程号） #以守护进程方式启动es elasticsearch -d ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:6:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"六 Docker 安装ES ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:7:0","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"Docker 安装 es 拉取镜像 sudo docker pull elasticsearch:7.2.0 等待下载完成， （选择docker是因为 docker比较轻便 不会出现各种各样的 java环境问题） 创建容器 # 在 Document 下创建 ElasticSearch 文件夹， 然后再创建 conf data logs 文件夹 用于放置 es的数据， 配置 ， 日志文件 mkdir ELasticSearch cd ElasticSearch mkdir conf mkdir logs mkdir data # 使用run 命令 创建 es 容器 sudo docker run -id --name=es-a -p 9200:9200 -p 9300:9300 -v /home/zhang/Documents/ElasticSearch/data/data-a:/usr/share/elasticsearch/data -v /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS= -Xms1024m -Xmx1024m\" elasticsearch:7.2.0 sudo curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose ","date":"2021-08-31","objectID":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/:7:1","tags":["Elasticsearch安装"],"title":"安装ElasticSearch","uri":"/posts/01-mac%E5%AE%89%E8%A3%85elasticsearch/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 常用的es 查询 ","date":"2020-09-05","objectID":"/posts/elasticsearch-09-term%E4%B8%8Ematch/:0:0","tags":["配置"],"title":"Elasticsearch term 与 match","uri":"/posts/elasticsearch-09-term%E4%B8%8Ematch/"},{"categories":["ElasticSearch"],"content":"准备数据 PUT zhifou/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT zhifou/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT zhifou/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT zhifou/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT zhifou/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2020-09-05","objectID":"/posts/elasticsearch-09-term%E4%B8%8Ematch/:0:1","tags":["配置"],"title":"Elasticsearch term 与 match","uri":"/posts/elasticsearch-09-term%E4%B8%8Ematch/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 简单操作 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:0:0","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"前言 现在，让我们启动一个节点和kibana。 接下来的一切操作都在kibana中Dev Tools下的Console里完成。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:0","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"创建一篇文档 现在，我们试图将小黑的小姨妈的个人信息录入elasticsearch。我们只要输入： PUT t1/doc/1 { \"name\": \"小黑的小姨妈\", \"age\": 18 } PUT表示创建命令。虽然命令可以小写，但是我们推荐大写。在以REST ful风格返回的结果中： { \"_index\" : \"t1\", \"_type\" : \"type1\", \"_id\" : \"1\", \"_version\" : 1, \"result\" : \"created\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 0, \"_primary_term\" : 1 } 结果中的result则是操作类型，现在是created，表示第一次创建。如果我们再次点击执行该命令，那么result则会是updated。我们细心则会发现_version开始是1，现在你每点击一次就会增加一次。表示第几次更改。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:1","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询所有索引 现在，我们再来学习一条命令： GET _cat/indices?v 返回的结果如下图： 上图中，展示当前集群中索引情况，包括，索引的健康状况、UUID、主副分片个数、大小等信息。你发现我们创建的t1索引了吗？ ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:2","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询指定的索引信息 我们来单独看看t1索引： GET t1 返回的结果如下： { \"t1\" : { \"aliases\" : { }, \"mappings\" : { \"doc\" : { \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } }, \"settings\" : { \"index\" : { \"creation_date\" : \"1553163739688\", \"number_of_shards\" : \"5\", \"number_of_replicas\" : \"1\", \"uuid\" : \"_7jNW5XATheeK84zKkPwlw\", \"version\" : { \"created\" : \"6050499\" }, \"provided_name\" : \"t1\" } } } } 返回了t1索引的创建信息。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:3","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询文档信息 那我们来查看我们刚才创建的那篇文档： GET t1/doc/1 返回的结果如下： Copy{ \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 2, \"found\" : true, \"_source\" : { \"name\" : \"小黑的小姨妈\", \"age\" : 18 } } 返回了我们刚才创建的文档信息。 我们再来为小黑添加两个姨妈： CopyPUT t1/doc/2 { \"name\": \"小黑的二姨妈\", \"age\": 16 } PUT t1/doc/3 { \"name\": \"小黑的三姨妈\", \"age\": 19 } 刚才，我们学会了查询小黑的一个姨妈，那么该如何查询所有姨妈呢？ GET t1/doc/_search 返回结果如下： Copy{ \"took\" : 7, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的二姨妈\", \"age\" : 16 } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的小姨妈\", \"age\" : 18 } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的三姨妈\", \"age\" : 19 } } ] } } 现在小黑跟他的姨妈们闹了别扭，就想删除这个姨妈，该怎么办呢？ ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:4","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"删除指定索引 我们其实直接删除这个t1索引就可以了： DELETE /t1 DELETE 是删除命令，返回结果如下： { \"acknowledged\" : true } 返回结果提示删除确认成功。 如果此时再查询索引情况，则会发现t1已经不存在了，所有的文档也就不存在了。 欢迎斧正，that’s all ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:5","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目 ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:0","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"Docker 配置桥接 #　创建网桥 docker network create -d bridge my-bridge # es 连接　网桥 docker network connect my-bridge es-a # kibana 连接网桥 docker network connect my-bridge kibana ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:1","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"修改kibana　配置文件 # 查看　es-a　容器　所在　公用网桥中的　ip sudo docker inspect es-a \"my-bridge\": { \"IPAMConfig\": {}, \"Links\": null, \"Aliases\": [ \"9f05d30f9f9e\" ], \"Gateway\": \"172.19.0.1\", \"IPAddress\": \"172.19.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:13:00:02\", \"DriverOpts\": {} } # 可以看到　在网桥中的　ip　为　\"IPAddress\": \"172.19.0.2\", # kibana 配置文件　设置　es 容器所在的ip elasticsearch.hosts: [\"http://172.19.0.2:9200\"] # 设置完成后　需要重启容器　才能生效（真香） ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:2","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"使用elasticsearch-head　开元项目对es进行管理 git clone https://github.com/mobz/elasticsearch-head.git cd elasticsearch-head npm install npm run start open http://localhost:9100/ ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:3","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"ElasticSearch　解决跨域问题(head　与　es 连接问题) # 在es 配置文件中　加入以下配置　解决跨域问题 http.cors.enabled: true http.cors.allow-origin: \"*\" ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:4","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 配置文件详解 ##################### Elasticsearch Configuration Example ##################### # # 只是挑些重要的配置选项进行注释,其实自带的已经有非常细致的英文注释了! # https://www.elastic.co/guide/en/elasticsearch/reference/current/modules.html # ################################### Cluster ################################### # 代表一个集群,集群中有多个节点,其中有一个为主节点,这个主节点是可以通过选举产生的,主从节点是对于集群内部来说的. # es的一个概念就是去中心化,字面上理解就是无中心节点,这是对于集群外部来说的,因为从外部来看es集群,在逻辑上是个整体,你与任何一个节点的通信和与整个es集群通信是等价的。 # cluster.name可以确定你的集群名称,当你的elasticsearch集群在同一个网段中elasticsearch会自动的找到具有相同cluster.name的elasticsearch服务. # 所以当同一个网段具有多个elasticsearch集群时cluster.name就成为同一个集群的标识. # cluster.name: elasticsearch #################################### Node ##################################### # https://www.elastic.co/guide/en/elasticsearch/reference/5.1/modules-node.html#master-node # 节点名称同理,可自动生成也可手动配置. # node.name: node-1 # 允许一个节点是否可以成为一个master节点,es是默认集群中的第一台机器为master,如果这台机器停止就会重新选举master. # node.master: true # 允许该节点存储数据(默认开启) # node.data: true # 配置文件中给出了三种配置高性能集群拓扑结构的模式,如下： # 1. 如果你想让节点从不选举为主节点,只用来存储数据,可作为负载器 # node.master: false # node.data: true # node.ingest: false # 2. 如果想让节点成为主节点,且不存储任何数据,并保有空闲资源,可作为协调器 # node.master: true # node.data: false # node.ingest: false # 3. 如果想让节点既不称为主节点,又不成为数据节点,那么可将他作为搜索器,从节点中获取数据,生成搜索结果等 # node.master: false # node.data: false # node.ingest: true (可不指定默认开启) # 4. 仅作为协调器 # node.master: false # node.data: false # node.ingest: false # 监控集群状态有一下插件和API可以使用: # Use the Cluster Health API [http://localhost:9200/_cluster/health], the # Node Info API [http://localhost:9200/_nodes] or GUI tools # such as \u003chttp://www.elasticsearch.org/overview/marvel/\u003e, # \u003chttp://github.com/karmi/elasticsearch-paramedic\u003e, # \u003chttp://github.com/lukas-vlcek/bigdesk\u003e and # \u003chttp://mobz.github.com/elasticsearch-head\u003e to inspect the cluster state. # A node can have generic attributes associated with it, which can later be used # for customized shard allocation filtering, or allocation awareness. An attribute # is a simple key value pair, similar to node.key: value, here is an example: # 每个节点都可以定义一些与之关联的通用属性，用于后期集群进行碎片分配时的过滤 # node.rack: rack314 # 默认情况下，多个节点可以在同一个安装路径启动，如果你想让你的es只启动一个节点，可以进行如下设置 # node.max_local_storage_nodes: 1 #################################### Index #################################### # 设置索引的分片数,默认为5 #index.number_of_shards: 5 # 设置索引的副本数,默认为1: #index.number_of_replicas: 1 # 配置文件中提到的最佳实践是,如果服务器够多,可以将分片提高,尽量将数据平均分布到大集群中去 # 同时,如果增加副本数量可以有效的提高搜索性能 # 需要注意的是,\"number_of_shards\" 是索引创建后一次生成的,后续不可更改设置 # \"number_of_replicas\" 是可以通过API去实时修改设置的 #################################### Paths #################################### # 配置文件存储位置 # path.conf: /path/to/conf # 数据存储位置(单个目录设置) # path.data: /path/to/data # 多个数据存储位置,有利于性能提升 # path.data: /path/to/data1,/path/to/data2 # 临时文件的路径 # path.work: /path/to/work # 日志文件的路径 # path.logs: /path/to/logs # 插件安装路径 # path.plugins: /path/to/plugins #################################### Plugin ################################### # 设置插件作为启动条件,如果一下插件没有安装,则该节点服务不会启动 # plugin.mandatory: mapper-attachments,lang-groovy ################################### Memory #################################### # 当JVM开始写入交换空间时（swapping）ElasticSearch性能会低下,你应该保证它不会写入交换空间 # 设置这个属性为true来锁定内存,同时也要允许elasticsearch的进程可以锁住内存,linux下可以通过 `ulimit -l unlimited` 命令 # bootstrap.mlockall: true # 确保 ES_MIN_MEM 和 ES_MAX_MEM 环境变量设置为相同的值,以及机器有足够的内存分配给Elasticsearch # 注意:内存也不是越大越好,一般64位机器,最大分配内存别才超过32G ############################## Network And HTTP ############################### # 设置绑定的ip地址,可以是ipv4或ipv6的,默认为0.0.0.0 # network.bind_host: 192.168.0.1 # 设置其它节点和该节点交互的ip地址,如果不设置它会自动设置,值必须是个真实的ip地址 # network.publish_host: 192.168.0.1 # 同时设置bind_host和publish_host上面两个参数 # network.host: 192.168.0.1 # 设置节点间交互的tcp端口,默认是9300 # transport.tcp.port: 9300 # 设置是否压缩tcp传输时的数据，默认为false,不压缩 # transport.tcp.compress: true # 设置对外服务的http端口,默认为9200 # http.port: 9200 # 设置请求内容的最大容量,默认100mb # http.max_content_length: 100mb # 使用http协议对外提供服务,默认为true,开启 # http.enabled: false ###################### 使用head等插件监控集群信息，需要打开以下配置项 ########### # http.c","date":"2020-09-03","objectID":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["配置"],"title":"Elasticsearch 配置文件详解","uri":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["ElasticSearch"],"content":"最新配置 cluster.name: elasticsearch # 配置的集群名称，默认是elasticsearch，es服务会通过广播方式自动连接在同一网段下的es服务，通过多播方式进行通信，同一网段下可以有多个集群，通过集群名称这个属性来区分不同的集群 node.name: \"Franz Kafka\" # 当前配置所在机器的节点名 node.master: true 指定该节点是否有资格被选举成为node（注意这里只是设置成有资格),默认true node.data: true # 指定该节点是否存储索引数据，默认为true。 index.number_of_shards: 5 # 设置默认索引分片个数，默认为5片。7.X版本以上配置无效 index.number_of_replicas: 1 # 设置默认索引副本个数，默认为1个副本。7.x版本以上配置无效 path.conf: /path/to/conf # 设置配置文件的存储路径，默认是es根目录下的config文件夹。 path.data: /path/to/data # 设置索引数据的存储路径 path.work: /path/to/work # 设置临时文件的存储路径 path.logs: /path/to/logs # 设置日志文件的存储路径 path.plugins: /path/to/plugins # 设置插件的存放路径 network.bind_host: 192.168.0.1 # 设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0，绑定这台机器的任何一个ip。 network.publish_host: 192.168.0.1 # 设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。 network.host: 192.168.0.1 # 这个参数是用来同时设置bind_host和publish_host上面两个参数。 transport.tcp.port: 9300 # 设置节点之间交互的tcp端口，默认是9300。 transport.tcp.compress: true # 设置是否压缩tcp传输时的数据，默认为false，不压缩。 http.port: 9200 # 设置对外服务的http端口，默认为9200。 http.max_content_length: 100mb # 设置内容的最大容量，默认100mb http.enabled: false # 是否使用http协议对外提供服务，默认为true，开启。 gateway.type: local # gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器等。 cluster.routing.allocation.node_initial_primaries_recoveries: 4 # 初始化数据恢复时，并发恢复线程的个数，默认为4。 cluster.routing.allocation.node_concurrent_recoveries: 2 # 添加删除节点或负载均衡时并发恢复线程的个数，默认为4。 indices.recovery.max_size_per_sec: 0 # 设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。 indices.recovery.concurrent_streams: 5 # 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 discovery.zen.minimum_master_nodes: 1 # 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）。7.x版本无效 discovery.zen.ping.timeout: 3s # 设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。7.x版本无效 discovery.zen.ping.multicast.enabled: false # 设置是否打开多播发现节点，默认是true。7.x版本无效 discovery.zen.ping.unicast.hosts: [\"host1\", \"host2:port\", \"host3[portX-portY]\"] # 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。7.x版本无效 discovery.seed_hosts # 在启动此节点时传递要执行发现的主机的初始列表 cluster.initial_master_nodes # 使用初始的一组符合主节点条件的节点引导集群 ","date":"2020-09-03","objectID":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:1","tags":["配置"],"title":"Elasticsearch 配置文件详解","uri":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["ElasticSearch"],"content":"docker 容器安装 Kibana Kibana ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:0:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"挂载 在宿主机上创建kibana config配置目录 eg: 配置文件 mkdir /home/zhang/Document/Kibana/config ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:1:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"Kibana配置 在/home/zhang/Document/Kibana/config目录下创建kibana.yml，具体内容如下： # Kibana is served by a back end server. This setting specifies the port to use. server.port: 5602 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values. # The default is 'localhost', which usually means remote machines will not be able to connect. # To allow connections from remote users, set this parameter to a non-loopback address. server.host: 0.0.0.0 # Enables you to specify a path to mount Kibana at if you are running behind a proxy. # Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath # from requests it receives, and to prevent a deprecation warning at startup. # This setting cannot end in a slash. #server.basePath: \"\" # Specifies whether Kibana should rewrite requests that are prefixed with # `server.basePath` or require that they are rewritten by your reverse proxy. # This setting was effectively always `false` before Kibana 6.3 and will # default to `true` starting in Kibana 7.0. #server.rewriteBasePath: false # The maximum payload size in bytes for incoming server requests. #server.maxPayloadBytes: 1048576 # The Kibana server's name. This is used for display purposes. #server.name: \"your-hostname\" # The URLs of the Elasticsearch instances to use for all your queries. elasticsearch.hosts: [\"http://10.133.0.188:9201\"] # When this setting's value is true Kibana uses the hostname specified in the server.host # setting. When the value of this setting is false, Kibana uses the hostname of the host # that connects to this Kibana instance. #elasticsearch.preserveHost: true # Kibana uses an index in Elasticsearch to store saved searches, visualizations and # dashboards. Kibana creates a new index if the index doesn't already exist. #kibana.index: \".kibana\" # The default application to load. #kibana.defaultAppId: \"home\" # If your Elasticsearch is protected with basic authentication, these settings provide # the username and password that the Kibana server uses to perform maintenance on the Kibana # index at startup. Your Kibana users still need to authenticate with Elasticsearch, which # is proxied through the Kibana server. #elasticsearch.username: \"kibana\" #elasticsearch.password: \"pass\" # Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively. # These settings enable SSL for outgoing requests from the Kibana server to the browser. #server.ssl.enabled: false #server.ssl.certificate: /path/to/your/server.crt #server.ssl.key: /path/to/your/server.key # Optional settings that provide the paths to the PEM-format SSL certificate and key files. # These files are used to verify the identity of Kibana to Elasticsearch and are required when # xpack.security.http.ssl.client_authentication in Elasticsearch is set to required. #elasticsearch.ssl.certificate: /path/to/your/client.crt #elasticsearch.ssl.key: /path/to/your/client.key # Optional setting that enables you to specify a path to the PEM file for the certificate # authority for your Elasticsearch instance. #elasticsearch.ssl.certificateAuthorities: [ \"/path/to/your/CA.pem\" ] # To disregard the validity of SSL certificates, change this setting's value to 'none'. #elasticsearch.ssl.verificationMode: full # Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of # the elasticsearch.requestTimeout setting. #elasticsearch.pingTimeout: 1500 # Time in milliseconds to wait for responses from the back end or Elasticsearch. This value # must be a positive integer. #elasticsearch.requestTimeout: 30000 # List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side # headers, set this value to [](an empty list). #elasticsearch.requestHeadersWhitelist: [ authorization ] # Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten # by client-side headers, regardless of the elasticsearch.requestHeaders","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:2:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"启动 创建docker-compose.yml文件，内容如下： version: '2.2' services: kibana: image: kibana:7.6.2 volumes: - ./kibana.yml:/usr/share/kibana/config/kibana.yml ports: - '5602:5602/tcp' 启动： docker-compose up -d ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:3:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:0:0","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 以7.2.0为例 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:0","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"挂载 在宿主机上创建Elasticsearch的数据存储、config配置目录 eg: # 在 Document 下创建 ElasticSearch 文件夹， 然后再创建 conf data logs 文件夹 用于放置 es的数据， 配置 ， 日志文件 mkdir ELasticSearch cd ElasticSearch mkdir config mkdir logs mkdir data 新建用户 adduser es 数据存储需要赋予权限：sudo chown -R 1000:1000 ~/ELasticSearch/data ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:1","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"Elasticsearch配置 在 ~/ELasticSearch/data/config文件夹下新建elasticsearch.yml、 jvm.options 具体内容可以参考： elasticsearch.yml cluster.name: business-log node.name: es-b-188 http.port: 9200 transport.tcp.port: 9301 network.bind_host: 10.133.0.188 network.publish_host: 10.133.0.188 jvm.options ## JVM configuration ################################################################ ## IMPORTANT: JVM heap size ################################################################ ## ## You should always set the min and max JVM heap ## size to the same value. For example, to set ## the heap to 4 GB, set: ## ## -Xms4g ## -Xmx4g ## ## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html ## for more information ## ################################################################ # Xms represents the initial size of total heap space # Xmx represents the maximum size of total heap space -Xms26g -Xmx26g ################################################################ ## Expert settings ################################################################ ## ## All settings below this section are considered ## expert settings. Don't tamper with them unless ## you understand what you are doing ## ################################################################ ## GC configuration #-XX:+UseConcMarkSweepGC #-XX:CMSInitiatingOccupancyFraction=75 #-XX:+UseCMSInitiatingOccupancyOnly ## G1GC Configuration # NOTE: G1GC is only supported on JDK version 10 or later. # To use G1GC uncomment the lines below. #-XX:-UseConcMarkSweepGC #-XX:-UseCMSInitiatingOccupancyOnly -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=75 ## DNS cache policy # cache ttl in seconds for positive DNS lookups noting that this overrides the # JDK security property networkaddress.cache.ttl; set to -1 to cache forever -Des.networkaddress.cache.ttl=60 # cache ttl in seconds for negative DNS lookups noting that this overrides the # JDK security property networkaddress.cache.negative ttl; set to -1 to cache # forever -Des.networkaddress.cache.negative.ttl=10 ## optimizations # pre-touch memory pages used by the JVM during initialization -XX:+AlwaysPreTouch ## basic # explicitly set the stack size -Xss1m # set to headless, just in case -Djava.awt.headless=true # ensure UTF-8 encoding by default (e.g. filenames) -Dfile.encoding=UTF-8 # use our provided JNA always versus the system one -Djna.nosys=true # turn off a JDK optimization that throws away stack traces for common # exceptions because stack traces are important for debugging -XX:-OmitStackTraceInFastThrow # flags to configure Netty -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 # log4j 2 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=${ES_TMPDIR} ## heap dumps # generate a heap dump when an allocation from the Java heap fails # heap dumps are created in the working directory of the JVM -XX:+HeapDumpOnOutOfMemoryError # specify an alternative path for heap dumps; ensure the directory exists and # has sufficient space -XX:HeapDumpPath=data # specify an alternative path for JVM fatal error logs -XX:ErrorFile=logs/hs_err_pid%p.log ## JDK 8 GC logging 8:-XX:+PrintGCDetails 8:-XX:+PrintGCDateStamps 8:-XX:+PrintTenuringDistribution 8:-XX:+PrintGCApplicationStoppedTime 8:-Xloggc:logs/gc.log 8:-XX:+UseGCLogFileRotation 8:-XX:NumberOfGCLogFiles=32 8:-XX:GCLogFileSize=64m # JDK 9+ GC logging 9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m # due to internationalization enhancements in JDK 9 Elasticsearch need to set the provider to COMPAT otherwise # time/date parsing will break in an incompatible way for some date patterns and locals 9-:-Djava.locale.providers=COMPAT 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:2","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"启动 创建docker-compose.yml文件，内容如下： version: '2.2' services: elasticsearch: image: elasticsearch:7.2.0 restart: always container_name: es-a network_mode: host volumes: - /home/zhang/Documents/ElasticSearch/data-a:/usr/share/elasticsearch/data - /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml - /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options environment: - bootstrap.memory_lock=true - ES_JAVA_OPTS= -Xms64m -Xmx128m ulimits: memlock: soft: -1 hard: -1 启动： docker-compose up -d # 在使用 docker-compose 创建容器的过程中 创建端口映射不成功 所以使用一下命令创建， 可解决此问题。 sudo docker run -id --name=es-a -p 9200:9200 -p 9300:9300 -v /home/zhang/Documents/ElasticSearch/data/data-a:/usr/share/elasticsearch/data -v /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS= -Xms1024m -Xmx1024m\" elasticsearch:7.2.0 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:3","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"备注 elasticsearch.yml、jvm.options、docker-compose.yml等每个节点都需要配置，其中elasticsearch.yml、docker-compose.yml具体节点信息需要替换。 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:4","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"什么是 Apache Lucene ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:0","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"有必要了解的有Apache Apache软件基金会（也就是Apache Software Foundation，简称为ASF）是专门为运作一个开源软件项目的Apache 的团体提供支持的非盈利性组织，这个开源软件的项目就是 Apache 项目。 最初，Apache基金会的开发爱好者开发并维护一个叫Apache的HTTP服务器。 后来，Apache服务器越来越火，就启动了更多的项目，比如PHP、Java Apache以及更多的子项目。比如Jakarta。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:1","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"Jakarta Jakarta是为了发展Java容器而启动的Java Apache的项目。后来随着Java的火爆而成为了囊括了众多基于Java语言开源软件子项目的项目。比如从这里孵化出了Tomcat、[ant](https://baike.baidu.com/item/apache ant/1065741?fr=aladdin)、Struts、Lucene。Jakarta ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:2","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"Lucene Lucene是Apache软件基金会4 jakarta项目的子项目。它是一个开源的全文检索引擎工具包。但它并不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。 最后，引用来自《Elasticsearch权威指南》书中关于Lucene的描述作为总结： Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:3","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"常见的开源搜索引擎 基于Lucene的搜索引擎，Java开发，包括： Lucene Solr elasticsearch katta compass 基于C++开发的： Sphinx 你可以想想Lucene的强大。接下来简要的介绍各搜索引擎的特点。 Lucene Lucene的开发语言是Java，也是Java家族中最为出名的一个开源搜索引擎，在Java世界中已经是标准的全文检索程序，它提供了完整的查询引擎和索引引擎，没有中文分词引擎，需要自己去实现，因此用Lucene去做一个搜素引擎需要自己去架构，另外它不支持实时搜索。 优点： 成熟的解决方案，有很多的成功案例。apache 顶级项目，正在持续快速的进步。庞大而活跃的开发社区，大量的开发人员。它只是一个类库，有足够的定制和优化空间：经过简单定制，就可以满足绝大部分常见的需求；经过优化，可以支持 10亿+ 量级的搜索 缺点： 需要额外的开发工作。所有的扩展，分布式，可靠性等都需要自己实现；非实时，从建索引到可以搜索中间有一个时间延迟，而当前的“近实时”(Lucene Near Real Time search)搜索方案的可扩展性有待进一步完善 Solr Solr是一个企业级的高性能、采用Java开发，基于Lucene的全文搜索服务器。 文档通过Http利用XML加到一个搜索集合中。 查询该集合也是通过 http收到一个XML/JSON响应来实现。它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提 供一套强大Data Schema来定义字段，类型和设置文本分析，提供基于Web的管理界面等。 优点： Solr有一个更大、更成熟的用户、开发和贡献者社区 支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式 Solr比较成熟、稳定 不考虑建索引的同时进行搜索，速度更快 缺点： 建立索引时，搜索效率下降，实时索引搜索效率不高 Sphinx Sphinx一个基于SQL的全文检索引擎，特别为一些脚本语言（PHP,Python，Perl，Ruby）设计搜索API接口。 Sphinx是一个用C++语言写的开源搜索引擎，也是现在比较主流的搜索引擎之一，在建立索引的时间方面比Lucene快50%，但是索引文件比Lucene要大一倍，因此Sphinx在索引的建立方面是空间换取时间的策略，在检索速度上，和lucene相差不大，但检索精准度方面Lucene要优于Sphinx，另外在加入中文分词引擎难度方面，Lucene要优于Sphinx.其中Sphinx支持实时搜索，使用起来比较简单方便. Sphinx可以非常容易的与SQL数据库和脚本语言集成。当前系统内置MySQL和PostgreSQL 数据库数据源的支持，也支持从标准输入读取特定格式 的XML数据。通过修改源代码，用户可以自行增加新的数据源（例如：其他类型的DBMS 的原生支持） Sphinx的特点： 高速的建立索引(在当代CPU上，峰值性能可达到10 MB/秒) 高性能的搜索(在2 – 4GB 的文本数据上，平均每次检索响应时间小于0.1秒) 可处理海量数据(目前已知可以处理超过100 GB的文本数据, 在单一CPU的系统上可 处理100 M 文档) 提供了优秀的相关度算法，基于短语相似度和统计（BM25）的复合Ranking方法 支持分布式搜索 支持短语搜索 提供文档摘要生成 可作为MySQL的存储引擎提供搜索服务 支持布尔、短语、词语相似度等多种检索模式 文档支持多个全文检索字段(最大不超过32个) 文档支持多个额外的属性信息(例如：分组信息，时间戳等) 支持断词 ElasticSearch ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 优点： 分布式：节点对外表现对等，加入节点自动均衡 elasticsearch完全支持Apache Lucene的接近实时的搜索 各节点组成对等的网络结构，当某个节点出现故障时会自动分配其他节点代替期进行工作 横向可扩展性，如果你需要增加一台服务器，只需要做点配置，然后启动就完事了 高可用：提供复制（replica）机制，一个分片可以设置多个复制，使得某台服务器宕机的情况下，集群仍旧可以照常运行，并会把由于服务器宕机丢失的复制恢复到其它可用节点上；这点也类似于HDFS的复制机制（HDFS中默认是3份复制） 缺点： 不支持事物 相对吃内存 see also：Apache Lucene | 开源搜索引擎分类 | ElasticSearch vs Solr多维度分析对比 | Lucene：基于Java的全文检索引擎简介 欢迎斧正，that’s all ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:4","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"在linux 上安装 elasticsearch ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:0","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"前言 由于elasticsearch依赖java环境，所以，我们首先要安装java jdk。 这里我们使es和kibana的版本保持一致，环境如下： centos7.3 java1.8 elasticsearch6.7.0 kibana6.7.0 ik6.7.0 另外，要检查一下防火墙是否关闭： Copyfirewall-cmd --state # 检查防火墙是否关闭 systemctl stop firewalld.service # 停止firewall systemctl disable firewalld.service # 禁止开机启动 ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:1","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"Docker 安装 es 拉取镜像 sudo docker pull elasticsearch:7.2.0 等待下载完成， （选择docker是因为 docker比较轻便 不会出现各种各样的 java环境问题） 创建容器 # 在 Document 下创建 ElasticSearch 文件夹， 然后再创建 conf data logs 文件夹 用于放置 es的数据， 配置 ， 日志文件 mkdir ELasticSearch cd ElasticSearch mkdir conf mkdir logs mkdir data # 使用run 命令 创建 es 容器 sudo docker run -id --name=es-a -p 9200:9200 -p 9300:9300 -v /home/zhang/Documents/ElasticSearch/data/data-a:/usr/share/elasticsearch/data -v /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS= -Xms1024m -Xmx1024m\" elasticsearch:7.2.0 sudo curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:2","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:0","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch 现在，你还离得开搜索吗？无论是Google还是百度提供的搜索入口，还是项目自己的搜索，比如QQ提供的搜索入口等等，都大大的方便了我们的工作、生活。但是你有没有想过——搭建属于自己的搜索服务，应用于你的博客项目、公司项目…… 无论你想不想，都要学习！因为随着公司业务的增长，数据也爆炸性增长。对于数据的处理、日志分析，如果还采用传统的方法，这恐怕是灾难性的。所以，我们是时候学习一个先进的搜索引擎了。 Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 你以为这些就完了？elasticsearch除了Lucene和全文搜索，我们还可以描述它： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据。 并且，这些功能都被集成到一个服务里面，elasticsearch也提供的与其它语言的接口，其中包括： Java JavaScript Groovy .NET PHP Perl Python Ruby 以及社区贡献的更多接口 使用我们喜欢的语言通过RESTful API接口，访问9200端口，就可以与elasticsearch玩耍了。 上手elasticsearch非常容易，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。 随着越学越深入，还可以利用Elasticsearch更多高级的功能，整个引擎可以很灵活地进行配置。可以根据自身需求来定制属于自己的Elasticsearch。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:1","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch 模糊历史 多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。 直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。 后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。 第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。 Shay的妻子依旧等待着她的食谱搜索…… ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:2","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch ： 面向文档（工作原理） 我们知道，关系型数据库以记录和行的形式存储数据，但是在elasticsearch中，是以文档的形式存储数据。 但区别在于，文档要比数据表的行更加灵活。因为文档可以是多层次的，它（文档）鼓励你将属于一个逻辑实体的数据保存在同一个文档中，而不是散落在各个表的不同行中。这样查询效率很高，因为我们无需连接其他的表，我们学习关系型数据库时，一定知道连表查询（尤其是连接多张表）是多么的费时吧！ ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:3","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"成功案例 之前有人说，elasticsearch的缺点之一是没有成熟的案例加持，那我们就来看看elasticsearch都有哪些成熟的案例： 维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。 英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。 StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。 GitHub使用Elasticsearch来检索超过1300亿行代码，可以参考A Whole New Code Search 每天，Goldman Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。 苏宁在大数据平台使用es存储600TB数据，集群规模包括：搭建超过500+物理机，30万shards，80000index。参考 腾讯在日志实时分析中采用es，处理高并发100W/S，PE级数据。 更多参考 所以，elasticsearch可以灵活的应用于我们的项目中。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:4","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"如何学elasticsearch 除了万能的百度和Google 之外，我们还有一些其他的学习途径： elasticsearch官方文档：这个比较好点，可以多多参考 elasticsearch博客：这个吧，看看就行 elasticsearch社区：社区还是很好的 elasticsearch视频：包括入门视频什么的 elasticsearch实战：该书籍的质量还是不错的。 elasticsearch权威指南：同样的，这个也不错。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:5","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch 能处理的数据量 一个很好地问题，不幸的是，单一索引的极限取决于存储索引的硬件、索引的设计、如何处理数据以及你为索引备份了多少副本。 通常来说，一个Lucene索引（也就是一个elasticsearch分片）不能处理多于21亿篇文档，或者多于2740亿的唯一词条。但达到这个极限之前，我们可能就没有足够的磁盘空间了！ 当然，一个分片如何很大的话，读写性能将会变得非常差。 扯了半天的淡，让我们开始一个灵活的学习之旅吧。 see also： 入门指南 | Elasticsearch Clients | 搜索引擎选择： Elasticsearch与Solr | Elasticsearch 基本介绍及其与 Python 的对接实现 | Elasticsearch权威指南中文版（截止本博客发表，还没有翻译完…….） 欢迎斧正，that’s all ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:6","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["GO"],"content":"1 接口 接口定义一个对象的行为。接口只指定了对象应该做什么，至于如何实现这个行为（即实现细节），则由对象本身去确定。 （python中 abc 模块 可以强制要求子类必须重写父类的方法 否则报错） python和go都属于鸭子类型，非侵入式接口 java：侵入式接口 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、定义接口 （接口是一系列行为的集合：一系列方法的集合） type Duck interface { run() speak() } //只要结构体绑定了接口中的所有方法，这个结构体就叫实现了Duck接口 type TDuck struct { name string age int wife string } //实现TDuck接口(绑定接口中的所有方法) func (t TDuck)Run() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我说人话\") } func (t TDuck)Speak() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我学人走路\") } //定义一个RDuck结构体 type RDuck struct { name string age int } //RDuck实现接口（实现接口中的所有方法） func (t RDuck)Run() { fmt.Println(\"我是普通肉鸭，我的名字是\",t.name,\"我阿嘎嘎叫\") } func (t RDuck)Speak() { fmt.Println(\"我是普通肉鸭，我的名字是\",t.name,\"我歪歪扭扭走路\") } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 实例化得到TDuck和 RDuck 两个对象 t:=TDuck{\"鸡哥\",88,\"凤姐\"} r:=RDuck{\"普通鸭子\",2} t.Run() t.Speak() r.Run() r.Speak() //接口也是一个类型（可以定义一个变量是接口类型） // 同一类事物的多种形态 var d DuckInterface d=t //d=r d.Speak() d.Run() //想再去t的属性，name，age，wife test(t) // {鸡哥 88 凤姐} //test(r) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 类型断言 func test(d DuckInterface) { //d.Run() //d.Speak() //var t TDuck //t=d.(TDuck) t:=d.(TDuck) //断言d是TDuck类型，如果正确，就会把d转成t fmt.Println(t.name) fmt.Println(t.wife) t.Speak() t.Run() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 类型选择 func test(d DuckInterface) { switch a:=d.(type) { case TDuck: fmt.Println(a.wife) fmt.Println(\"你是TDuck类型\") case RDuck: fmt.Println(a.name) fmt.Println(\"你是RDuck类型\") default: fmt.Println(\"不知道是什么类型\") } } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5、 空接口 //-只要一个类型，实现接口所有的方法，就叫实现该接口 //-如果一个接口是空的，一个方法都没有，所有类型都实现了空接口 //-任意类型，都可以赋值给空接口类型 var a EmptyInterface a=1 a=\"xx\" a=[3]int{1,2,3} ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:5","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6、 接口类型空值（nil） var a EmptyInterface fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:6","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"7、有名 / 匿名空接口 // 有名空接口 type EmptyInterface interface { } // 匿名空接口 func test(i interface{}) { } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:7","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"8、 实现多个接口 type DuckInterface1 interface { Run() Speak() } type HumanInterface interface { Drive() } //定义一个TDuck结构体 type TDuck1 struct { name string age int wife string } //TDuck实现接口（实现接口中的所有方法） func (t TDuck1)Run() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我说人话\") } func (t TDuck1)Speak() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我学人走路\") } //实现HumanInterface接口 func (t TDuck1)Drive() { fmt.Println(\"我是唐老鸭，我开车\") } func main() { t:=TDuck1{\"鸡哥\",18,\"凤姐\"} var d DuckInterface1 var h HumanInterface d=t d.Run() d.Speak() h=t h.Drive() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:8","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"9、 接口嵌套 type DuckInterface1 interface { Run() Speak() } type HumanInterface interface { DuckInterface1 //相当于 //Run() //Speak() Drive() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:9","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2 并发和并行 # 并发：假如在他晨跑时，鞋带突然松了。于是他停下来，系一下鞋带，接下来继续跑 # 并行：如这个人在慢跑时，还在用他的 iPod 听着音乐 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:2:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3 go 协程 go协程 –\u003e goroutine，并不是真正的协程（线程+协程，语言层面处理了，不需要开发者去关注） package main import ( \"fmt\" \"time\" ) func hello() { fmt.Println(\"go go go！\") } func main() { fmt.Println(\"主函数开始\") go hello() //通过go关键字，开启goroutine，并发执行 go hello() go hello() go hello() fmt.Println(\"主函数结束\") time.Sleep(2*time.Second) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:3:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4 信道 goroutine直接通信 go语言不推崇共享变量方法做通信，而推崇管道通信channel（信道） ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、 信道也是一个变量（需要指明运输类型） var a chan int //定义一个int类型信道 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 信道的零值， nil类型， 它是一个引用 fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 信道初始化 var a chan int=make(chan int) fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 信道放值和取值 var a chan int=make(chan int) a\u003c-1 //放值，把1放到信道中 var b int=\u003c-a //取值 //\u003c-a //取值 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5、 默认情况下，信道的放值和取值都是阻塞的(一次一个都放不进去) package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"开始\") var a chan bool=make(chan bool) //信道是引用类型 go hello1(a) \u003c-a time.Sleep(2*time.Second) } func hello1(a chan bool) { fmt.Println(\"go go go\") a\u003c-true fmt.Println(\"xxx\") } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:5","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6、 信道案例 package main /* 输入 453 计算每一位的平方和和每一位的立方和的和 squares = (4 * 4) + (5 * 5) + (3 * 3) cubes = (4 * 4 * 4) + (5 * 5 * 5) + (3 * 3 * 3) output = squares + cubes */ import ( \"fmt\" ) func calcSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 //% 取余数 453对10取余数--》3--》5--》4 sum += digit * digit number /= 10 // /除以 453除以10----》45--》5--》0 } squareop \u003c- sum } func calcCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u003c- sum } func main() { number := 4535 sqrch := make(chan int) cubech := make(chan int) go calcSquares(number, sqrch) go calcCubes(number, cubech) squares, cubes := \u003c-sqrch, \u003c-cubech //squares:= \u003c-sqrch //cubes := \u003c-cubech fmt.Println(\"Final output\", squares + cubes) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:6","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"7、 死锁 、 单项信道 与 信道关闭 package main func main() { //1 死锁 //var a chan int=make(chan int) //a\u003c-1 //一直阻塞在这，报死锁错误 //\u003c-a //一直阻塞在这，报死锁错误 //2 单向信道（只写或者只读） //sendch := make(chan int) //定义一个可写可读信道 //go sendData(sendch) //fmt.Println(\u003c-sendch) //只能往里写值，取值报错 //3 信道的关闭 close //sendch := make(chan int) //close(sendch) } func sendData(sendch chan\u003c- int) { //转成只写信道 sendch \u003c- 10 //\u003c-sendch //只要读就报错 } package main import ( \"fmt\" ) func producer(chnl chan int) { for i := 0; i \u003c 10; i++ { chnl \u003c- i } close(chnl) } func main() { ch := make(chan int) go producer(ch) for v := range ch { //如果信道没关闭，一直取值，直到没有值，会报死锁 fmt.Println(\"Received \",v) } } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:7","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5 缓冲信道 有缓冲的信道， 可以放多个值 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、 缓冲信道的定义和死锁问题 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var a chan int =make(chan int,2) //长度为4的有缓冲信道 a\u003c-1 a\u003c-2 //管子满了 //a\u003c-5 //报死锁错误 //推断出无缓冲信道 var a chan int =make(chan int,0) fmt.Println(\u003c-a) fmt.Println(\u003c-a) //管子没有东西了，再取，报死锁 //fmt.Println(\u003c-a) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 信道的容量和长度 //长度是目前管道中有几个值，容量是管道最多能容纳多少值 var a chan int =make(chan int,4) fmt.Println(len(a)) fmt.Println(cap(a)) a\u003c-1 a\u003c-2 fmt.Println(len(a)) fmt.Println(cap(a)) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 小案例 (通过信道实现goroutine的同步) var a chan int =make(chan int,3) //b:=\u003c-a go test3(a) fmt.Println(\u003c-a) fmt.Println(\u003c-a) func test3(a chan int) { a\u003c-1 time.Sleep(time.Second*2) fmt.Println(\"假设我在运算\") a\u003c-2 close(a) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 通过 waitgroup 实现同步 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { no := 3 var wg sync.WaitGroup //值类型，没有初始化，有默认值 for i := 0; i \u003c no; i++ { wg.Add(1) go process(i, \u0026wg) } wg.Wait() //add了几次，必须有几个wg.Done()对应，否则一直等在这 fmt.Println(\"All go routines finished executing\") } func process(i int, wg *sync.WaitGroup) { fmt.Println(\"started Goroutine \", i) time.Sleep(2 * time.Second) fmt.Printf(\"Goroutine %d ended\\n\", i) wg.Done() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6 异常处理 defer:延迟执行，即便程序出现严重错误，也会执行 panic：主动抛出异常 raise recover：恢复程序，继续执行 //异常处理 package main import \"fmt\" //func main() { // f1() // f2() // f3() //} //func f1() { // fmt.Println(\"f1\") //} // //func f2() { // fmt.Println(\"f2\") // //如果这个地方出了异常 //} //func f3() { // fmt.Println(\"f3\") //} //defer:延迟执行，即便程序出现严重错误，也会执行 //panic：主动抛出异常 raise //recover：恢复程序，继续执行 //func main() { // //defer fmt.Println(\"我最后才执行\") //先注册，等函数执行完成后，逆序执行defer注册的代码 // //defer fmt.Println(\"ddddd\") // defer func() { // fmt.Println(\"我最后才执行\") // }() // defer func() { // fmt.Println(\"我最后才执行\") // //出异常 // //这个代码执行不到了 // }() // // fmt.Println(\"111\") // fmt.Println(\"222\") // panic(\"我出错了\") //主动抛出异常 // //var a []int =make([]int,2,3) // //fmt.Println(a[9]) // fmt.Println(\"这句话还会执行吗 ？不会了\") //} //在defer中恢复程序，继续执行 func main() { f1() f2() f3() } func f1() { fmt.Println(\"f1\") } func f2() { defer func() { //recover() //恢复程序继续执行 if err:=recover();err!=nil{ //err 如果不为nil(空），表示出了异常 fmt.Println(err) //把异常信息打印出来 } }() fmt.Println(\"f2\") //如果这个地方出了异常 panic(\"我出错了\") fmt.Println(\"永远执行不到\") } func f3() { fmt.Println(\"f3\") } // python中 //print('ssss') //try: // print('ssss') // raise(\"xxxx\") // print('我永远不会执行') //except Exception as e: // print(e) //finally: // print('我永远会执行') //go 中 //print('ssss') //defer func() { // if err:=recover();err!=nil{ // fmt.Println(err) // } // //finally 写在这 // print('我永远会执行') //}() //print('ssss') //panic(\"xxxx\") //print('我永远不会执行') [toc] ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:6:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"指针 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、定义指针 // 指向int类型的指针（指向什么类型指针，就是在什么类型前加星号） var a *int ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、指针的零值 fmt.Println(a) //nil ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、使用指针 var a *int var b int=100 // a指针指向b （取谁的地址，就是在谁前面加一个\u0026） a=\u0026b fmt.Println(a) // 0xc0000b4008 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、了解（骚操作） var a *int var b **int= \u0026a var c ***int= \u0026b var d ****int =\u0026c fmt.Println(d) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、 解引用 （把指针反解成值）（在指针变量前加*，表示解引用） fmt.Println(*a) fmt.Println(***d) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、 向函数传递指针参数 var a int =100 ////在函数中把a的值改成101 fmt.Println(a) test2(\u0026a) fmt.Println(a) func test2(a *int) { //解引用然后，自增1 //*a++ *a=*a+100 fmt.Println(*a) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、不要向函数传递数组指针， 而应该使用切片 var a [4]int = [4]int{1,2,3} fmt.Println(a) //test3(\u0026a) test4(a[:]) fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、go 不支持指针运算(在c中可以通过数组指针的运算进行取值) var b int=100 var a *int=\u0026b //a++ ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、 指针数组和数组指针 // 指针数组 --\u003e 数组里面放指针 var a int =10 var b int =20 var c int =30 var d [3]*int=[3]*int{\u0026a,\u0026b,\u0026c} fmt.Println(d) // 数组指针 --\u003e 指针数组指针 var a [3]int=[3]int{1,3,4} var b *[3]int=\u0026a fmt.Println(b) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"结构体 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、 什么是结构体 //结构体,go语言中的面向对象 //结构体是用户定义的类型,表示若干个字段（Field）的集合 //类比面向对象中的类，只有属性，没有方法 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、 定义一个结构体 // type关键字 结构体名字 struct关键字 {一个一个的字段} type Person struct { name string age int sex string } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、使用结构体 //（结构体的零值，是属性的零值)不是nil，它不是引用类型，是值类型 var a Person fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、 定义并初始化 // 1 var a Person=Person{} // 2 var a Person=Person{name:\"lqz\",age:19,sex:\"男\"} // 3 var a =Person{name:\"lqz\",age:19,sex:\"男\"} // 4 a :=Person{name:\"lqz\",age:19,sex:\"男\"} // 5 a :=Person{sex:\"男\",name:\"lqz\",age:19} // 6 a :=Person{sex:\"男\",name:\"lqz\"} //按位置初始化(固定位置，并且都传) a :=Person{\"lqz\",19,\"男\"} fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、 使用结构体 var a Person=Person{name:\"zhang\",age:19,sex:\"男\"} fmt.Println(a.name) a.name=\"wang\" fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、 匿名结构体（没有名字,没有type关键字，定义在函数内部） //什么情况下用？只使用一次，数据整合在一起 a:=struct { name string age int sex string }{\"lqz\",19,\"男\"} fmt.Println(a.name) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、结构体的指针（结构体是值类型） var a *Person=\u0026Person{\"zhang\",19,\"男\"} fmt.Println(a) //Go 语言允许我们在访问 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName fmt.Println((*a).name) fmt.Println(a.name) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、 匿名字段（字段没有名字,不允许有多个同类型的字段） 有什么用？用来做字段提升，面向对象中的继承 type Person struct { string int } //按位置实例化 a:=Person{\"zhang\",19} //按关键字实例化 a:=Person{int:19,string:\"zhang\"} fmt.Println(a) fmt.Println(a.string) fmt.Println(a.int) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、嵌套结构体（结构体套结构体） 不管是结构体名字还是字段名字，大写字母开头，表示导出字段，表示在外部包可以使用 //面向对象封装（python __） type Person struct { Name string Age int Sex string hobby Hobby } type Hobby struct { HobbyId int HobbyName string } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"10、 提升字段 type Person struct { Name string Age int Sex string Hobby } type Hobby struct { HobbyId int HobbyName string } // 此处就相当于是python中 类的继承， 求中 Hobby 是父类 Person 是子类 // 提升字段可以直接在Person 结构体的实例中以点的方式进行访问 11、字段冲突 type Person struct { Name string Age int Sex string Hobby } type Hobby struct { HobbyId int Name string } // 当父结构体（父类）Hobby 中有Name Person中也有Name 当进行实例化的时候， 优先访问的是子结构体Person中的name 这也是子类重写父类的属性。 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:10","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"方法 结构体+方法就是实现面向对象中的类 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、 什么是方法 方法其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的 python中什么是方法， 什么是函数？ \"\"\" 1、 方法是面向对象中的概念，对象绑定方法，类的绑定方法，可以自动传值， 2、 类中不加任何装饰器定义的函数，是对象的绑定方法，对象来调用，可以自动传值，类也可以来掉，如果类来调用，他就是普通函数，有几个值就传几个值 3、 类的绑定方法，类来调用，会把类自动传入 \"\"\" ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、方法的定义 //定义一个结构体 type Person struct { name string age int sex string } //给结构体绑定方法(无参数) func (p Person1)PrintName() { fmt.Println(p.name) } // 绑定一个修改名字的方法(有参数) func (p Person1)ChangeName(name string) { p.name=name fmt.Println(\"--------\",p) } //普通函数 func PrintName(p Person1) { fmt.Println(p.name) } p:=Person1{\"zhang\",19,\"男\"} p.PrintName() // zhang ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、 为什么要有结构体的绑定方法 Go 不是纯粹的面向对象编程语言，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。 相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。假设我们有一个 Square 和 Circle 结构体。可以在 Square 和 Circle 上分别定义一个 Area 方法。见下面的程序。 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、值接收器和指针接收器 //指针类型接收器，修改age的方法 func (p *Person1)ChangeAge(age int) { p.age=age //(*p).age=age //正常操作 fmt.Println(\"--------\",p) } p:=Person1{\"zhang\",19,\"男\"} p.ChangeName(\"wang\") // 值接收器，改新的，不会影响原来的，不会影响当前的p对象 fmt.Println(p) // 调用指针类型接收器的方法 p.ChangeAge(100) //指针类型接收器，会影响原来的，会影响当前的p对象 fmt.Println(p) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、值接收器和指针接收器的应用场景 //用指针接收器的情况 //1 方法内部的改变，影响调用者 //2 当拷贝一个结构体的代价过于昂贵时 ,就用指针接收器 //其他情况，值接收器和指针接收器都可以 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、匿名字段的方法（重点） p:=Person1{\"wang\",19,\"男\",Hobby1{1,\"篮球\"}} //匿名字段，属性可以提升 //匿名字段，方法也提升 p.printName() // 也提升了 子类对象调用父类中的方法，子类中没有，就是调用父类的--》 对象.方法名 p.Hobby1.printName() // 正常操作 直接指名道姓的调用父类中的方法---》 super().方法名 // 子类中重写了父类的方法（嵌套结构体中有重名的方法） p.printName() ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、在方法中使用值接收器 与 在函数中使用值参数 type Person1 struct { name string age int sex string } //方法中使用值接收器 func (p Person1)printName() { fmt.Println(p.name) } p:=Person1{\"zhang\",19,\"男\"} p.printName() // zhang printName(p) //在函数中使用值参数 func printName(p Person1) { fmt.Println(p.name) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、在方法中使用指针接收器 与 在函数中使用指针参数 type Person1 struct { name string age int sex string } //在方法中使用指针接收器 func (p *Person1)printName() { fmt.Println(p.name) } //在函数中使用指针参数 func printName(p *Person1) { fmt.Println(p.name) // printName(\u0026a) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、在非结构体上的方法 // 给数据类型加方法 // 错误方式 func (i int)add() { i=i+i } // 自己定义类型， 可以绑定方法 type myInt int func (i *myInt)add() { (*i)++ fmt.Println(*i) } i:=10 i.add() [toc] ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"数组 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、定义 //1 基本使用：定义 //定义了一个大小为3的int类型数组 //数组在定义阶段，大小和类型就固定了 var a [3]int //只定义，没有初始化 fmt.Println(a) // 因int 类型的0值是0 所以， 未初始化数组是[0,0,0] ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、使用数组 var a [3]int a[2]=100 fmt.Println(a) // [0,0,100] fmt.Println(a[0]) // 100 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、定义并赋值 // 方式1 var a [3]int=[3]int{1,2,3} // 方式2 var a =[3]int{1,2,3} // 方式3 a := [3]int{1, 2, 3} //只给第2个位置设为99 a := [3]int{2:99} // 进阶版 a := [3]int{2:99,1:88} fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、数组的大小是类型的一部分 //这两个不是一个类型 var a [2]int var b [3]int a=b // 类型不一样 无法赋值 fmt.Println(a\u003eb) // 类型不一样 无法比较 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、数组是值类型（当参数传递到函数中，修改不会改变原来的值） // go语言中，都是copy传递 /* python中都是引用传递，一切皆对象，就是地址，当做参数传递是把地址传过去了 python中比较特殊：可变类型和不可变类型 */ var a [3]int=[3]int{5,6,7} fmt.Println(a) test1(a) fmt.Println(a) func test(a int){ a[0]=999 fmt.Println(a) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、数组长度（len()） var a [3]int=[3]int{5,6,7} fmt.Println(len(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、循环数组 //方式一 var a [3]int=[3]int{5,6,7} for i:=0;i\u003clen(a);i++{ fmt.Println(a[i]) } //方式二 range:是一个关键字 var a [3]int=[3]int{5,6,7} for i,v:=range a{ fmt.Println(i) //索引 fmt.Println(v) //数组的值 } //函数如果返回两个值，必须用两个值来接收 //range可以用一个值来接收，如果用一个值来接收，就是索引 for i:=range a{ fmt.Println(i) //索引 } //只取值，不取索引 for _,v:=range a{ fmt.Println(v) //值 } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、多维数组 var a [3][2]int = [3][2]int{ {1, 2}, {4, 5}, {9, 70} } //a[1][0]=999 fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"切片 切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。 切片底层依附于数组 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、创建切片 // 先创建数组 var a [9]int = [9]int{1,2,3,4,5,6,7,8,9} // []int 就是切片的一种类型 var b []int b = a[0:3] // 前闭后开 // 没有 -1 没有步长 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、使用切片 fmt.Println(b[0]) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、切片的修改会影响底层数组， 数组的修改也会影响切片 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[0:3] //前闭后开 fmt.Println(a) fmt.Println(b) a[0]=999 b[2]=888 fmt.Println(a) fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、切片的长度和容量 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[2:3] //前闭后开 fmt.Println(len(b)) // 切片的长度是1 //切片容量是9，意思是，可以往里追加值，追加成9个 fmt.Println(cap(b)) 注意 切片的容量不是源数组的长度， 是源数组从开始切的位置到数组末尾的长度 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、追加值 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[2:3] //前闭后开 b=append(b,1) b=append(b,11,22,33,44,55) fmt.Println(len(b)) fmt.Println(cap(b)) fmt.Println(b) fmt.Println(a) //到了数组的尾部，继续追加值 b=append(b,999) fmt.Println(len(b)) fmt.Println(cap(b)) //容量是14 //总结1：当切片追加值，超过了切片容量，切片容量会翻倍，在原来容量基础上乘以2 //b=append(b,222,333,444,555,666,7,8) //fmt.Println(len(b)) //fmt.Println(cap(b)) //容量是14 //总结2：一旦超过了原数组， 就会重新申请数组，把数据copy到新数组，切片和原数组就没有关系了 //fmt.Println(a) //fmt.Println(b) //a[8]=7777 //fmt.Println(a) //fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、通过 make创建切片（底层也是依附于数组） var a []int // 切片的零值是什么？ nil类型： 是所有引用类型的空值 fmt.Println(a) if a==nil{ fmt.Println(\"我是空的\") } var a []int=make([]int,3,4) // 3是长度，4是容量 a=append(a,55) fmt.Println(a) fmt.Println(len(a)) // 3 fmt.Println(cap(a)) // 4 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、切片定义并赋初值 var a []int=[]int{1,2,3} fmt.Println(a) fmt.Println(len(a)) fmt.Println(cap(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、切片是引用类型，当参数传递， 会修改掉原来的值 var a []int=[]int{1,2,3} fmt.Println(a) test3(a) fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"9、多维切片 var a [][]int=make([][]int,2,3) fmt.Println(a) fmt.Println(a[0]==nil) a[0][0]=999 // 这样赋值会报错， 因为make 只是初始化了最外层， 即第一层[] 第二层[] 没有初始化。 // 解决， 可以使用for循环进行初始化 a[0]=make([]int,2,3) a[0][1]=999 fmt.Println(a) a[1][0]=99999 // 定义并赋初始值常用 var a [][]int=[][]int{ {1,2,3}, {4,5,6,7,7,8} } //跟上面不一样 var a [][3]int=[][3]int{ {1,2,3}, {4,5,6} } fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:9","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"10、切片拷贝 var a[]int = make([]int,3,4) var b[]int=make([]int,2,6) a[0]=11 a[1]=22 a[2]=33 b[0]=999 copy(b,a) fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:10","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"11、切片越界 var a[]int = make([]int,3,4) a[0]=11 a[1]=22 a[2]=33 a=append(a,000) // 中括号取值， 只能取到长度， 不能取到容量大小 fmt.Println(a[3]) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:11","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"Maps: hash, 字典 (key:value) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、map的定义和使用 // map[key]value 类型： key 的类型必须是可hash的， key值： 数字， 字符串 // map的零值是 nil， 它是一个引用类型 var a map[int]string fmt.Println(a) if a==nil{ fmt.Println(\"我是空的\") } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、map的使用 // 定义未初始化 var map[int]string // 定义并初始化 使用make var map[int]string = make(map[int]string) // 使用[] 添加/修改， a[1]=\"zhang\" a[2]:\"wang\" a[3]:\"qilitang\" // a[\"xx\"] key 值不能乱写 fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、获取元素 var a map[int]string=make(map[int]string) fmt.Println(a[0]) //取出value值的空值 \"\" 统一的方案来判断value值是否存在 //a[0] 可以返回两个值，一个是value值（可能为空），另一个是true或false var a map[int]int=make(map[int]int) a[0]=0 v,ok:=a[0] fmt.Println(v) fmt.Println(ok) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、map 删除元素 var a map[int]int=make(map[int]int) a[1]=11 a[2]=22 fmt.Println(a) //根据key删（内置函数） delete(a,1) fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、map长度 var a map[int]int=make(map[int]int) fmt.Println(len(a)) a[1]=11 a[2]=22 fmt.Println(len(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、map是引用类型 var a map[int]int=make(map[int]int) a[1]=11 test4(a) fmt.Println(a) func test4(a map[int]int) { a[1]=999 fmt.Println(a) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、 map的相等性 var a map[string]string=make(map[string]string) a[\"name\"]=\"zhang\" var b map[string]string=make(map[string]string) b[\"name\"]=\"zhang\" // 不能判断， map只能跟nil比较 if a==nil { } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、循环map // 需要借助内置range循环 var a map[string]string=map[string]string{\"name\":\"zhang\",\"age\":\"19\",\"sex\":\"男\"} for k,v:=range a{ fmt.Println(k) fmt.Println(v) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"9、map是无序的 // 如何让map变为有序 [toc] ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:9","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"if else 基本使用 package main import \"fmt\" // if else if else func main() { a := 10 if a == 10 { fmt.Println(\"13\") } else if a \u003e 10 { fmt.Println(\"a大于10\") } else { fmt.Println(\"a小于10\") } } 不能换行（go语言每一行结尾，需要加一个; ,每当换行，会自动加;） 在条件里可以进行初始化操作,(作用域范围的区别) package main import \"fmt\" func main() { a := 10 if a \u003c 10 { fmt.Println(\"xxx\") } else { fmt.Println(\"yyyy\") } } // 2 package main import \"fmt\" func main() { if a:=10 ;a \u003c 10 { fmt.Println(\"xxx\") } else { fmt.Println(\"yyyy\") } } ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:1","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"for 循环 基本语法 package main import \"fmt\" func main() { // 基本语法 // for 初始化; 条件判断; 自增/自减 { 循环体内容} // 打印1=9 for i:=1; i\u003c10; i++{ fmt.Println(i) } } 省略第一部分 package main import \"fmt\" func main() { // 2 省略第一部分（初始化）,作用域范围不一样 i:=0 for ;i\u003c10 ; i++ { fmt.Println(i) } } 省略第三部分 package main import \"fmt\" func main() { //3 省略第三部分 for i:=0;i\u003c10 ; { i++ fmt.Println(i) } } 省略第一部分和第三部分 package main import \"fmt\" func main() { //4 省略第一和第三部分 i := 0 for ; i \u003c 10; { i++ fmt.Println(i) } } package main import \"fmt\" func main() { //for 条件 {} i := 0 for i \u003c 10 { i++ fmt.Println(i) } // 死循环 for true{ fmt.Println(1) } // 死循环 for { fmt.Println(1) } } break continue(和python 中一样) ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:2","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"switch 语句 //switch package main func main() { // 1 switch 基本使用 //a:=10 //switch a { //case 1: // fmt.Println(\"1\") //case 2: // fmt.Println(2) //case 9: // fmt.Println(9) //case 10: // fmt.Println(\"10\") //} //2 default //a:=15 //switch a { //case 1: // fmt.Println(\"1\") //case 2: // fmt.Println(2) //case 9: // fmt.Println(9) //case 10: // fmt.Println(\"10\") //default: // fmt.Println(\"不知道\") //} //3 多条件 //a:=3 //switch a { //case 1,2,3: // fmt.Println(\"1\") //case 4,5,6: // fmt.Println(2) //case 7,9: // fmt.Println(9) //case 10,16: // fmt.Println(\"10\") //default: // fmt.Println(\"不知道\") //} //4 无表达式 //a:=3 //switch { //case a==1 || a==3: // fmt.Println(\"1\") //case a==4||a==5: // fmt.Println(2) //default: // fmt.Println(\"不知道\") //} //5 fallthrough,无条件执行下一个case //a:=1 //switch { //case a==1 || a==3: // fmt.Println(\"1\") // //fallthrough //fallthrough 会无条件执行下一个case //case a==4||a==5: // fmt.Println(2) // fallthrough //default: // fmt.Println(\"不知道\") //} } [toc] ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:3","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"包 //1 在同一个包下（文件夹下），包名必须一致 //2 以后，包名就是文件夹的名字 //3 同一个包下，同名函数只能有一个（init除外） //4 一个包（当成一个文件），同一包下的函数，直接调用即可 //5 导包的位置，从src路径开始 //6 包只要在src路径下就可以导入 //7 大写表示导出，在外部包可以使用，小写只能再包内部适应 //8 使用第三方包：go get github.com/astaxie/beego （放到gopath的src路径下） package main import \"github.com/astaxie/beego\" func main() { beego.Run() } ","date":"2020-01-06","objectID":"/posts/go-06-%E5%8C%85/:0:1","tags":["golang"],"title":"Go 包","uri":"/posts/go-06-%E5%8C%85/"},{"categories":["GO"],"content":"mode模式 //1 包导入 import . \"github.com/astaxie/beego\" 类似于python中form xx import * //2 包导入 import _ \"github.com/go-sql-driver/mysql\" 触发init的执行，但是不试用包内的函数 //3 包导入 import f \"fmt\" 重命名，以后直接用f //4 对比python中__init__.py //在代码中导入模块 import xx 实质上触发__init__.py 的执行(在__init__.py中也可以执行其他代码，对应到go中就是init函数) 一般情况下，在__init__.py写from xx import 会使用到的函数，导过来 以后再用 xx.函数() //5 go mod没有之前，可以设置多个gopath，开发某个项目，切到不同的gopath，类似于虚拟环境 //6 go env -GO111MODULE=\"off\" 表示go mod模式是关闭的，用gopath -一旦开启了go mod模式，代码不需要放在src路径下（任意位置都可以） -在项目路径下要有 go.mod 文件（文件里记录了，go版本，项目依赖的包，包的版本） -写代码，建自己的包即可 -一般情况下，项目有一个main.go 内部是main包，main函数，整个程序的入口 [toc] ","date":"2020-01-06","objectID":"/posts/go-06-%E5%8C%85/:0:2","tags":["golang"],"title":"Go 包","uri":"/posts/go-06-%E5%8C%85/"},{"categories":["GO"],"content":"变量的定义方式 package main import \"fmt\" func main() { // 方式一 // var 变量名 变量类型=变量值 // 注意 变量定义后 必须使用, 不适使用报错 // 导入的包必须使用 不适用报错 var age int =18 // 定义并赋值 var name string // 定义 name = \"我是你爸爸\" //赋值 fmt.Println(name, age) // 方式二 类型推导(不需要加类型) var salary = 1000 fmt.Println(salary) fmt.Printf(\"salary的类型是:%T, 值是%d\\n\",salary,salary) // Printf 表示格式化输出 // 方式三 简略声明 male := 100 fmt.Println(male) // 同时定义多个变量(3种方式都可以) var a, b,c = 1,\"2\",\"3\" fmt.Println(a,b,c) } 注意 变量不能重复定义 变量要先定义后使用 简略声明方式定义特殊, 冒号前至少有一个未定义变量则不报错. 变量类型是固定的. 变量定义了, 必须使用,否则报错 包导入则必须使用, 不使用就报错 ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:1:0","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"常量 // 常量 : 恒定不变得量 , 建议全部大写 // 程序在运行过程中, 不会改变值, 例如: 数据库链接地址, 端口号等 package main // 批量声明 const ( notFound = 404 statusOk = 200 ) // 当 出现 n2 n3 这样的没有被赋值的声明 则默认为 n1 const ( n1 =100 n2 n3 ) func main() { //1 const关键字 常量名 常量类型 =值 const A int =99 //2 常量可以定义了不使用 const B int =99 //3 类型可以省略 const C =99 fmt.Printf(\"%T\",b) //4 同时定义多个常量 const ( AGE=19 NAME=\"zyz\" sex=\"男\" ) fmt.Println(AGE) //5 改变常量(不允许) // AGE=199 //fmt.Println(AGE) } ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:0","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"Iota iota 是go语言中的常量计数器, 只能在常量的表达式中使用. iota 在const 关键字出现时 将被重置为 0 , const 中每新增一行常量声明将使iota 计数加一次, 类似 枚举. 在定义枚举时候很有用. 举例说明: const ( n1 = iota n2 n3 n4 n5 ) ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:1","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"常见的几个iota 例子 使用_ 跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 多个常量声明在一行 const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) 定义数量级 （这里的\u003c\u003c表示左移操作，1\u003c\u003c10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2\u003c\u003c2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。 const ( _ = iota KB = 1 \u003c\u003c (10 * iota) MB = 1 \u003c\u003c (10 * iota) GB = 1 \u003c\u003c (10 * iota) TB = 1 \u003c\u003c (10 * iota) PB = 1 \u003c\u003c (10 * iota) ) [toc] ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:2","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"go语言介绍 # 诞生于09年, 是谷歌公司推出的. -python 1989年 -java 1990年 # 缺点: 生态不是特别好 Go 语言特性 # 跨平台编译型语言 # 语法接近C # 有垃圾回收机制(gc) # 支持面向对象和面向过程式的编程模式.(没有class 但是支持) Go 语言发展 # 目前最新的是1.14.2 版本. go语言向下兼容. 不用考虑版本问题 Go 语言应用 # 国内的很多大型的互联网公司, 腾讯, 百度, 京东, 知乎等 # 国外 谷歌. facebook Go 应用领域 # 服务开发 # 并发 # 分布式 # 微服务方向 Go 语言项目 # Docker # K8s (kubernetes) # 区块链 Go 语言发展前景 # 新兴语言 最牛逼! 不解释 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"环境搭建 # go 开发包安装 # go ide 安装(gplang, vscode, sublime text) # 安装完成后 go version 查看版本 # go env 查看go环境变量 GO111MODULE=\"\" # 当此配置 为空或者off 则代表没有开启 go mode 模式, 用的是gopath 模式 GOROOT=\"/usr/local/Cellar/go/1.14.2_1/libexec\" # go 开发安装路径 GOPATH=\"/Users/zhang/go\" # 代码的存放路径 # go mode 模式: 代码可以存放在任意路径 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"Hello World // 单行注释 /* 多行注释 */ package main // 表示声明包, 每一个go代码第一行都必须写这个 import \"fmt\" // 导入fmt包 类比 python中 import os.path func main() { // 声明 main 函数 函数体 放在 {}之中. fmt.Println(\"Hello, World\") // Println 是输入至控制台, 类比python中的print } // 程序的执行入口是 main包下的 main函数 // 编译型语言都有入口, 对比 python中 一个py文件就是一个 main 函数. // 一个项目只能有一个 main函数 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"常用命令 build go build 文件 # 生成本机环境的可执行文件 fmt go fmt 文件 # 代码格式化 install # 编译并安装包和依赖 run go run 文件 # 编译并运行go程序 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"规范 1 变量：go语言中变量区分大小写，建议用驼峰 var Name=\"lqz\" var name=\"lqz\" fmt.Println(Name) fmt.Println(name) 2 文件名：建议用下划线 3 大写字母开头，表示导出字段（外部包可以使用） 4 先导入第三方包，内置包，自己写的包 5 不像python中缩进代表同一段代码块 var a =10 fmt.Println(a) fmt.Println(\"xxx\") [toc] ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"函数 go为编译型语言, 需要先编译后执行, 所以 go中函数不会像python 一样需要先定义后执行, go 中函数 可以写在任意位置 语法 // 语法 func(关键字) 函数名() {} 无参 无返回值函数 package main import \"fmt\" func main() { t1() } // 无参数, 无返回值 func t1() { fmt.Println(\"231\") } 有参数 无返回值 package main import \"fmt\" func main() { t1(132) } // 有参数 无返回值 // go中函数没有关键字参数, 所有的都是位置参数, 也没有默认参数 func t1( i int) { fmt.Println(i) } 多个参数 无返回值 package main import \"fmt\" func main() { t1(132,456) } // go中函数没有关键字参数, 所有的都是位置参数, 也没有默认参数 func t1( i int, m int) { fmt.Println(i) } // 如果参数为同一个类型, 可以简写 func t1( i,m int) { fmt.Println(i) } 多个参数有一个返回值(需要指明返回值的类型) package main import \"fmt\" func main() { i := t1(132, 456) fmt.Println(i) } // 多个参数 有一个返回值 func t1(i,m int) int{ return i+m } 多个参数 多个返回值 package main import \"fmt\" func main() { i,m := t1(132, 456) fmt.Println(i,m) } // 多个参数 有一个返回值 func t1(i,m int) (int,int){ c := i+m d := i*m return c,d } 补充 //func test(a,b int)(){} //func test(a,b int)(int){} //func test(a,b int)(int,string,int){} //func test(a,b int)int{} 可变长参数 // 可变长参数 package main import \"fmt\" func main() { i, m := t1(132, 456, 321) fmt.Println(i, m) } func t1(m int, i ...int) (int, int) { c := m + i[0] d := i[0] * i[1] return c, d } 函数是一等公民**(头等函数), 在go 中函数也是一个类型 返回值时函数类型 package main import \"fmt\" func main() { i := t1() i() } func t1() func() { var a func()=func (){ fmt.Println(\"我是内层函数\") } return a } //func t1() func() { // return func (){ // fmt.Println(\"我是内层函数\") // } //} 闭包函数(定义在函数内部, 对外部作用域的引用) 闭包函数的本质: 多了一种传参方式 func t1(b int) func() { a:= func() { fmt.Println(b) } return a } // 在go 语言中没有装饰器语法糖, 需要自己手动实现装饰器 闭包函数高级 func t1(b int) func(x,y int) { var a func(x,y int) a= func(x,y int) { fmt.Println(b+x+y) } return a } // 禁止套娃! 匿名空接口 // 可边长参数补充 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } // a ... interface{} 为 匿名空接口 补充， 命名返回值 func test(x,y int)(a int) { a=x+y return } // 在指定返回值数据类型时， 可以指定要返回的内部名称变量。 // 上面例子中 就是将返回值命名给a 给类型重命名 package main import \"fmt\" func main() { var a MyFunc a(1,2) } //func(x,y int) 类型命名为MyFunc type MyFunc func(x,y int) func test() MyFunc { return func(x,y int) { fmt.Println(x+y) fmt.Println(\"xxx\") } } ","date":"2020-01-04","objectID":"/posts/go-04-%E5%87%BD%E6%95%B0/:1:0","tags":["函数"],"title":"函数","uri":"/posts/go-04-%E5%87%BD%E6%95%B0/"},{"categories":["GO"],"content":"装饰器的实现 package main import ( \"fmt\" \"time\" ) func main() { test := director(test) a:=test() fmt.Println(a) } func director(fun func() int) func() int{ a := func() int { start_time := time.Now().Unix() fmt.Println(start_time) time.Sleep(time.Second) res := fun() end_time := time.Now().Unix() fmt.Println(end_time) return res } return a } func test() int{ fmt.Println(\"我是主函数\") return 0 } // 套娃套到头疼! [toc] ","date":"2020-01-04","objectID":"/posts/go-04-%E5%87%BD%E6%95%B0/:1:1","tags":["函数"],"title":"函数","uri":"/posts/go-04-%E5%87%BD%E6%95%B0/"},{"categories":["GO"],"content":"基本数据类型 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 有符号整型：（长度不同，表示的数字范围不一样） -int:在32位机器上是int32，在64位机器上是int64 -int8 ：8个bit位，一个字节，正负 2的7次方-1的范围 -int16: 正负 2的15次方-1的范围 -int32: -int64: 无符号整数： -uint8 ：2的8次方-1 -uint16： -uint32 -uint64 复数： -complex类型：（了解，不知道更好）实部和虚部 其他： -byte：uint8的别名 -rune:int32的别名 特殊整型 int : 在32位机器上是int32，在64位机器上是int64 uint : 在32位机器上是uint32，在64位机器上是uint64 uintptr: 无符号整型, 用于存放一个指针 注意 在使用int 和uint类型时, 不能假定它是32位或者64位整型, 而是要考虑int 和uint 在不同平台的差异 注意事项 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。 进制转换 package main import \"fmt\" func main(){ // 十进制 var a int = 10 fmt.Printf(\"%d \\n\", a) // 10 fmt.Printf(\"%b \\n\", a) // 1010 占位符%b表示二进制 // 八进制 以0开头 var b int = 077 fmt.Printf(\"%o \\n\", b) // 77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\"%x \\n\", c) // ff fmt.Printf(\"%X \\n\", c) // FF } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。 打印浮点数时，可以使用fmt包配合动词%f，代码如下： package main import ( \"fmt\" \"math\" ) func main() { fmt.Printf(\"%f\\n\", math.Pi) fmt.Printf(\"%.2f\\n\", math.Pi) } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:2","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"复数 complex64和complex128 var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:3","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:4","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\")中的内容，可以在Go语言的源码中直接添加非ASCII码字符， 用双引号包裹的内容,反引号 `` 反引号可以换行 注意 双引号包含的是字符串 单引号包含的是字符 例如： var a string= \"我是你爸爸\" ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:5","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。 转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 举个例子，我们要打印一个Windows平台下的一个文件路径： package main import ( \"fmt\" ) func main() { fmt.Println(\"str := \\\"c:\\\\Code\\\\lesson1\\\\go.exe\\\"\") } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:6","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 4 补充类型零值 // 补充：类型的默认值 var a int var b float32 var c string var d bool fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:7","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"数据类型的转换 //类型转换(强类型:不通类型之间不能做运算) //类型转换 //var a int =19 //var b float32=18.1 //float转成int类型，小数点后直接弃用，不是四舍五入 //fmt.Println(a+int(b)) //var b float32=18.9999 //fmt.Println(int(b)) //恶心的地方(了解) //var a int =199 //64为操作系统int64 //var b int64=199 ////int和int64不是一个类型 //fmt.Println(a+int(b)) [toc] ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Docker"],"content":"1 Docker的安装 # 1 yum 包更新到最新 yum update # 2 安装所需要的软件包, yum-util 提供yum-config-manager 功能, 另外两个是 devicemapper驱动以来的 yum install -y yum-utils device-mapper-persistent-data lvm2 # 3 设置yum 源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 4 安装docker 出现输入的界面都按y yum install -y docker-ce # 5 查看docker的版本, 验证是否安装成功 docker -v ","date":"2018-12-02","objectID":"/posts/docker/:1:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"2 Docker 架构 ","date":"2018-12-02","objectID":"/posts/docker/:2:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"3 配置镜像加速器 ","date":"2018-12-02","objectID":"/posts/docker/:3:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"4 Docker 服务相关命令 启动docker服务 systemctl start docker 停止docker服务 systemctl stop docker 重启docker服务 systemctl restart docker 查看docker服务状态 systemctl status docker 开机启动docker服务 systemctl enable docker 查看docker 日志 docker logs 容器名 ","date":"2018-12-02","objectID":"/posts/docker/:4:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"5 Docker 镜像相关命令 查看本地镜像 docker images # REPOSITORY 指的是容器 # TAG 指的是版本号 # IMAGE ID 镜像的id # CREATED 创建时间 # SIZE 大小 搜索镜像 docker search redis 下载镜像 docker pull redis # 不写版本号 默认是 lastest # 我们在hub.docker.com 搜索 软件版本号 docker pull redis:5.0 # 下载 5.0 版本的 redis 删除镜像 # id 删除 docker rmi 镜像id # 版本删除 docker rmi redis:版本 # 查看所有镜像的id docker images -q # 删除所有镜像 docker rmi `docker images -q` ","date":"2018-12-02","objectID":"/posts/docker/:5:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"6 Docker 容器相关命令 创建容器 # 1 查看镜像 docker images # 创建容器 docker run -it --name=c1 mysql:5.7 /bin/bash # -i 表示 容器一直运行着 # -t 表示 给容器加个伪终端 # -d 以守护式 模式创建容器 # -name 表示 起名字 后面可以 = 或者空格 # 指定镜像 mysql:5.7 # /bin/bash 表示进入容器时的初始化指令 默认是 /bin/bash # 使用exit 退出容器 注意 : # 使用 -it 创建的容器 # 创建成功会立马进入容器 # 在退出容器后会立马停止容器 创建后台运行的容器 # 创建的容器会在后台运行. docker run -id --name=m2 mysql:5.7 查看容器 # 查看正在运行的容器 docker ps # 查看所有容器 docker ps -a 进入容器 docker exec -it 容器名 /bin/bash 启动容器 docker start 容器名 停止容器 docker stop 容器名 删除容器 docker rm 容器名 # 开启的容器是不能被删除 容器其他信息 docker inspect 容器名 查看容器日志 docker logs 容器名 容器启动错误解决 Errcode: 13 - Permission denied) # 在创建容器时 加上 -–privileged=true ","date":"2018-12-02","objectID":"/posts/docker/:6:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"7 Docker 容器的 数据卷 数据卷的简介 配置数据卷 ","date":"2018-12-02","objectID":"/posts/docker/:7:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"数据卷容器 简介 配置数据卷容器 数据卷目录 位置查找 # 查找容器的具体信息 docker inspect 容器名 查找宿主机数据目录与容器对应目录 ","date":"2018-12-02","objectID":"/posts/docker/:7:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"小结 ","date":"2018-12-02","objectID":"/posts/docker/:7:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"8 Docker的应用部署 ","date":"2018-12-02","objectID":"/posts/docker/:8:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 mysql 1 搜索 mysql docker search mysql 2 拉取mysql 镜像 docker pull mysql:5.7 3 创建容器 # 1 在/root 下创建mysql 目录 用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ -p 3306:3306 \\ --name=c_mysql \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=951228 \\ mysql:5.7 参数说明 -p 3307:3306 将容器的3306端口映射到宿主机的3307端口 -v $pwd/conf:/etc/mysql/conf.d 将主机当前目录下的conf/my.cnf 挂在到容器的 /etc.mysql/my.cnf 配置目录 -v $pwd/logs:/logs 将 主机当前目录下的logs 目录挂在到容器的/logs 日志目录 -v $pwd/data:/var/lib/mysql 讲主机当前目录下的data 目录 挂载到容器的 /var/lib/mysql 数据目录 -e MYSQL_ROOT_PASSWORD=123456 初始化root用户的密码 Mysql 5.7 默认配置文件 # For advice on how to change settings please see # http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html [mysqld] # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. # innodb_buffer_pool_size = 128M # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # These are commonly set, remove the # and set as required. # basedir = ..... # datadir = ..... # port = ..... # server_id = ..... # socket = ..... # Remove leading # to set options mainly useful for reporting servers. # The server defaults are faster for transactions and fast SELECTs. # Adjust sizes as needed, experiment to find the optimal values. # join_buffer_size = 128M # sort_buffer_size = 2M # read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES docker 中配置默认路径 /usr/my.cnf ","date":"2018-12-02","objectID":"/posts/docker/:8:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Tomcat # 注意 需要进入 tomcat 容器内 把 webapps.disp 改名为 webapps , 不然访问不到主页 1 搜索tomcat镜像 docker search tomcat 2 拉去tomcat 镜像 docker pull tomcat 3 创建容器, 设置端口映射, 目录映射 mkdir ~/tomcat cd ~/tomcat docker run -id --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数解释同上 ","date":"2018-12-02","objectID":"/posts/docker/:8:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Nginx # 注意, 首先要创建nginx.conf 文件 用于管理 容器的nginx # 在 宿主nginx 文件夹下创建/conf/nginx.conf 用于映射 容器nginx配置文件 Nginx 原始配置文件 搜索nginx镜像 docker search nginx 拉去nginx 镜像 docker pull nginx 创建nginx 容器 mkdir ~/nginx cd mkdir ~/nginx # 创建 conf 文件夹 mkdir conf # 在conf 文件夹下创建 nginx.conf 文件, 粘贴下面内容 vim nginx.conf 准备好 nginx 配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 创建nginx 容器 docker run -id --name=c_nginx \\ -p 80:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明 # -p 80:80 宿主机80 端口 映射 容器的80端口 # -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf 使用宿主机 nginx.conf 配置文件映射到 容器的配置文件 # -v $PWD/logs:/var/log/nginx 挂在log 目录文件 # -v $PWD/html:/usr/share/nginx/html ","date":"2018-12-02","objectID":"/posts/docker/:8:3","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Redis 1 搜索 Redis docker search redis 2 拉去镜像 docker pull redis:5.0 3 创建容器 映射端口 docker run -id --name=c_redis -p 6379:6379 redis:5.0 ","date":"2018-12-02","objectID":"/posts/docker/:8:4","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"9 Docker 镜像原理 ","date":"2018-12-02","objectID":"/posts/docker/:9:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"10 Docker 镜像制作 ","date":"2018-12-02","objectID":"/posts/docker/:10:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"第一种方式 容器转镜像 ","date":"2018-12-02","objectID":"/posts/docker/:10:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"第二种方式 dockerfile 关键字 Dockerfile 案例1 构建镜像 docker built -f centos_dockerfile -t itheima_centos:1.0 # -f 找到 dockerfile 文件 # -t 指定 新镜像的名称及版本 Dockerfile 案例2 ","date":"2018-12-02","objectID":"/posts/docker/:10:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"11 Docker的服务编排 ","date":"2018-12-02","objectID":"/posts/docker/:11:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"介绍 ","date":"2018-12-02","objectID":"/posts/docker/:11:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker Compose 1 安装 Docker Compose # Compose 目前已经完全支持Linux , Macos 和Windows, 在我们安装Compose 之前, 需要先安装Docker, 下面我们以编译好的二进制包方式安装在Linux系统中. curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose=`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose # 查看版本信息 docker-compose -version 2 卸载 Docker Compose # 而今之宝方式安装的, 删除二进制文件即可 rm /usr/local/bin/docker-compose 3 使用 1 创建 docker-compose 目录 mkdir ~/docker-compose cd ~/docker-compose 2 编写 docker-compose.yml文件 version: '3' services: nginx: image: nginx ports: - 80:80 links: - app valumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - \"8080\" 3 创建./nginx/conf.d 目录 mkdir -p ./nginx/conf.d # -p 表示是在父文件夹 4 在 ./nginx/conf.d 目录下 编写 nginx 的 conf 文件. 文件必须是 conf 文件 名字无所谓 server { listen 80; access_log off; location / { proxy_pass http://app:8080; } } 5 在 ~/docker-compose 目录下 使用 docker-compose 启动容器 docker-compose up 6 测试访问 直接访问 nginx ","date":"2018-12-02","objectID":"/posts/docker/:11:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"12 Docker 私有仓库 ","date":"2018-12-02","objectID":"/posts/docker/:12:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"一 私有仓库的搭建 # 1 拉去私有仓库镜像 docker pull registry # 2 启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry # 3 打开浏览器 输入地址 http://私有仓库服务器ip:5000/v2/_catalog , 看到 {\"repositories\":[]} 表示私有仓库 搭建成功 # 4 修改daemon.json vim /etc/docker/daemon.json # 在上述稳健者添加一个key, 保存退出. 此步用于让docker 新人私有仓库地址; 注意 讲次有仓库服务器ip 修改为自己私有仓库服务器的真是ip {\"insecure-registries\":[\"私有仓库服务器ip:5000\"]} # 5 重启 docker 服务 systemctl restart docker docker start registry ","date":"2018-12-02","objectID":"/posts/docker/:12:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"二 将 镜像上传至私有仓库 # 1 标记镜像为私有仓库镜像 docker tag centos:7 私有仓库服务器ip\"5000/contos:7 # 2 上传标记镜像 docker push 私有仓库服务器ip:5000/centos:7 ","date":"2018-12-02","objectID":"/posts/docker/:12:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"三 私有仓库的镜像拉到本地 docker pull 仓库ip:5000/centos:7 # 拉取镜像到本地 ","date":"2018-12-02","objectID":"/posts/docker/:12:3","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"13 Docker 与 虚拟机的对比 ","date":"2018-12-02","objectID":"/posts/docker/:13:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 容器虚拟化 与 创痛虚拟机比较 [toc] ","date":"2018-12-02","objectID":"/posts/docker/:13:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker容器间通信 Docker会为每个创建的容器自动分配一个虚拟IP，这个虚拟IP无法从容器外侧进行访问，只是Docker环境内部容器间彼此通信的标识，容器间的网络是互通互联的。 但是通过这种虚拟IP方式，进行容器间的通信，有一些局限性。因为在Docker中创建一个容器非常容易，比如说新创建的MySQL容器可能会替代之前创建的MySQL容器，而此时Tomcat服务器中配置的是之前的MySQL容器的Ip地址，因此随着新容器的创建，之前Tomcat配置的Ip地址需要不断的变更，并重启服务。当有很多Tomcat服务器同时连接MySQL数据库时，这个修改工作就是一个很大的工作量。 那这个问题如何解决呢？ 容器创建时进行命名，配置连接时不在配置IP地址，而是配置容器的名字，这样以后再创建容器时，只要名字不变，就可以自动连接到新创建的容器。 举例说明： （1）创建web服务 # 创建容器 运行Tomcat服务 --name 为容器命名 docker run -d --name webserver tomcat （2）创建数据库服务（模拟） docker run -d --name database -it centos /bin/bash 注：命令添加中的-d -it 和**/bin/bash** 是因为centos容器创建完成后，默认就进入退出状态。如果想让其保持运行状态，后台必须保持一个进程在运行，/bin/bash表示启动容器后启动bash。 （3）查看正在运行的容器 （4）查看连个容器的虚拟IP地址 通过docker inspect [OPTIONS] NAME|ID 命令查看 docker inspect : 获取容器/镜像的元数据。 首先查看webserver容器的Ip地址 docker inspect webserver 查看database容器的IP地址 docker inspect database （5）进入webserver容器内容，测试网络 docker exec -it webserver /bin/bash 但是直接ping database却是不通的，因为我们并没有进行相应的网络设置，docker并不知道database和哪个IP是对应的，因此我们可以在创建webserver容器时指定webserver到database的单向通信。 ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:0","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"1、容器间单向通信 移除上面创建的web容器，并重新创建 # 强制移除webserver容器 docker rm -f webserver # 重新创建webserver容器 --link 要链接的容器名称 （--link 可以使新生成的容器链接到已在运行的容器） docker run -d --name webserver --link database tomcat Tomcat中的数据库连接配置文件中的url中的IP地址即可换成database ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:1","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"2、容器间双向通信 图中的网桥充当了Docker容器和外界宿主机之间的通信源，使得容器内部也可以访问互联网 例如在webserver内部可以访问百度 网桥也可以用于容器内部，实现容器间的双向通信。不仅如此网桥还有另一个重要作用，就是对容器从网络层面进行分组 （1）通过【docker network ls 】列出当前网络状况明细 上图中列出的bridge即为容器和外界通信的桥梁，如果我们想实现容器内部的双向通信也可以创建一个网桥，具体操作过程如下： （2）创建网桥 # 创建网桥 docker network create -d bridge my-bridge # 执行命令进行查看 docker network ls （3）将需要通信的容器添加到网桥中 docker network connect my-bridge webserver docker network connect my-bridge database （4）进入容器进行验证是否能够互相通信 网桥的原理：创建一个网桥，就相当于在宿主机上安装了一个虚拟网卡，这个虚拟网卡也承担了网关的作用。虚拟网卡和物理网卡之间需要做地址转换 ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:2","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"安装 docker-compose ","date":"2018-09-03","objectID":"/posts/docker-compose/:0:1","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"切换到root 用户 下载 curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose 修改权限 chmod +x /usr/local/bin/docker-compose 检查是否成功 docker-compose -version 此外，因为 docker-compose 使用 Python 编写，所以可以使用 pip 直接安装： $ pip install -U docker-compose 1 ","date":"2018-09-03","objectID":"/posts/docker-compose/:0:2","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"第一个 Compose file version: '3' services: spider: build: context: . dockerfile: Dockerfile volumes: - $PWD:/code - /data1/datascience/scrapy-data:/data command: scrapy crawl comment 12345678910 说明： version 指定了 compose file 的版本，最新的版本为 3.4 services 下定义服务，这里定义了一个爬虫服务 spider build 指定构建镜像上下文、Dockerfile 文件和 ARGS 等。 volumes 用于创建卷并挂载，这里挂载了源码目录和数据存储目录 command 指定服务启动时执行的命令，参考 Dockerfile COMMAND。 ","date":"2018-09-03","objectID":"/posts/docker-compose/:1:0","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"Compose file 指令 先来看一份 docker-compose.yml 文件： version: '2' services: web: image: dockercloud/hello-world ports: - 8080 networks: - front-tier - back-tier redis: image: redis links: - web networks: - back-tier lb: image: dockercloud/haproxy ports: - 80:80 links: - web networks: - front-tier - back-tier volumes: - /var/run/docker.sock:/var/run/docker.sock networks: front-tier: driver: bridge back-tier: driver: bridge 可以看到一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。 image: 指定容器启动的镜像，对应 Dockerfile FROM。 在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: redis image: ubuntu:14.04 image: tutum/influxdb image: example-registry.com:4000/postgresql image: a4bc65fd build: 服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。 最简单的直接利用 Dockerfile 构建，只需要指定上下文或者 Dockerfile 位置： version: '2' services: webapp: build: . 如果需要更细粒度的配置，需要使用 context, dockerfile, args, labels 等选项。 # Dockerfile ARG buildno ARG password RUN echo \"Build number: $buildno\" RUN script-requiring-password.sh \"$password\" # docker-compose file version: '2' services: webapp: image: webapp:tag build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 password: secret command: 使用 command 可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 command: [\"bundle\", \"exec\", \"thin\", \"-p\", \"3000\"] container_name: 指定运行时容器名称，而不使用默认格式（\u003c项目名称\u003e\u003c服务名称\u003e\u003c序号\u003e）。 container_name: my-web-container depends_on: 指明服务之间依赖，解决了容器的依赖、启动先后的问题。 version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 被依赖的服务会优先启动（显然） 若服务启动时被依赖服务没有启动，则自动被启动 dns: 指定 DNS 服务器。 dns: 8.8.8.8 dns: - 8.8.8.8 - 9.9.9.9 tmpfs: 挂载临时目录到容器内部，与 run 的参数一样效果： tmpfs: /run tmpfs: - /run - /tmp entrypoint: 在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义。 entrypoint: /code/entrypoint.sh env_file: 专门存放变量的文件。如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。如果有变量名称与 environment 指令冲突，则以后者为准。格式如下： env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 文件格式如： RACK_ENV=development 注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。 environment: 与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。 一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。 environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET expose: 这个标签与 Dockerfile 中的 EXPOSE 指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上 docker-compose.yml 的端口映射还得 ports 这样的标签。 expose: - \"3000\" - \"8000\" external_links: 在使用 Docker 过程中，我们会有许多单独使用docker run启动的容器，为了使 Compose 能够连接这些不在 docker-compose.yml 中定义的容器，我们需要一个特殊的标签，就是 external_links，它可以让 Compose 项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts: 添加主机名的标签，就是往 /etc/hosts 文件中添加一些记录、 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" labels: 向容器添加元数据，和 Dockerfile 的 LABEL 指令一个意思。 labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" links: 上面的 depends_on 标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与 Docker client 的 –link 一样效果，会连接到其它服务中的容器。。 web: links: - db - db:database - redis 使用的别名将会自动在服务容器中的 /etc/hosts 里创建。 相应的环境变量也将被创建。 logging: 用于配置日志服务。默认的 driver 是 json-file。 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" pid: 将 PID 模式设置为主机 PID 模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。 pid: \"host\" ports: 映射端口的标签。使用 HOST:CONTAINER 格式或者只是指定容器的端口，宿主机会随机映射端口。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 12345 注意：当使用 HOST:CONTAINER","date":"2018-09-03","objectID":"/posts/docker-compose/:2:0","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["爬虫"],"content":"爬虫 Scrapy高级 使用 ","date":"2017-07-09","objectID":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/:0:0","tags":["爬虫","scrapy"],"title":"动作链","uri":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/"},{"categories":["爬虫"],"content":"动作链 from selenium import webdriver from selenium.webdriver import ActionChains import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get('https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable') bro.implicitly_wait(10) #切换frame（很少） bro.switch_to.frame('iframeResult') div=bro.find_element_by_xpath('//*[@id=\"draggable\"]') # 使用动作链 #得到一个动作练对象 action=ActionChains(bro) # 使用动作链 #点击并且夯住 action.click_and_hold(div) # 直接把上面的div移动到某个元素上 # action.move_to_element(元素控件) # 移动x坐标，y坐标 # 三种移动方式 # action.move_by_offset() # 通过坐标 # action.move_to_element() # 到另一个标签 # action.move_to_element_with_offset() # 到另一个标签，再偏移一部分 for i in range(5): action.move_by_offset(10,10) # 直接把上面的div移动到某个元素上的某个位置 # action.move_to_element_with_offset() # 调用它，会动起来 action.perform() time.sleep(1) #释放动作链 action.release() time.sleep(5) bro.close() ","date":"2017-07-09","objectID":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/:1:0","tags":["爬虫","scrapy"],"title":"动作链","uri":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/"},{"categories":["爬虫"],"content":"爬虫 Scrapy高级 使用 ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:0:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"scrapy 请求传参 # 1 放 ：yield Request(url,callback=self.parser_detail,meta={'item':item}) # 2 取：response.meta.get('item') # 3 指定解析函数 callback=self.解析函数. class CnblogSpider(scrapy.Spider): name = 'cnblog' # allowed_domains = ['https://www.cnblogs.com/'] start_urls = ['https://www.cnblogs.com/sitehome/p/1'] num = 0 # post_list \u003e div:nth-child(19) \u003e div def parse(self, response): article_list = response.css(\".post_item_body\") for article in article_list: item = CrawlCnblogsItem() title = article.css(\".titlelnk::text\").extract_first() url = article.css(\".titlelnk::attr(href)\").extract_first() desc = article.css(\"p::text\").extract()[-1] author = article.css(\".post_item_foot\u003ea::text\").extract_first() comment = article.xpath(\".//*[contains(@class,'post_item_foot')]/span[1]/a/text()\").extract_first() view = article.xpath(\".//*[contains(@class,'post_item_foot')]/span[2]/a/text()\").extract_first() item[\"title\"] = title.strip() item[\"url\"] = url item[\"desc\"] = desc item[\"author\"] = author.strip() item[\"comment\"] = comment.strip() item[\"view\"] = view.strip() yield item nextpage = f'https://www.cnblogs.com{response.css(\".pager\u003e a:last-child::attr(href)\").extract_first()}' if nextpage and (self.num \u003c 10): yield Request(url=nextpage, callback=self.parse) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:1:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"提高爬取效率 - 在配置文件中进行相关的配置即可:(默认还有一套setting) #1 增加并发： 默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS = 100值为100,并发设置成了为100。 #2 提高日志级别： 在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL = ‘INFO’ # 3 禁止cookie： 如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED = False # 4禁止重试： 对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED = False # 5 减少下载超时： 如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT = 10 超时时间为10s ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:2:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"下载中间件 # 2大中间件：下载中间件，爬虫中间件 # 1 写在middlewares.py中（名字随便命名） # 2 配置生效（） SPIDER_MIDDLEWARES = { 'cnblogs_crawl.middlewares.CnblogsCrawlSpiderMiddleware': 543, } DOWNLOADER_MIDDLEWARES = { 'cnblogs_crawl.middlewares.CnblogsCrawlDownloaderMiddleware': 543, } # 2 下载中间件 -process_request：（请求去，走） # - return None: 继续处理当次请求，进入下一个中间件 # - return Response： 当次请求结束，把Response丢给引擎处理（可以自己爬，包装成Response） # - return Request ： 相当于把Request重新给了引擎，引擎再去做调度 # - 抛异常：执行process_exception -process_response：（请求回来，走） # - return a Response object ：继续处理当次Response，继续走后续的中间件 # - return a Request object：重新给引擎做调度 # - or raise IgnoreRequest ：process_exception -process_exception：（出异常，走） # - return None: continue processing this exception # - return a Response object: stops process_exception() chain ：停止异常处理链，给引擎（给爬虫） # - return a Request object: stops process_exception() chain ：停止异常处理链，给引擎（重新调度） ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:3:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"集成 selenium # 在爬虫已启动，就打开一个chrom浏览器，以后都用这一个浏览器来爬数据 # 1 在爬虫中创建bro对象 bro = webdriver.Chrome(executable_path='./chromedriver') # 2 中间件中使用： spider.bro.get(request.url) text=spider.bro.page_source response=HtmlResponse(url=request.url,status=200,body=text.encode('utf-8')) return response # 3 关闭，在爬虫中 def close(self, reason): self.bro.close() ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:4:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"fack-useragent # 请求头中的user-agent list=['',''] # pip3 install fake-useragent # https://github.com/hellysmile/fake-useragent from fake_useragent import UserAgent ua=UserAgent(verify_ssl=False) print(ua.random) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:5:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"去重源码分析 # 去重源码分析 # from scrapy.core.scheduler import Scheduler # Scheduler下：def enqueue_request(self, request)方法判断是否去重 if not request.dont_filter and self.df.request_seen(request): Requests对象，RFPDupeFilter对象 # 如果要自己写一个去重类 -写一个类，继承BaseDupeFilter类 -重写def request_seen(self, request): -在setting中配置：DUPEFILTER_CLASS = '项目名.dup.UrlFilter' # scrapy起始爬取的地址 def start_requests(self): for url in self.start_urls: yield Request(url) 增量爬取 -增量爬取（100链接，150个链接） -已经爬过的，放到某个位置（mysql，redis中：集合） -如果用默认的，爬过的地址，放在内存中，只要项目一重启，就没了，它也不知道我爬过那个了，所以要自己重写去重方案 -你写的去重方案，占得内存空间更小 -bitmap方案 -BloomFilter布隆过滤器 from scrapy.http import Request from scrapy.utils.request import request_fingerprint # 这种网址是一个 requests1=Request(url='https://www.baidu.com?name=lqz\u0026age=19') requests2=Request(url='https://www.baidu.com?age=18\u0026name=lqz') ret1=request_fingerprint(requests1) ret2=request_fingerprint(requests2) print(ret1) print(ret2) # bitmap去重 一个小格表示一个连接地址 32个连接，一个比特位来存一个地址 # https://www.baidu.com?age=18\u0026name=lqz ---》44 # https://www.baidu.com?age=19\u0026name=lqz ---》89 # c2c73dfccf73bf175b903c82b06a31bc7831b545假设它占4个bytes，4*8=32个比特位 # 存一个地址，占32个比特位 # 10个地址，占320个比特位 #计算机计量单位 # 比特位：只能存0和1 # 8个比特位是一个bytes # 1024bytes=1kb # 1024kb=1m # 1024m=1g # 布隆过滤器：原理和python中如何使用 def request_seen(self, request): # 把request对象传入request_fingerprint得到一个值：aefasdfeasd # 把request对象，唯一生成一个字符串 fp = self.request_fingerprint(request) #判断fp，是否在集合中，在集合中，表示已经爬过，return True，他就不会再爬了 if fp in self.fingerprints: return True # 如果不在集合中，放到集合中 self.fingerprints.add(fp) if self.file: self.file.write(fp + os.linesep) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:6:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"分布式爬虫 # 1 安装pip3 install scrapy-redis # 1 原来的爬虫继承 from scrapy_redis.spiders import RedisSpider class CnblogsSpider(RedisSpider): #start_urls = ['http://www.cnblogs.com/'] redis_key = 'myspider:start_urls' # 2 在setting中配置 SCHEDULER = \"scrapy_redis.scheduler.Scheduler\" DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\" ITEM_PIPELINES = { 'scrapy_redis.pipelines.RedisPipeline': 300 } # 3 多台机器上启动scrapy # 4 向reids中发送起始url lpush myspider:start_urls https://www.cnblogs.com ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:7:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"爬虫 Scrapy框架 使用 ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:0:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"1 Scrapy 介绍/架构 Scrapy一个开源和协作的框架，其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的，使用它可以以快速、简单、可扩展的方式从网站中提取所需的数据。但目前Scrapy的用途十分广泛，可用于如数据挖掘、监测和自动化测试等领域，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。 Scrapy 是基于twisted框架开发而来，twisted是一个流行的事件驱动的python网络框架。因此Scrapy使用了一种非阻塞（又名异步）的代码来实现并发。整体架构大致如下 Components： 引擎(EGINE) 引擎负责控制系统所有组件之间的数据流，并在某些动作发生时触发事件。有关详细信息，请参见上面的数据流部分。 调度器(SCHEDULER) 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL的优先级队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 下载器(DOWLOADER) 用于下载网页内容, 并将网页内容返回给EGINE，下载器是建立在twisted这个高效的异步模型上的 爬虫(SPIDERS) SPIDERS是开发人员自定义的类，用来解析responses，并且提取items，或者发送新的请求 项目管道(ITEM PIPLINES) 在items被提取后负责处理它们，主要包括清理、验证、持久化（比如存到数据库）等操作 下载器中间件(Downloader Middlewares) 位于Scrapy引擎和下载器之间，主要用来处理从EGINE传到DOWLOADER的请求request，已经从DOWNLOADER传到EGINE的响应response，你可用该中间件做以下几件事 process a request just before it is sent to the Downloader (i.e. right before Scrapy sends the request to the website); change received response before passing it to a spider; send a new Request instead of passing received response to a spider; pass response to a spider without fetching a web page; silently drop some requests. 爬虫中间件(Spider Middlewares) 位于EGINE和SPIDERS之间，主要工作是处理SPIDERS的输入（即responses）和输出（即requests） 官网链接：https://docs.scrapy.org/en/latest/topics/architecture.html ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:1:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"2 Scripy框架的安装和启动 安装 #Windows平台 1、pip3 install wheel #安装后，便支持通过wheel文件安装软件，wheel文件官网：https://www.lfd.uci.edu/~gohlke/pythonlibs 3、pip3 install lxml 4、pip3 install pyopenssl 5、下载并安装pywin32：https://sourceforge.net/projects/pywin32/files/pywin32/ 6、下载twisted的wheel文件：http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted 7、执行pip3 install 下载目录\\Twisted-17.9.0-cp36-cp36m-win_amd64.whl 8、pip3 install scrapy #Linux和 mac平台 1、pip3 install scrapy 创建 scrapy startproject #创建项目 scrapy genspider #创建爬虫程序 启动 scrapy crawl 爬虫名字 # 启动爬虫 scrapy crawl 爬虫名字 --nolog # 不打印日志启动 从文件启动 from scrapy.cmdline import execute # execute(['scrapy','crawl','chouti','--nolog']) execute(['scrapy','crawl','chouti']) ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:2:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"3 配置文件和目录介绍 目录介绍 -crawl_chouti # 项目名 -crawl_chouti # 跟项目一个名，文件夹 -spiders # spiders：放着爬虫 genspider生成的爬虫，都放在这下面 -__init__.py -chouti.py # 抽屉爬虫 -cnblogs.py # cnblogs 爬虫 -items.py # 对比django中的models.py文件 ,写一个个的模型类 -middlewares.py # 中间件（爬虫中间件，下载中间件），中间件写在这 -pipelines.py # 写持久化的地方（持久化到文件，mysql，redis，mongodb） -settings.py # 配置文件 -scrapy.cfg # 不用关注，上线相关的 配置文件 # 配置文件 ROBOTSTXT_OBEY = False # 是否遵循爬虫协议，强行运行 USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36' # 请求头中的ua LOG_LEVEL='ERROR' # 这样配置，程序错误信息才会打印， #启动爬虫直接 scrapy crawl 爬虫名 就没有日志输出 # scrapy crawl 爬虫名 --nolog 爬虫文件 class ChoutiSpider(scrapy.Spider): name = 'chouti' # 爬虫名字 allowed_domains = ['https://dig.chouti.com/'] # 允许爬取的域 start_urls = ['https://dig.chouti.com/'] # 起始爬取的位置，爬虫一启动，会先向它发请求 def parse(self, response): # 解析，请求回来，自动执行parser，在这个方法中做解析 print('---------------------------',response) 数据解析 使用bs4 # 1 解析，可以使用bs4解析 from bs4 import BeautifulSoup soup=BeautifulSoup(response.text,'lxml') soup.find_all() 使用内置解析器 response.css response.xpath # 解析 # 所有用css或者xpath选择出来的都放在列表中 # 取第一个:extract_first() # 取出所有extract() # css选择器取文本和属性： response.css(\".link-title::text\") response.css(\".link-title::attr(href)\") # xpath选择器取文本和属性 response.xpath('.//a[contains(@class,\"link-title\")/text()]') response.xpath('//a[contains(@class,\"link-title\")/@href]') ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:3:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"4 数据持久化 # 方式一 -1 parser解析函数，return 列表，列表套字典 -2 scrapy crawl chouti -o aa.json (支持：('json', 'jsonlines', 'jl', 'csv', 'xml', 'marshal', 'pickle') # 方式二 pipline的方式（管道） -1 在items.py中创建模型类 -2 在爬虫中chouti.py，引入，把解析的数据放到item对象中（要用中括号） -3 yield item对象 -4 配置文件配置管道 ITEM_PIPELINES = { # 数字表示优先级（数字越小，优先级越大） 'crawl_chouti.pipelines.CrawlChoutiPipeline': 300, 'crawl_chouti.pipelines.CrawlChoutiRedisPipeline': 301， } -5 pipline.py中写持久化的类 # 在保存数据之前执行的函数 -spider_open # 在执行数据持久化之后执行的函数 -spider_close -process_item（在这写保存到哪） [toc] ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:4:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"爬虫 selenium 模块使用 ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:0:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"介绍 selenium最初是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题 可以操作浏览器(火狐，谷歌（建议你用谷歌），ie)，模拟人的行为（人可以干啥，代码控制就可以干啥） ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:1:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"selenium的简单使用 # pip3 install selenium # 1 基本使用 from selenium import webdriver # import time # # 得到 一个谷歌浏览器对象 # # 代码不能直接操作浏览器，需要有一个浏览器驱动（配套的） # # 下载谷歌浏览器驱动：http://npm.taobao.org/mirrors/chromedriver/ # # 谷歌浏览器驱动要跟谷歌版本对应 # # http://npm.taobao.org/mirrors/chromedriver/80.0.3987.106/ ：80.0.3987.149（正式版本） # # 指定一下驱动的位置（相对路径/绝对路径） # bro=webdriver.Chrome(executable_path='./chromedriver') # # bro.get(\"https://www.baidu.com\") # # # 页面内容 # # ret.text 相当于它，可以使用bs4解析数据，或者用selenium自带的解析器解析 # print(bro.page_source) # time.sleep(5) # bro.close() ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:2:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"selenium的高级用法 常用方法 bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") 解析器 # 1、find_element_by_id # id找 # 2、find_element_by_link_text # a标签上的文字找 # 3、find_element_by_partial_link_text # a标签上的文字模糊 # 4、find_element_by_tag_name # 根据标签名字找 # 5、find_element_by_class_name # 根据类名字找 # 6、find_element_by_name # name='xx' 根据name属性找 # 7、find_element_by_css_selector # css选择器找 # 8、find_element_by_xpath #xpath选择器找 在输入框中输入美女（自带的解析器，查找输入框空间） # //*[@id=\"kw\"] # input_search=bro.find_element_by_xpath('//*[@id=\"kw\"]') input_search=bro.find_element_by_css_selector('#kw') 写文字 input_search.send_keys(\"美女\") 查找搜索按钮 enter=bro.find_element_by_id('su') 点击按钮 enter.click() 关闭浏览器 bro.close() 小案例 import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") # # 隐士等待(最多等待10s) # 只有控件没有加载出来，才会等，控件一旦加载出来，直接就取到 bro.implicitly_wait(10) submit_button=bro.find_element_by_link_text('登录') submit_button.click() user_button=bro.find_element_by_id('TANGRAM__PSP_10__footerULoginBtn') user_button.click() user_input=bro.find_element_by_id('TANGRAM__PSP_10__userName') user_input.send_keys(\"ssssss@qq.com\") pwd_input=bro.find_element_by_id('TANGRAM__PSP_10__password') pwd_input.send_keys(\"123456\") submit_input=bro.find_element_by_id('TANGRAM__PSP_10__submit') submit_input.click() time.sleep(5) bro.close() 获取 cookie # 登陆之后，拿到cookie：就可以自己搭建cookie池（requests模块发请求，携带者cookie） import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") print(bro.get_cookies()) bro.close() # #搭建cookie池和代理池的作用是什么？封ip ，封账号（弄一堆小号，一堆cookie） 无界面浏览器 from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument('window-size=1920x3000') #指定浏览器分辨率 chrome_options.add_argument('--disable-gpu') #谷歌文档提到需要加上这个属性来规避bug chrome_options.add_argument('--hide-scrollbars') #隐藏滚动条, 应对一些特殊页面 chrome_options.add_argument('blink-settings=imagesEnabled=false') #不加载图片, 提升速度 chrome_options.add_argument('--headless') #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败 bro=webdriver.Chrome(executable_path='./chromedriver',options=chrome_options) bro.get(\"https://www.baidu.com\") print(bro.get_cookies()) bro.close 获取标签属性(重点) print(tag.get_attribute('src')) print(tag.get_attribute('href')) 获取标签文本(重点) print(tag.text) 获取标签ID，位置，名称，大小（了解） print(tag.id) print(tag.location) print(tag.tag_name) print(tag.size) 显示等待与隐式等待 # 隐士等待(最多等待10s) bro.implicitly_wait(10) # 只有控件没有加载出来，才会等，控件一旦加载出来，直接就取到 # 显示等待（每个控件，都要写等待），不要使用 元素交互操作 # 点击click，清空clear，输入文字send_keys 执行js import time bro=webdriver.Chrome(executable_path='./chromedriver') # bro.get(\"https://www.cnblogs.com\") # 执行js代码 # bro.execute_script('alert(1)') # window.scrollTo(0,document.body.scrollHeight) # 使页面滚动到最低层 bro.execute_script('window.scrollTo(0,document.body.scrollHeight)') time.sleep(5) bro.close() 模拟浏览器的前进后头 import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.cnblogs.com\") time.sleep(1) bro.get(\"https://www.baidu.com\") time.sleep(1) bro.get(\"https://www.jd.com\") #退到上一个 bro.back() time.sleep(1) # 前进一下 bro.forward() time.sleep(5) bro.close() 选项卡管理 import time from selenium import webdriver # browser=webdriver.Chrome(executable_path='./chromedriver') browser.get('https://www.baidu.com') browser.execute_script('window.open()') # 本质上是执行的js代码 print(browser.window_handles) #获取所有的选项卡 browser.switch_to_window(browser.window_handles[1]) browser.get('https://www.taobao.com') time.sleep(2) browser.switch_to_window(browser.window_handles[0]) browser.get('https://www.sina.com.cn') browser.close() 异常处理 from selenium import webdriver from selenium.common.exceptions import TimeoutException,NoSuchElementException,NoSuchFrameException try: browser=webdriver.Chrome(executable_path='./chromedriver') browser.get('http://www.baidu.com') browser.find_element_by_id(\"xxx\") # except Exception as e: # print(e) finally: browser.close() ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:3:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"小案例 ######## # 爬取京东商品信息 ####### from selenium import webdriver import time from selenium.webdriver.common.keys import Keys bro=webdriver.Chrome(executable_path='./chromedriver') def get_goods(bro): # find_elements_by_class_name 找所有 # find_element_by_class_name 找一个 li_list=bro.find_elements_by_class_name('gl-item') # ul_list=bro.find_elements_by_css_selector('.gl-item') for li in li_list: url=li.find_element_by_css_selector('.p-img\u003ea').get_attribute('href') url_img=li.find_element_by_css_selector('.p-img img').get_attribute(\"src\") if not url_img: url_img='https:'+li.find_element_by_css_selector('.p-img img').get_attribute(\"data-lazy-img\") price=li.find_element_by_css_selector('.p-price i').text name=li.find_element_by_css_selector('.p-name em').text commit=li.find_element_by_css_selector('.p-commit a').text print(''' 商品名字：%s 商品价格：%s 商品图片地址：%s 商品地址：%s 商品评论数：%s '''%(name,price,url,url_img,commit)) #查找下一页按钮 next=bro.find_element_by_partial_link_text('下一页') time.sleep(1) next.click() #继续抓取下一页 get_goods(bro) try: bro.get('https://www.jd.com') #隐士等待 bro.implicitly_wait(10) input_search=bro.find_element_by_id('key') input_search.send_keys(\"精品内衣\") #模拟键盘操作(模拟键盘敲回车) input_search.send_keys(Keys.ENTER) get_goods(bro) except Exception as e: print(e) finally: bro.close() [toc] ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:3:1","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"爬虫 代理池 模块使用 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:0:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"免费代理池 # https://github.com/jhao104/proxy_pool # 收费的：提供给你一个接口，每掉一次这个接口，获得一个代理 # 免费：用爬虫爬取，免费代理，放到我的库中，flask，django搭一个服务（删除代理，自动测试代理可用性），每次发一个请求，获取一个代理 # 带你配置 # 1 下载，解压，用pycharm打开 # 2 安装依赖 pip install -r requirements.txt # 3 配置Config/setting.py: DB_TYPE = getenv('db_type', 'redis').upper() DB_HOST = getenv('db_host', '127.0.0.1') DB_PORT = getenv('db_port', 6379) DB_PASSWORD = getenv('db_password', '') # 4 本地启动redis-server # 5 可以在cli目录下通过ProxyPool.py -python proxyPool.py schedule :调度程序，他会取自动爬取免费代理 -python proxyPool.py webserver:启动api服务，把flask启动起来 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:1:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"验证码破解 # 1 简单验证码，字母，数字 # 2 高级的，选择，你好，12306选择乒乓球，滑动验证（极验） # 打码平台（自动破解验证码，需要花钱）云打码，超级鹰（12306） http://www.yundama.com/ http://www.chaojiying.com/ # 注册账号，（充钱）把demo下载下来，运行即可 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:2:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"爬取段子发送给女朋友 ##### # 1 爬取糗事百科，微信自动发送 ##### # https://www.qiushibaike.com/text/ # https://www.qiushibaike.com/text/page/1/ import requests from bs4 import BeautifulSoup ret=requests.get('https://www.qiushibaike.com/text/page/1/') # print(ret.text) ll=[] soup=BeautifulSoup(ret.text,\"lxml\") article_list=soup.find_all(name='div',id=True,class_='article') for article in article_list: content=article.find(name='div',class_='content').span.text # content=article.find(name='div',class_='content').text # content=article.find(class_='content').text # print(content) # 入库 #我们放到列表中 ll.append(content) print(ll) # 微信自动发消息 # wxpy：实现了web微信的接口 # pip3 install wxpy from wxpy import * # 实例化得到一个对象，微信机器人对象 import random bot=Bot(cache_path=True) @bot.register() # 接收从指定好友发来的消息，发送者即recv_msg.sender为指定好友girl_friend def recv_send_msg(recv_msg): print('收到的消息：',recv_msg.text) # recv_msg.text取得文本 return random.choice(ll) embed() ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:3:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"爬虫 bs4 模块使用 ","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:0","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"bs4的使用 从html或者xml中提取数据的python库，修改xml # 安装 pip3 install beautifulsoup4 # 使用 from bs4 import BeautifulSoup # 实例化得到对象，传入要解析的文本，解析器 # html.parser内置解析器，速度稍微慢一些，但是不需要装第三方模块 # lxml：速度快一些，但是需要安装 pip3 install lxml soup=BeautifulSoup(ret.text,'html.parser') # soup=BeautifulSaoup(open('a.html','r')) # find（找到的第一个） # find_all(找到的所有) 遍历文档树 from bs4 import BeautifulSoup html_doc = \"\"\" \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"id=\"id_p\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \"\"\" # pip3 install lxml soup=BeautifulSoup(html_doc,'lxml') # 美化 # print(soup.prettify()) Tag 对象 from bs4.element import Tag #1、用法（通过.来查找，只能找到第一个） # head=soup.head # title=head.title # # print(head) # print(title) 获取标签名称 # p=soup.body # print(type(p)) # print(p.name) 获取标签属性 p=soup.p # 方式一 # 获取class属性,可以有多个，拿到列表 print(p['class']) print(p['id']) print(p.get('id')) # 方式二 print(p.attrs['class']) print(p.attrs.get('id')) 获取标签内容 p=soup.p print(p.text) # 所有层级都拿出来拼到一起 print(p.string) # 只有一层，才能去除 print(list(p.strings)) # 把每次都取出来，做成一个生成器 嵌套选择 title=soup.head.title print(title) 子节点 子孙节点 p1=soup.p.children # 迭代器 p2=soup.p.contents # 列表 print(list(p1)) print(p2) 父节点 祖先节点 p1=soup.p.parent # 直接父节点 p2=soup.p.parents print(p1) # print(len(list(p2))) print(list(p2)) 兄弟节点 print(soup.a.next_sibling) #下一个兄弟 print(soup.a.previous_sibling) #上一个兄弟 print(list(soup.a.next_siblings)) #下面的兄弟们=\u003e生成器对象 print(soup.a.previous_siblings) #上面的兄弟们=\u003e生成器对象 查找文档树 # 查找文档树（find，find_all），速度比遍历文档树慢 # 两个配合着使用（soup.p.find()） 五种过滤器(# 以find为例) 字符串 #1 字符串查找 引号内是字符串 p=soup.find(name='p') p=soup.find(name='body') print(p) # 查找类名是title的所有标签,class是关键字，class_ ret=soup.find_all(class_='title') href属性为http://example.com/elsie的标签 ret=soup.find_all(href='http://example.com/elsie') 找id为xx的标签 ret=soup.find_all(id='id_p') print(ret) 正则表达式 import re # reg=re.compile('^b') # ret=soup.find_all(name=reg) #找id以id开头的标签 reg=re.compile('^id') ret=soup.find_all(id=reg) print(ret) 列表 ret=soup.find_all(name=['body','b']) ret=soup.find_all(id=['id_p','link1']) ret=soup.find_all(class_=['id_p','link1']) # and 关系 ret=soup.find_all(class_='title',name='p') print(ret) True # 所有有名字的标签 ret=soup.find_all(name=True) #所有有id的标签 ret=soup.find_all(id=True) # 所有有herf属性的 ret=soup.find_all(href=True) print(ret) 方法 def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id') print(soup.find_all(has_class_but_no_id)) 其他使用 ret=soup.find_all(attrs={'class':\"title\"}) ret=soup.find_all(attrs={'id':\"id_p1\",'class':'title'}) print(ret) 拿到标签取属性, 去text ret=soup.find_all(attrs={'id':\"id_p\",'class':'title'}) print(ret[0].text) limit(限制条数) soup.find() # 就是find_all limit=1 ret=soup.find_all(name=True,limit=2) print(len(ret)) recursive recursive=False (只找儿子)不递归查找，只找第一层 ret=soup.body.find_all(name='p',recursive=False) print(ret) ","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:1","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"css 和 xpath 选择器 css 选择器 # 重点 # Tag对象.select(\"css选择器\") # #ID号 # .类名 # div\u003ep：儿子 和div p：子子孙孙 # 找div下最后一个a标签 div a:last-child # bs4：自己的选择器，css选择器 # lxml：css选择器，xpath选择器 # selenium：自己的选择器，css选择器，xpath选择器 # scrapy框架：自己的选择器，css选择器，xpath选择器 # #select('.article') #该模块提供了select方法来支持css,详见官网:https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id37 html_doc = \"\"\" \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"\u003e \u003cb\u003eThe Dormouse's story\u003c/b\u003e Once upon a time there were three little sisters; and their names were \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003e \u003cspan\u003eElsie\u003c/span\u003e \u003c/a\u003e \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; \u003cdiv class='panel-1'\u003e \u003cul class='list' id='list-1'\u003e \u003cli class='element'\u003eFoo\u003c/li\u003e \u003cli class='element'\u003eBar\u003c/li\u003e \u003cli class='element'\u003eJay\u003c/li\u003e \u003c/ul\u003e \u003cul class='list list-small' id='list-2'\u003e \u003cli class='element'\u003e\u003ch1 class='yyyy'\u003eFoo\u003c/h1\u003e\u003c/li\u003e \u003cli class='element xxx'\u003eBar\u003c/li\u003e \u003cli class='element'\u003eJay\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e and they lived at the bottom of a well. \u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \"\"\" from bs4 import BeautifulSoup soup=BeautifulSoup(html_doc,'lxml') ### css 选择器 print(soup.p.select('.sister')) print(soup.select('.sister span')) print(soup.select('#link1')) print(soup.select('#link1 span')) print(soup.select('#list-2 .element.xxx')) print(soup.select('#list-2')[0].select('.element')) #可以一直select,但其实没必要,一条select就可以了 # xpath选择 # / 从根节点选取 /a 从根节点开始，往下找a标签（子） # //从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 //a 从根节点开始找a标签（子子孙孙中所有a） # . 选取当前节点。 # .. 选取当前节点的父节点。 # @ 选取属性。 ######## # 2 xpath选择器 ######## # XPath 是一门在 XML 文档中查找信息的语言 # xpath选择 # / 从根节点选取 /a 从根节点开始，往下找a标签（子） # //从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 //a 从根节点开始找a标签（子子孙孙中所有a） # 取值 /text() # 取属性 /@属性名 # //*[@id=\"auto-channel-lazyload-article\"]/ul[1] # //ul[1] # //*[@id=\"focus-1\"]/div[1]/ul/li[3]/h2 # #focus-1 \u003e div.focusimg-pic \u003e ul \u003e li:nth-child(3) \u003e h2 doc=''' \u003chtml\u003e \u003chead\u003e \u003cbase href='http://example.com/' /\u003e \u003ctitle\u003eExample website\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='images'\u003e \u003ca href='image1.html' id=\"xxx\"\u003eName: My image 1 \u003cbr /\u003e\u003cimg src='image1_thumb.jpg' /\u003e\u003c/a\u003e \u003ch5\u003etest\u003c/h5\u003e \u003ca href='image2.html'\u003eName: My image 2 \u003cbr /\u003e\u003cimg src='image2_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image3.html'\u003eName: My image 3 \u003cbr /\u003e\u003cimg src='image3_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image4.html'\u003eName: My image 4 \u003cbr /\u003e\u003cimg src='image4_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image5.html' class='li li-item' name='items'\u003eName: My image 5 \u003cbr /\u003e\u003cimg src='image5_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image6.html' name='items'\u003e\u003cspan\u003e\u003ch5\u003etest\u003c/h5\u003e\u003c/span\u003eName: My image 6 \u003cbr /\u003e\u003cimg src='image6_thumb.jpg' /\u003e\u003c/a\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ''' from lxml import etree html=etree.HTML(doc) # 传字符串 # html=etree.parse('search.html',etree.HTMLParser()) # 文件 # 1 所有节点 # a=html.xpath('//*') # 2 指定节点（结果为列表） # a=html.xpath('//head') # 3 子节点，子孙节点 # a=html.xpath('//div/a') # a=html.xpath('//body/a') #无数据 # a=html.xpath('//body//a') # 4 父节点 # a=html.xpath('//body//a[@href=\"image1.html\"]/..') # a=html.xpath('//body//a[@href=\"image1.html\"]') # a=html.xpath('//body//a[1]/..') # 也可以这样 # a=html.xpath('//body//a[1]/parent::*') # 5 属性匹配 # a=html.xpath('//body//a[@href=\"image1.html\"]') # 6 文本获取 标签后加：/text() ********重点 # a=html.xpath('//body//a[@href=\"image1.html\"]/text()') # a=html.xpath('//body//a/text()') # 7 属性获取 标签后：/@href ********重点 # a=html.xpath('//body//a/@href') # # 注意从1 开始取（不是从0） # a=html.xpath('//body//a[3]/@href') # 8 属性多值匹配 # a 标签有多个class类，直接匹配就不可以了，需要用contains # a=html.xpath('//body//a[@class=\"li\"]') # a=html.xpath('//body//a[@href=\"image1.html\"]') # a=html.xpath('//body//a[contains(@class,\"li\")]') # a=html.xpath('//body//a[contains(@class,\"li\")]/text()') # a=html.xpath('//body//a[contains(@class,\"li\")]/@name') # 9 多属性匹配 or 和 and （了解） # a=html.xpath('//body//a[contains(@class,\"li\") or @name=\"items\"]') # a=html.xpath('//body//a[contains(@class,\"li\") and @name=\"items\"]/text()') # a=html.xpath('//body//a[contains(@class,\"li\"","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:2","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":null,"content":"爬虫 requests 模块使用 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:0","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"爬虫介绍 # 1 本质：模拟发送http请求（requests）----》解析返回数据（re，bs4，lxml，json）---》入库（redis，mysql，mongodb） # 2 app爬虫：本质一模一样 # 3 为什么python做爬虫最好：包多，爬虫框架：scrapy：性能很高的爬虫框架，爬虫界的django，大而全（爬虫相关的东西都集成了） # 4 百度，谷歌，就是个大爬虫 在百度搜索，其实是去百度的服务器的库搜的，百度一直开着爬虫，一刻不停的在互联网上爬取，把页面存储到自己库中 # 5 全文检索：全文检索 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:1","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"requests 模块 requests模块是基于urllib2 内置库的基础上封装的一个模块, 被广泛应用 安装方法 pip3 install requests 基本使用 返回值的属性 import requests # # 发送http请求 # # get,delete,post。。本质都是调用request函数 # ret=requests.get('https://www.cnblogs.com') # print(ret.status_code) # 响应状态码 # print(ret.text) # 响应体，转成了字符串 # print(ret.content) # 响应体，二进制 # ret=requests.post()\\ # ret=requests.request(\"get\",) # ret=requests.delete() ## get 请求 带参数 get请求带参数 方式一 ret = requests.get('https://www.baidu.com/', headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36', }) 方式二（建议用方式二）中文会自动转码 ret=requests.get('http://0.0.0.0:8001/',params={'name':\"美女\",'age':18}) print(ret.text) 带 headers ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', headers={ # 标志，什么东西发出的请求，浏览器信息，django框架，从哪取？（meta） 'User-Agent': 'request', # 上一个页面的地址，图片防盗链 'Referer': 'xxx' }) print(ret) # 图片防盗链：如果图片的referer不是我自己的网站，就直接禁止掉 \u003cimg src=\"https://www.lgstatic.com/lg-community-fed/community/modules/common/img/avatar_default_7225407.png\"\u003e 带 cookie # 带cookie,随机字符串(用户信息：也代表session)，不管后台用的token认证，还是session认证 # 一旦登陆了，带着cookie发送请求，表示登陆了（下单，12306买票，评论） 方式一 ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', headers={ 'cookie': 'key3=value;key2=value', }) 方式二 ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', cookies={\"islogin\":\"xxx\"}) print(ret) 发送post 请求 5 发送post请求（注册，登陆），携带数据（body） data=None, json=None # data:urlencoded编码 ret=requests.post('http://0.0.0.0:8001/',data={'name':\"lqz\",'age':18}) # json:json编码 import json data=json.dumps({'name':\"lqz\",'age':18}) ret=requests.post('http://0.0.0.0:8001/',json=data) print(ret) # 注意：编码格式是请求头中带的，所有我可以手动修改，在headers中改 session 对象 session=requests.session() # 跟requests.get/post用起来完全一样，但是它处理了cookie # 假设是一个登陆，并且成功 session.post() # 再向该网站发请求，就是登陆状态，不需要手动携带cookie session.get(\"地址\") 响应对象 print(respone.text) # 响应体转成str print(respone.content) # 响应体二进制（图片，视频） print(respone.status_code) # 响应状态码 print(respone.headers) # 响应头 print(respone.cookies) # 服务端返回的cookie print(respone.cookies.get_dict()) # 转成字典 print(respone.cookies.items()) print(respone.url) # 当次请求的地址 print(respone.history) # 如果有重定向，放到一个列表中 ret=requests.post('http://0.0.0.0:8001/') ret=requests.get('http://0.0.0.0:8001/admin') #不要误解 ret=requests.get('http://0.0.0.0:8001/user') print(ret.history) print(respone.encoding) # 编码方式 response.iter_content() # 视频，图片迭代取值 with open(\"a.mp4\",'wb') as f: for line in response.iter_content(): f.write(lin 乱码问题 # 加载回来的页面，打印出来，乱码（我们用的是utf8编码），如果网站用gbk， ret.encoding='gbk' ret=requests.get('http://0.0.0.0:8001/user') # ret.apparent_encoding当前页面的编码 ret.encoding=ret.apparent_encoding 解析json # 返回数据，有可能是json格式，有可能是html格式 ret=requests.get('http://0.0.0.0:8001/') print(type(ret.text)) print(ret.text) # a=ret.json() print(a['name']) print(type(a)) 使用代理 proxies={} # 正向代理 # django如何拿到客户端ip地址 META.get(\"REMOTE_ADDR\") # 如何去获取代理，如何使用（用自己项目验收） # 使用代理有什么用 ret=requests.get('http://0.0.0.0:8001/',proxies={'http':'地址'}) print(type(ret.text)) print(ret.text) 异常处理 # 用try except捕获一下 就用它就型了：Exception 上传文件 (爬虫用的比较少，后台写服务，) file={'myfile':open(\"1.txt\",'rb')} ret=requests.post('http://0.0.0.0:8001/',files=file) print(ret.content) ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:2","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"爬梨视频 ############ # 2 爬取视频 ############# #categoryId=9 分类id #start=0 从哪个位置开始，每次加载12个 # https://www.pearvideo.com/category_loading.jsp?reqType=5\u0026categoryId=9\u0026start=0 import requests import re ret=requests.get('https://www.pearvideo.com/category_loading.jsp?reqType=5\u0026categoryId=9\u0026start=0') # print(ret.text) # 正则取解析 reg='\u003ca href=\"(.*?)\" class=\"vervideo-lilink actplay\"\u003e' video_urls=re.findall(reg,ret.text) print(video_urls) for url in video_urls: ret_detail=requests.get('https://www.pearvideo.com/'+url) reg='srcUrl=\"(.*?)\",vdoUrl=srcUrl' mp4_url=re.findall(reg,ret_detail.text)[0] #type:str # 下载视频 video_content=requests.get(mp4_url) video_name=mp4_url.rsplit('/',1)[-1] with open(video_name,'wb') as f: for line in video_content.iter_content(): f.write(line) ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:3","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"模拟登陆 ############ # 3 模拟登陆某网站 ############# import requests ret = requests.post('http://www.aa7a.cn/user.php', data={ 'username': '616564099@qq.com', 'password': 'lqz123', 'captcha': 'f5jn', 'remember': '1', 'ref': 'http://www.aa7a.cn/', 'act': 'act_login', }) cookie=ret.cookies.get_dict() print(cookie) # 如果不出意外，咱么就登陆上了,再向首页发请求，首页返回的数据中就有616564099@qq.com ret1=requests.get('http://www.aa7a.cn/',cookies=cookie) # ret1=requests.get('http://www.aa7a.cn/') print('616564099@qq.com' in ret1.text) # 秒杀小米手机，一堆小号 # 定时任务：一到时间，就可以发送post请求，秒杀手机 # 以后碰到特别难登陆的网站，代码登陆不进去怎么办？ # 之所以要登陆，就是为了拿到cookie，下次发请求（如果程序拿不到cookie，自动登陆不进去） # 就手动登陆进去，然后用程序发请求 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:4","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":["异步"],"content":"celery 的简单使用 ","date":"2017-06-03","objectID":"/posts/celery/:0:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"官方 Celery 官网：http://www.celeryproject.org/ Celery 官方文档英文版：http://docs.celeryproject.org/en/latest/index.html Celery 官方文档中文版：http://docs.jinkan.org/docs/celery/ ","date":"2017-06-03","objectID":"/posts/celery/:1:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery异步任务框架 \"\"\" 1）可以不依赖任何服务器，通过自身命令，启动服务(内部支持socket) 2）celery服务为为其他项目服务提供异步解决任务需求的 注：会有两个服务同时运行，一个是项目服务，一个是celery服务，项目服务将需要异步处理的任务交给celery服务，celery就会在需要时异步完成项目的需求 人是一个独立运行的服务 | 医院也是一个独立运行的服务 正常情况下，人可以完成所有健康情况的动作，不需要医院的参与；但当人生病时，就会被医院接收，解决人生病问题 人生病的处理方案交给医院来解决，所有人不生病时，医院独立运行，人生病时，医院就来解决人生病的需求 \"\"\" ","date":"2017-06-03","objectID":"/posts/celery/:2:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery架构 Celery的架构由三部分组成，消息中间件（message broker）、任务执行单元（worker）和 任务执行结果存储（task result store）组成。 ","date":"2017-06-03","objectID":"/posts/celery/:3:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"消息中间件 Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等 ","date":"2017-06-03","objectID":"/posts/celery/:3:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"任务执行单元 Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。 ","date":"2017-06-03","objectID":"/posts/celery/:3:2","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"任务结果存储 Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等 ","date":"2017-06-03","objectID":"/posts/celery/:3:3","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"使用场景 异步执行：解决耗时任务 延迟执行：解决延迟任务 定时执行：解决周期(周期)任务 ","date":"2017-06-03","objectID":"/posts/celery/:3:4","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery的安装配置 pip install celery 消息中间件：RabbitMQ/Redis app=Celery(‘任务名’, broker=‘xxx’, backend=‘xxx’) ","date":"2017-06-03","objectID":"/posts/celery/:4:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"两种celery任务结构：提倡用包管理，结构更清晰 # 如果 Celery对象:Celery(...) 是放在一个模块下的 # 1）终端切换到该模块所在文件夹位置：scripts # 2）执行启动worker的命令：celery worker -A 模块名 -l info -P eventlet # 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info # 注：模块名随意 # 如果 Celery对象:Celery(...) 是放在一个包下的 # 1）必须在这个包下建一个celery.py的文件，将Celery(...)产生对象的语句放在该文件中 # 2）执行启动worker的命令：celery worker -A 包名 -l info -P eventlet # 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info # 注：包名随意 ","date":"2017-06-03","objectID":"/posts/celery/:4:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery执行异步任务 ","date":"2017-06-03","objectID":"/posts/celery/:5:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"包架构封装 project ├── celery_task # celery包 │ ├── __init__.py # 包文件 │ ├── celery.py # celery连接和配置相关文件，且名字必须交celery.py │ └── tasks.py # 所有任务函数 ├── add_task.py # 添加任务 └── get_result.py # 获取结果 ","date":"2017-06-03","objectID":"/posts/celery/:5:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"基本使用 celery.py # 1）创建app + 任务 # 2）启动celery(app)服务： # 非windows # 命令：celery worker -A celery_task -l info # windows： # pip3 install eventlet # celery worker -A celery_task -l info -P eventlet # 3）添加任务：手动添加，要自定义添加任务的脚本，右键执行脚本 # 4）获取结果：手动获取，要自定义获取任务的脚本，右键执行脚本 from celery import Celery broker = 'redis://127.0.0.1:6379/1' backend = 'redis://127.0.0.1:6379/2' app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) tasks.py from .celery import app import time @app.task def add(n, m): print(n) print(m) time.sleep(10) print('n+m的结果：%s' % (n + m)) return n + m @app.task def low(n, m): print(n) print(m) print('n-m的结果：%s' % (n - m)) return n - m add_task.py from celery_task import tasks # 添加立即执行任务 t1 = tasks.add.delay(10, 20) t2 = tasks.low.delay(100, 50) print(t1.id) # 添加延迟任务 from datetime import datetime, timedelta eta=datetime.utcnow() + timedelta(seconds=10) tasks.low.apply_async(args=(200, 50), eta=eta) get_result.py from celery_task.celery import app from celery.result import AsyncResult id = '21325a40-9d32-44b5-a701-9a31cc3c74b5' if __name__ == '__main__': async = AsyncResult(id=id, app=app) if async.successful(): result = async.get() print(result) elif async.failed(): print('任务失败') elif async.status == 'PENDING': print('任务等待中被执行') elif async.status == 'RETRY': print('任务异常后正在重试') elif async.status == 'STARTED': print('任务已经开始被执行') ","date":"2017-06-03","objectID":"/posts/celery/:5:2","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"高级使用 celery.py # 1）创建app + 任务 # 2）启动celery(app)服务： # 非windows # 命令：celery worker -A celery_task -l info # windows： # pip3 install eventlet # celery worker -A celery_task -l info -P eventlet # 3）添加任务：自动添加任务，所以要启动一个添加任务的服务 # 命令：celery beat -A celery_task -l info # 4）获取结果 from celery import Celery broker = 'redis://127.0.0.1:6379/1' backend = 'redis://127.0.0.1:6379/2' app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) # 时区 app.conf.timezone = 'Asia/Shanghai' # 是否使用UTC app.conf.enable_utc = False # 任务的定时配置 from datetime import timedelta from celery.schedules import crontab app.conf.beat_schedule = { 'low-task': { 'task': 'celery_task.tasks.low', 'schedule': timedelta(seconds=3), # 'schedule': crontab(hour=8, day_of_week=1), # 每周一早八点 'args': (300, 150), } } tasks.py from .celery import app import time @app.task def add(n, m): print(n) print(m) time.sleep(10) print('n+m的结果：%s' % (n + m)) return n + m @app.task def low(n, m): print(n) print(m) print('n-m的结果：%s' % (n - m)) return n - m get_result.py from celery_task.celery import app from celery.result import AsyncResult id = '21325a40-9d32-44b5-a701-9a31cc3c74b5' if __name__ == '__main__': async = AsyncResult(id=id, app=app) if async.successful(): result = async.get() print(result) elif async.failed(): print('任务失败') elif async.status == 'PENDING': print('任务等待中被执行') elif async.status == 'RETRY': print('任务异常后正在重试') elif async.status == 'STARTED': print('任务已经开始被执行') ","date":"2017-06-03","objectID":"/posts/celery/:5:3","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"django中使用 celery.py \"\"\" celery框架django项目工作流程 1）加载django配置环境 2）创建Celery框架对象app，配置broker和backend，得到的app就是worker 3）给worker对应的app添加可处理的任务函数，用include配置给worker的app 4）完成提供的任务的定时配置app.conf.beat_schedule 5）启动celery服务，运行worker，执行任务 6）启动beat服务，运行beat，添加任务 重点：由于采用了django的反射机制，使用celery.py所在的celery_task包必须放置项目的根目录下 \"\"\" # 一、加载django配置环境 import os os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"luffyapi.settings.dev\") # 二、加载celery配置环境 from celery import Celery # broker broker = 'redis://127.0.0.1:6379/0' # backend backend = 'redis://127.0.0.1:6379/1' # worker app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) # 时区 app.conf.timezone = 'Asia/Shanghai' # 是否使用UTC app.conf.enable_utc = False # 任务的定时配置 from datetime import timedelta from celery.schedules import crontab app.conf.beat_schedule = { 'update-banner-list': { 'task': 'celery_task.tasks.update_banner_list', 'schedule': timedelta(seconds=10), 'args': (), } } tasks.py from .celery import app from django.core.cache import cache from home import models, serializers from django.conf import settings @app.task def update_banner_list(): queryset = models.Banner.objects.filter(is_delete=False, is_show=True).order_by('-orders')[:settings.BANNER_COUNT] banner_list = serializers.BannerSerializer(queryset, many=True).data # 拿不到request对象，所以头像的连接base_url要自己组装 for banner in banner_list: banner['image'] = 'http://127.0.0.1:8000%s' % banner['image'] cache.set('banner_list', banner_list, 86400) return True ","date":"2017-06-03","objectID":"/posts/celery/:5:4","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["Python基础"],"content":"GIL 全局解释器锁 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:0","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"什么是GIL 全局解释器锁 \"\"\" In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) \"\"\" GIL 本质就是一把互斥锁， 本质上是将并发变为串行 每个进程内都会存在一把GIl ， 同一进程内的多个线程必须要抢到GIL才行使用Cpython解释器来执行自己的代码， 即 同一进程下的多个线程无法实现并行，但是可以实现并发。 在Cpython 解释器下， 如果想实现并行可以开启多个进行 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:1","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"为什么要有GIL Python的内存管理不是线程安全的原因就是 垃圾回收机制。 因为Cpython 解释器的垃圾回收机制不是线程安全的 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:2","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"一 isinstance(obj,cls)和issubclass(sub,super) isinstance(obj,cls)检查是否obj是否是类 cls 的对象 1 class Foo(object): 2 pass 3 4 obj = Foo() 5 6 isinstance(obj, Foo) issubclass(sub, super)检查sub类是否是 super 类的派生类 1 class Foo(object): 2 pass 3 4 class Bar(Foo): 5 pass 6 7 issubclass(Bar, Foo) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:1:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"二 反射 1 什么是反射 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。 2 python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射） 四个可以实现自省的函数 下列方法适用于类和对象（一切皆对象，类本身也是一个对象） hasattr(object,name) def hasattr(*args, **kwargs): # real signature unknown \"\"\" Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError. \"\"\" pass getattr(object, name, default=None) def getattr(object, name, default=None): # known special case of getattr \"\"\" getattr(object, name[, default]) -\u003e value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case. \"\"\" pass **setattr(x, y, v) ** def setattr(x, y, v): # real signature unknown; restored from __doc__ \"\"\" Sets the named attribute on the given object to the specified value. setattr(x, 'y', v) is equivalent to ``x.y = v'' \"\"\" pass delattr(x, y) def delattr(x, y): # real signature unknown; restored from __doc__ \"\"\" Deletes the named attribute from the given object. delattr(x, 'y') is equivalent to ``del x.y'' \"\"\" pass 四个方法的使用演示 class BlackMedium: feature='Ugly' def __init__(self,name,addr): self.name=name self.addr=addr def sell_house(self): print('%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼' %self.name) def rent_house(self): print('%s 黑中介租房子啦,傻逼才租呢' %self.name) b1=BlackMedium('万成置地','回龙观天露园') #检测是否含有某属性 print(hasattr(b1,'name')) print(hasattr(b1,'sell_house')) #获取属性 n=getattr(b1,'name') print(n) func=getattr(b1,'rent_house') func() # getattr(b1,'aaaaaaaa') #报错 print(getattr(b1,'aaaaaaaa','不存在啊')) #设置属性 setattr(b1,'sb',True) setattr(b1,'show_name',lambda self:self.name+'sb') print(b1.__dict__) print(b1.show_name(b1)) #删除属性 delattr(b1,'addr') delattr(b1,'show_name') delattr(b1,'show_name111')#不存在,则报错 print(b1.__dict__) 四个方法的使用演示 类也是对象 class Foo(object): staticField = \"old boy\" def __init__(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return 'bar' print getattr(Foo, 'staticField') print getattr(Foo, 'func') print getattr(Foo, 'bar') 反射当前模块成员 #!/usr/bin/env python # -*- coding:utf-8 -*- import sys def s1(): print 's1' def s2(): print 's2' this_module = sys.modules[__name__] hasattr(this_module, 's1') getattr(this_module, 's2') 反射当前模块成员 导入其他模块，利用反射查找该模块是否存在某个方法 module_test.py 1 #!/usr/bin/env python 2 # -*- coding:utf-8 -*- 3 4 \"\"\" 5 程序目录： 6 module_test.py 7 index.py 8 9 当前文件： 10 index.py 11 \"\"\" 12 13 import module_test as obj 14 15 #obj.test() 16 17 print(hasattr(obj,'test')) 18 19 getattr(obj,'test')() 3 为什么用反射之反射的好处 好处一：实现可插拔机制 有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。 总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能 **egon还没有实现全部功能 ** class FtpClient: \"ftp客户端, 但是没有实现具体功能\" def __init__(self,addr): pass 不影响lili的代码编写 #from module import FtpClient f1=FtpClient('192.168.1.1') if hasattr(f1,'get'): func_get=getattr(f1,'get') func_get() else: print('----\u003e不存在此方法') print('处理其他的逻辑') 不影响lili的代码编写 好处二：动态导入模块（基于反射当前模块成员） ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:2:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"三 setattr,delattr,getattr 三者的用法演示 class Foo: x=1 def __init__(self,y): self.y=y def __getattr__(self, item): print('----\u003e from getattr:你找的属性不存在') def __setattr__(self, key, value): print('----\u003e from setattr') # self.key=value #这就无限递归了,你好好想想 # self.__dict__[key]=value #应该使用它 def __delattr__(self, item): print('----\u003e from delattr') # del self.item #无限递归了 self.__dict__.pop(item) #__setattr__添加/修改属性会触发它的执行 f1=Foo(10) print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值 f1.z=3 print(f1.__dict__) #__delattr__删除属性的时候会触发 f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作 del f1.a print(f1.__dict__) #__getattr__只有在使用点调用属性且属性不存在的时候才会触发 f1.xxxxxx ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:3:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"四 二次加工标准类型(包装) 包装：python为大家提供了标准数据类型，以及丰富的内置方法，其实在很多场景下我们都需要基于标准数据类型来定制我们自己的数据类型，新增/改写方法，这就用到了我们刚学的继承/派生知识（其他的标准类型均可以通过下面的方式进行二次加工） 二次加工标准类型(基于继承实现) class List(list): #继承list所有的属性，也可以派生出自己新的，比如append和mid def append(self, p_object): ' 派生自己的append：加上类型检查' if not isinstance(p_object,int): raise TypeError('must be int') super().append(p_object) @property def mid(self): '新增自己的属性' index=len(self)//2 return self[index] l=List([1,2,3,4]) print(l) l.append(5) print(l) # l.append('1111111') #报错，必须为int类型 print(l.mid) #其余的方法都继承list的 l.insert(0,-123) print(l) l.clear() print(l) 二次加工标准类型(基于继承实现) 练习（clear加权限限制） class List(list): def __init__(self,item,tag=False): super().__init__(item) self.tag=tag def append(self, p_object): if not isinstance(p_object,str): raise TypeError super().append(p_object) def clear(self): if not self.tag: raise PermissionError super().clear() l=List([1,2,3],False) print(l) print(l.tag) l.append('saf') print(l) # l.clear() #异常 l.tag=True l.clear() 练习（clear加权限限制） 授权：授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。 实现授权的关键点就是覆盖__getattr__方法 授权示范一 import time class FileHandle: def __init__(self,filename,mode='r',encoding='utf-8'): self.file=open(filename,mode,encoding=encoding) def write(self,line): t=time.strftime('%Y-%m-%d %T') self.file.write('%s %s' %(t,line)) def __getattr__(self, item): return getattr(self.file,item) f1=FileHandle('b.txt','w+') f1.write('你好啊') f1.seek(0) print(f1.read()) f1.close() 授权示范一 授权示范二 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' #我们来加上b模式支持 import time class FileHandle: def __init__(self,filename,mode='r',encoding='utf-8'): if 'b' in mode: self.file=open(filename,mode) else: self.file=open(filename,mode,encoding=encoding) self.filename=filename self.mode=mode self.encoding=encoding def write(self,line): if 'b' in self.mode: if not isinstance(line,bytes): raise TypeError('must be bytes') self.file.write(line) def __getattr__(self, item): return getattr(self.file,item) def __str__(self): if 'b' in self.mode: res=\"\u003c_io.BufferedReader name='%s'\u003e\" %self.filename else: res=\"\u003c_io.TextIOWrapper name='%s' mode='%s' encoding='%s'\u003e\" %(self.filename,self.mode,self.encoding) return res f1=FileHandle('b.txt','wb') # f1.write('你好啊啊啊啊啊') #自定制的write,不用在进行encode转成二进制去写了,简单,大气 f1.write('你好啊'.encode('utf-8')) print(f1) f1.close() 练习题（授权） #练习一 class List: def __init__(self,seq): self.seq=seq def append(self, p_object): ' 派生自己的append加上类型检查，覆盖原有的append' if not isinstance(p_object,int): raise TypeError('must be int') self.seq.append(p_object) @property def mid(self): '新增自己的方法' index=len(self.seq)//2 return self.seq[index] def __getattr__(self, item): return getattr(self.seq,item) def __str__(self): return str(self.seq) l=List([1,2,3]) print(l) l.append(4) print(l) # l.append('3333333') #报错，必须为int类型 print(l.mid) #基于授权，获得insert方法 l.insert(0,-123) print(l) #练习二 class List: def __init__(self,seq,permission=False): self.seq=seq self.permission=permission def clear(self): if not self.permission: raise PermissionError('not allow the operation') self.seq.clear() def __getattr__(self, item): return getattr(self.seq,item) def __str__(self): return str(self.seq) l=List([1,2,3]) # l.clear() #此时没有权限，抛出异常 l.permission=True print(l) l.clear() print(l) #基于授权，获得insert方法 l.insert(0,-123) print(l) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:4:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"五 __getattribute __ 回顾__getattr__ class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print('执行的是我') # return self.__dict__[item] f1=Foo(10) print(f1.x) f1.xxxxxx #不存在的属性访问，触发__getattr__ __getattribute__ class Foo: def __init__(self,x): self.x=x def __getattribute__(self, item): print('不管是否存在,我都会执行') f1=Foo(10) f1.x f1.xxxxxx __getattribute__ 二者同时出现 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print('执行的是我') # return self.__dict__[item] def __getattribute__(self, item): print('不管是否存在,我都会执行') raise AttributeError('哈哈') f1=Foo(10) f1.x f1.xxxxxx #当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError 二者同时出现 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:5:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"六 描述符(get,set,delete) 1 描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了__get__(),set(),delete()中的一个,这也被称为描述符协议 get():调用一个属性时,触发 set():为一个属性赋值时,触发 delete():采用del删除属性时,触发 定义一个描述符 class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符 def __get__(self, instance, owner): pass def __set__(self, instance, value): pass def __delete__(self, instance): pass 定义一个描述符 2 描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中) 引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 class Foo: def __get__(self, instance, owner): print('触发get') def __set__(self, instance, value): print('触发set') def __delete__(self, instance): print('触发delete') #包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法 f1=Foo() f1.name='egon' f1.name del f1.name #疑问:何时,何地,会触发这三个方法的执行 引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 描述符应用之何时?何地? #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') #描述符Int class Int: def __get__(self, instance, owner): print('Int调用') def __set__(self, instance, value): print('Int设置...') def __delete__(self, instance): print('Int删除...') class People: name=Str() age=Int() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #何地？：定义成另外一个类的类属性 #何时？：且看下列演示 p1=People('alex',18) #描述符Str的使用 p1.name p1.name='egon' del p1.name #描述符Int的使用 p1.age p1.age=18 del p1.age #我们来瞅瞅到底发生了什么 print(p1.__dict__) print(People.__dict__) #补充 print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的 print(type(p1).__dict__ == People.__dict__) 描述符应用之何时?何地? 3 描述符分两种 一 数据描述符:至少实现了__get__()和__set__() 1 class Foo: 2 def __set__(self, instance, value): 3 print('set') 4 def __get__(self, instance, owner): 5 print('get') 二 非数据描述符:没有实现__set__() 1 class Foo: 2 def __get__(self, instance, owner): 3 print('get') 4 注意事项: 一 描述符本身应该定义成新式类,被代理的类也应该是新式类 二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中 三 要严格遵循该优先级,优先级由高到底分别是 1.类属性 2.数据描述符 3.实例属性 4.非数据描述符 5.找不到的属性触发__getattr__() 类属性\u003e数据描述符 #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典 #那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错 People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__() People.name='egon' #那赋值呢,我去,并没有触发__set__() del People.name #赶紧试试del,我去,也没有触发__delete__() #结论:描述符对类没有作用--------\u003e傻逼到家的结论 ''' 原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级 People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__() People.name='egon' #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__() del People.name #同上 ''' 数据描述符\u003e实例属性 #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age p1=People('egon',18) #如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性 p1.name='egonnnnnn' p1.name print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看/赋值/删除都是跟描述符有关,与实例无关了 del p1.name 数据描述符\u003e实例属性 实例属性\u003e非数据描述符 class Foo: def func(self): print('我胡汉三又回来了') f1=Foo() f1.func() #调用类的方法,也可以说是调用非数据描述符 #函数是一个非数据描述符对象(一切皆对象么) print(dir(Foo.func)) print(hasattr(Foo.func,'__set__')) print(hasattr(Foo.func,'__get__')) print(hasattr(Foo.func,'__delete__')) #有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了 #笨蛋哥,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么 #函数就是一个由非描述符类实例化得到的对象 #没错，字符串也一样 f1.func='这是实例属性啊' print(f1.func) del f1.func #删掉了非数据 f1.func() 实例属性\u003e非数据描述符 再次验证：实例属性\u003e非数据描述符 class Foo: def __set__(self, instance, value): print('set') def __get__(self, instance, owner): print('get') class Room: name=Foo() def __init__(self,name,width,length): self.name=name self.width=width self.length=length #name是一个数据描述符,因为name=Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级 #对实例的属性操作,触发的都是描述符的 r1=Room('厕所',1,1) r1.n","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:6:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"六 再看property 一个静态属性property本质就是实现了get，set，delete三种方法 用法一 class Foo: @property def AAA(self): print('get的时候运行我啊') @AAA.setter def AAA(self,value): print('set的时候运行我啊') @AAA.deleter def AAA(self): print('delete的时候运行我啊') #只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter f1=Foo() f1.AAA f1.AAA='aaa' del f1.AAA 用法一 用法二 class Foo: def get_AAA(self): print('get的时候运行我啊') def set_AAA(self,value): print('set的时候运行我啊') def delete_AAA(self): print('delete的时候运行我啊') AAA=property(get_AAA,set_AAA,delete_AAA) #内置property三个参数与get,set,delete一一对应 f1=Foo() f1.AAA f1.AAA='aaa' del f1.AAA 怎么用？ 案例一 class Goods: def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price obj = Goods() obj.price # 获取商品价格 obj.price = 200 # 修改商品原价 print(obj.price) del obj.price # 删除商品原价 案例一 案例二 #实现类型检测功能 #第一关： class People: def __init__(self,name): self.name=name @property def name(self): return self.name # p1=People('alex') #property自动实现了set和get方法属于数据描述符,比实例属性优先级高,所以你这面写会触发property内置的set,抛出异常 #第二关：修订版 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------\u003e') return self.DouNiWan @name.setter def name(self,value): print('set------\u003e') self.DouNiWan=value @name.deleter def name(self): print('delete------\u003e') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 print(p1.name) print(p1.name) print(p1.name) print(p1.__dict__) p1.name='egon' print(p1.__dict__) del p1.name print(p1.__dict__) #第三关:加上类型检查 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------\u003e') return self.DouNiWan @name.setter def name(self,value): print('set------\u003e') if not isinstance(value,str): raise TypeError('必须是字符串类型') self.DouNiWan=value @name.deleter def name(self): print('delete------\u003e') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 p1.name=1 案例二 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:7:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"七 setitem,__getitem,delitem class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): self.__dict__[key]=value def __delitem__(self, key): print('del obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('del obj.key时,我执行') self.__dict__.pop(item) f1=Foo('sb') f1['age']=18 f1['age1']=19 del f1.age1 del f1['age'] f1['name']='alex' print(f1.__dict__) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:8:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"八 str,repr,format 改变对象的字符串显示__str__,repr 自定制格式化字符串__format__ #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' format_dict={ 'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型 'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址 'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名 } class School: def __init__(self,name,addr,type): self.name=name self.addr=addr self.type=type def __repr__(self): return 'School(%s,%s)' %(self.name,self.addr) def __str__(self): return '(%s,%s)' %(self.name,self.addr) def __format__(self, format_spec): # if format_spec if not format_spec or format_spec not in format_dict: format_spec='nat' fmt=format_dict[format_spec] return fmt.format(obj=self) s1=School('oldboy1','北京','私立') print('from repr: ',repr(s1)) print('from str: ',str(s1)) print(s1) ''' str函数或者print函数---\u003eobj.__str__() repr或者交互式解释器---\u003eobj.__repr__() 如果__str__没有被定义,那么就会使用__repr__来代替输出 注意:这俩方法的返回值必须是字符串,否则抛出异常 ''' print(format(s1,'nat')) print(format(s1,'tna')) print(format(s1,'tan')) print(format(s1,'asfdasdffd')) 自定义format练习 date_dic={ 'ymd':'{0.year}:{0.month}:{0.day}', 'dmy':'{0.day}/{0.month}/{0.year}', 'mdy':'{0.month}-{0.day}-{0.year}', } class Date: def __init__(self,year,month,day): self.year=year self.month=month self.day=day def __format__(self, format_spec): if not format_spec or format_spec not in date_dic: format_spec='ymd' fmt=date_dic[format_spec] return fmt.format(self) d1=Date(2016,12,29) print(format(d1)) print('{:mdy}'.format(d1)) 自定义format练习 issubclass和isinstance #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class A: pass class B(A): pass print(issubclass(B,A)) #B是A的子类,返回True a1=A() print(isinstance(a1,A)) #a1是A的实例 issubclass和isinstance ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:9:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"九 __slots__ __slots__使用 ''' 1.__slots__是什么:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性) 2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的) 3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__ 当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个 字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给 实例添加新的属性了,只能使用在__slots__中定义的那些属性名。 4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该 只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。 关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。 更多的是用来作为一个内存优化工具。 ''' class Foo: __slots__='x' f1=Foo() f1.x=1 f1.y=2#报错 print(f1.__slots__) #f1不再有__dict__ class Bar: __slots__=['x','y'] n=Bar() n.x,n.y=1,2 n.z=3#报错 __slots__使用 刨根问底 class Foo: __slots__=['name','age'] f1=Foo() f1.name='alex' f1.age=18 print(f1.__slots__) f2=Foo() f2.name='egon' f2.age=19 print(f2.__slots__) print(Foo.__dict__) #f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存 刨根问底 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:10:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十 __next__和__iter__实现迭代器协议 简单示范 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class Foo: def __init__(self,x): self.x=x def __iter__(self): return self def __next__(self): n=self.x self.x+=1 return self.x f=Foo(3) for i in f: print(i) 简单示范 class Foo: def __init__(self,start,stop): self.num=start self.stop=stop def __iter__(self): return self def __next__(self): if self.num \u003e= self.stop: raise StopIteration n=self.num self.num+=1 return n f=Foo(1,5) from collections import Iterable,Iterator print(isinstance(f,Iterator)) for i in Foo(1,5): print(i) 练习：简单模拟range，加上步长 class Range: def __init__(self,n,stop,step): self.n=n self.stop=stop self.step=step def __next__(self): if self.n \u003e= self.stop: raise StopIteration x=self.n self.n+=self.step return x def __iter__(self): return self for i in Range(1,7,3): # print(i) 练习：简单模拟range，加上步长 斐波那契数列 class Fib: def __init__(self): self._a=0 self._b=1 def __iter__(self): return self def __next__(self): self._a,self._b=self._b,self._a + self._b return self._a f1=Fib() print(f1.__next__()) print(next(f1)) print(next(f1)) for i in f1: if i \u003e 100: break print('%s ' %i,end='') ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:11:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十一 __doc__ 它类的描述信息 class Foo: \"\"\"我是描述信息\"\"\" pass print(Foo.__doc__) 该属性无法被继承 class Foo: '我是描述信息' pass class Bar(Foo): pass print(Bar.__doc__) #该属性无法继承给子类 该属性无法被继承 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:12:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十二 __module__和__class__ __module__ 表示当前操作的对象在那个模块 __class__ 表示当前操作的对象的类是什么 lib/aa.py class C: def __init__(self): self.name = \"sb\" index.py from lib.aa import C obj = C() print obj._module__ # 输出 lib.aa, 即输出模块 print obj.__class__ # 输出 lib.aa.C 即输出类 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:13:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十三 __del__ 析构方法，当对象在内存中被释放时，自动触发执行。 注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__ 简单示范 class Foo: def __del__(self): print('执行我啦') f1=Foo() del f1 print('-------\u003e') #输出结果 执行我啦 -------\u003e 挖坑埋了你 class Foo: def __del__(self): print('执行我啦') f1=Foo() # del f1 print('-------\u003e') #输出结果 -------\u003e 执行我啦 #为何啊？？？ 典型的应用场景： 创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中 当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源 这与文件处理是一个道理： f=open('a.txt') #做了两件事，在用户空间拿到一个f变量，在操作系统内核空间打开一个文件 del f #只回收用户空间的f，操作系统的文件还处于打开状态 #所以我们应该在del f之前保证f.close()执行,即便是没有del，程序执行完毕也会自动del清理资源，于是文件操作的正确用法应该是 f=open('a.txt') 读写... f.close() 很多情况下大家都容易忽略f.close,这就用到了with上下文管理 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:14:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十四 __enter__和__exit__ 我们知道在操作文件对象的时候可以这么写 1 with open('a.txt') as f: 2 '代码块' 上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明__enter__和__exit__方法 上下文管理协议 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') # return self def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') with Open('a.txt') as f: print('=====\u003e执行代码块') # print(f,f.name) 上下文管理协议 __exit__()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) with Open('a.txt') as f: print('=====\u003e执行代码块') raise AttributeError('***着火啦,救火啊***') print('0'*100) #-------------------------------\u003e不会执行 如果__exit__()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) return True with Open('a.txt') as f: print('=====\u003e执行代码块') raise AttributeError('***着火啦,救火啊***') print('0'*100) #-------------------------------\u003e会执行 练习：模拟Open class Open: def __init__(self,filepath,mode='r',encoding='utf-8'): self.filepath=filepath self.mode=mode self.encoding=encoding def __enter__(self): # print('enter') self.f=open(self.filepath,mode=self.mode,encoding=self.encoding) return self.f def __exit__(self, exc_type, exc_val, exc_tb): # print('exit') self.f.close() return True def __getattr__(self, item): return getattr(self.f,item) with Open('a.txt','w') as f: print(f) f.write('aaaaaa') f.wasdf #抛出异常，交给__exit__处理 练习：模拟Open 用途或者说好处： 1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处 十五 call 对象后面加括号，触发执行。 注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()() class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__ obj() # 执行 __call__ [toc] ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:15:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"一 反射 在Python中，反射指的是通过字符串来操作对象的属性，涉及到四个内置函数的使用（Python中一切皆对象，类和对象都可以用下述四个方法） class Teacher: def __init__(self,full_name): self.full_name =full_name t=Teacher('Egon Lin') # hasattr(object,'name') hasattr(t,'full_name') # 按字符串'full_name'判断有无属性t.full_name # getattr(object, 'name', default=None) getattr(t,'full_name',None) # 等同于t.full_name,不存在该属性则返回默认值None # setattr(x, 'y', v) setattr(t,'age',18) # 等同于t.age=18 # delattr(x, 'y') delattr(t,'age') # 等同于del t.age 基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行 \u003e\u003e\u003e class FtpServer: ... def serve_forever(self): ... while True: ... inp=input('input your cmd\u003e\u003e: ').strip() ... cmd,file=inp.split() ... if hasattr(self,cmd): # 根据用户输入的cmd，判断对象self有无对应的方法属性 ... func=getattr(self,cmd) # 根据字符串cmd，获取对象self对应的方法属性 ... func(file) ... def get(self,file): ... print('Downloading %s...' %file) ... def put(self,file): ... print('Uploading %s...' %file) ... \u003e\u003e\u003e server=FtpServer() \u003e\u003e\u003e server.serve_forever() input your cmd\u003e\u003e: get a.txt Downloading a.txt... input your cmd\u003e\u003e: put a.txt Uploading a.txt... ","date":"2017-03-01","objectID":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/:1:0","tags":["反射","面向对象"],"title":"python 反射及内置方法","uri":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"二 内置方法 Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。 __str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型 \u003e\u003e\u003e class People: ... def __init__(self,name,age): ... self.name=name ... self.age=age ... def __str__(self): ... return '\u003cName:%s Age:%s\u003e' %(self.name,self.age) #返回类型必须是字符串 ... \u003e\u003e\u003e p=People('lili',18) \u003e\u003e\u003e print(p) #触发p.__str__()，拿到返回值后进行打印 \u003cName:lili Age:18\u003e __del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作 class MySQL: def __init__(self,ip,port): self.conn=connect(ip,port) # 伪代码，发起网络连接，需要占用系统资源 def __del__(self): self.conn.close() # 关闭网络连接，回收系统资源 obj=MySQL('127.0.0.1',3306) # 在对象obj被删除时，自动触发obj.__del__() [toc] ","date":"2017-03-01","objectID":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/:2:0","tags":["反射","面向对象"],"title":"python 反射及内置方法","uri":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"一 绑定方法 类中定义的函数分为两大类：绑定方法和非绑定方法 其中绑定方法又分为绑定到对象的对象方法和绑定到类的类方法。 在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@classmethod后，该函数就绑定到了类。 类方法通常用来在__init__的基础上提供额外的初始化实例的方式 # 配置文件settings.py的内容 HOST='127.0.0.1' PORT=3306 # 类方法的应用 import settings class MySQL: def __init__(self,host,port): self.host=host self.port=port @classmethod def from_conf(cls): # 从配置文件中读取配置进行初始化 return cls(settings.HOST,settings.PORT) \u003e\u003e\u003e MySQL.from_conf # 绑定到类的方法 \u003cbound method MySQL.from_conf of \u003cclass ‘__main__.MySQL'\u003e\u003e \u003e\u003e\u003e conn=MySQL.from_conf() # 调用类方法，自动将类MySQL当作第一个参数传给cls 绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆，这也是Python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。 ","date":"2017-02-28","objectID":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/:1:0","tags":["面向对象"],"title":"python 面向对象之 绑定方法与非绑定方法","uri":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"二 非绑定方法 为类中某个函数加上装饰器 @staticmethod 后，该函数就变成了非绑定方法，也称为静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说 import uuid class MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): return uuid.uuid1() \u003e\u003e\u003e conn=MySQL(‘127.0.0.1',3306) \u003e\u003e\u003e print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec # 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法 \u003e\u003e\u003e MySQL.create_id \u003cfunction MySQL.create_id at 0x1025c16a8\u003e \u003e\u003e\u003e conn.create_id \u003cfunction MySQL.create_id at 0x1025c16a8\u003e 总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。 ","date":"2017-02-28","objectID":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/:2:0","tags":["面向对象"],"title":"python 面向对象之 绑定方法与非绑定方法","uri":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"继承的定义 继承是创建新类的一种方式, 这种方式解决了 代码冗余的问题. 在python中, 子类可以继承多个父类. 父类又称之为 “基类” 或 “超类” 在其他语言中, 子类只能继承一个父类. # 父类1 class Father1: pass # 父类2 class Father2: pass # 子类-- 单继承 class Son(Father1): pass # 子类 多继承 class Son2(Father1, Father2): pass son_obj = Son() ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:1:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"查看继承. 是调用类的__bases__ 方法查看所继承的父类. print(Son2.__bases__) # 输出结果 (\u003cclass '__main__.Father1'\u003e, \u003cclass '__main__.Father2'\u003e) 返回的结果是一个元组, 包晗父类的信息 ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:2:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"经典类与新式类. 什么是经典类, 什么是新式类? object 是python3 中所有类的几类 , 它提供给了一些常见的方法入 __str__ ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"新式类 在python中, 所有继承object的 子类都属于新式类 python3 中所有的类都属于新式类, 默认全部继承object ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"经典类 所有没有继承object类的, 都属于经典类. 经典类只有在python2 中才有, ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:2","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"抽象与继承 要想找到子类与父类之间的关系, 需要先进行抽象, 然后在类中找到相同的部分, 抽象成父类. 类是由对象进行抽象, 找到对象之间的相同的关系, 然后抽象成类. 父类是由类进行抽象, 找到类之间的相同关系, 然后抽象成父类 ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:4:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"继承与重用性 请先看下面例子 class OldboyStudent: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def choose_course(self): pass class OldboyTeacher(): school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def score(self): pass 两个类中, 都有相同的代码, 这样的话, 就会代码冗余 两个类之中都有相同的部分, 那么就可以抽象出来一个父类 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyStudent: def choose_course(self): pass class OldboyTeacher(): def score(self): pass 在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时 我们不可能从头开始写一个类B，这就用到了类的继承的概念。 通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用 ==提示：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大减少了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.== ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:5:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"属性查找 重点 class Foo: def f1(self): print('Foo.f1') def f2(self): print('Foo.f2') self.f1() class Bar(Foo): def f1(self): print('Foo.f1') b=Bar() b.f2() 属性的查找 是先从对象的名称空间中查找, 然后再找子类. ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:5:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"派生 当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。 以下为例. 当老师有自己的独有属性. 例如 老师有自己的工资, 那么就可以按照下面的方式进行修改 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): self.name = name self.age = age self.sex = sex self.sal = sal def score(self): pass 但是有一个问题, 子类和父类都有很多的重复代码. 这样代码仍然很冗余. 如何解决这个问题呢? ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"解决重用的代码冗余. 方案1 重用父类的__init__的方法 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): OldboyPeople.__init__(self, name, age, sex) self.sal = sal def score(self): pass 这种方法和调用类内的函数一样, 此时的__init__ 就是一个普通的函数, 使用的时候, 要将 self 传入. 方案2 使用super() super类是个特殊类, 调用此类可以直接指向父类的名称空间, 即, 在super().父类方法. 并且 不需要再手动传入 对象, 即self class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): super().__init__(name, age, sex) self.sal = sal def score(self): pass ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"菱形继承(钻石继承) python3 中, 新式类是以广度优先. python2 中, 经典类是以深度优先 [toc] ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:2","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"组合 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"什么是组合? 在一个类中, 以另外一个类的对象作为数据属性, 称之为组合 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:1","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"组合有什么用? 组合与继承都是用来解决代码的重用性问题 继承是一种\"是\"的关系. 例如, 老师是人, 学生也是人 都有, 名字, 年龄 性别 组合是一种 “有” 的关系, ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:2","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"怎么用组合? 看下面代码 # 示例 class People: def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class Teacher(People): def __init__(self, name, age, sex,): super().__init__(name, age, sex, ) self.course = [] def add_course(self, course): self.course.append(course) def show_course(self): for line in self.course: print(line.c_name, line.c_price, line.c_cycle) class Course: def __init__(self, c_name, c_price, c_cycle): self.c_name = c_name self.c_price = c_price self.c_cycle = c_cycle # 实例化处一个 python课程 python_obj = Course(\"python\", 22000, \"6 mon\") # 将python课程 关联到 老师对象中 tea1 = Teacher(\"七里塘\", 18, \"male\") tea1.add_course(python_obj) # 查看组合内对象的属性 # print(tea1.course[0].c_name) # 为了便于查看, 需要在类内定义方法. tea1.show_course() ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:2:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"封装 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"1. 什么是封装 解释1: 封装就是将一堆属性即方法封装起来. 1: 定义类的过程就是封装, 由类产生对象,就是讲对象的属性和方法封装进对象体内. 解释2: 也有说 在类内 定义属性和方法时 使用__属性/方法名 这种方式是封装. 2: 这种方式, 遵循的是 在对象内部属性的使用是开放的, 在对象外部使用内部属性或方法是封闭的 为什么用封装? 可以通过 “对象.” 的方式 “存放/获取” 属性或方法。 对象拥有 “.” 的机制。 方便数据的存取。 如何进行封装, 在定义类的时候, 就进行了封装 \"\"\" 示例 class User: x = 10 def __init__(self): pass ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:1","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"访问限制机制: 什么是访问限制机制: 在创建类的时候, 定义类内部的 属性和方法是, 使用__ 开头, 凡是以__开头的属性/方法,都会被限制, 外部不能直接访问 ==注意: 凡是在类内部定义__开头的属性或方法，都会变形为 _类名__属性/方法。== 为什么要用 访问限制机制? 将一些隐私数据隐藏起来, 不让外部轻易获取 如何实现? # 示例1 class User: _name = \"王大\" def tell_name(self): print(self._name) obj = User() # 直接用.属性名 方法 会找不到, # print(obj.__name) \"\"\" Traceback (most recent call last): File \"D:/Python_study/Project/oldboy/day22/封装.py\", line 55, in \u003cmodule\u003e print(obj.__name) AttributeError: 'User' object has no attribute '__name' \"\"\" # 所以只能通过接口调用 # obj.tell_name() ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:2","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"什么是property property 是将类中的方法, 伪装成属性的方法. [toc] ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:3","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"面向对象编程 我们以前已经学了面向过程编程思想. 那什么是面向对象编程呢? 首先我们要搞明白 什么是对象, 然后才能去了解什么是面向对象编程. ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:0:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"对象的概念 面向对象的核心是 “对象” 二字, 而对象的精髓在于 “整合”, 即 对象是 “特征与技能\"的结合体. 要了解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。 面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的数据属性和方法属性），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙交互着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取),对象是特征与技能的结合体，基于面向对象设计程序就好比在创造一个世界，你就是这个世界的上帝，存在的皆为对象，不存在的也可以创造出来，与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界的模拟，是一种“上帝式”的思维方式。 优点: 解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 缺点: 编程的复杂度远高于面向过程，不了解面向对象而立即上手基于它设计程序，极容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会徒增编程难度，比如管理linux系统的shell脚本就不适合用面向对象去设计，面向过程反而更加适合。 无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法准确地预测最终结果。于是我们经常看到对战类游戏，新增一个游戏人物，在对战的过程中极容易出现阴霸的技能，一刀砍死3个人，这种情况是无法准确预知的，只有对象之间交互才能准确地知道最终的结果。 应用场景: 需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方 面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:1:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"类与对象 类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列对象相似的特征与技能的结合体 在现实世界中：先有对象，再有类 世界上肯定是先出现各种各样的实际存在的物体，然后随着人类文明的发展，人类站在不同的角度总结出了不同的种类，如人类、动物类、植物类等概念 也就说，对象是具体的存在，而类仅仅只是一个概念，并不真实存在 在程序中：务必保证先定义类，后产生对象 这与函数的使用是类似的，先定义函数，后调用函数，类也是一样的，在程序中需要先定义类，后调用类 不一样的是，调用函数会执行函数体代码返回的是函数体执行的结果，而调用类会产生对象，返回的是对象 #在现实世界中，站在老男孩学校的角度：先有对象，再有类 对象1：李坦克 特征: 学校=oldboy 姓名=李坦克 性别=男 年龄=18 技能： 学习 吃饭 睡觉 对象2：王大炮 特征: 学校=oldboy 姓名=王大炮 性别=女 年龄=38 技能： 学习 吃饭 睡觉 对象3：牛榴弹 特征: 学校=oldboy 姓名=牛榴弹 性别=男 年龄=78 技能： 学习 吃饭 睡觉 现实中的老男孩学生类 相似的特征: 学校=oldboy 相似的技能： 学习 吃饭 睡觉 在现实世界中：先有对象，再有类 在程序中，务必保证：先定义（类），后使用（产生对象） PS: 1. 在程序中特征用变量标识，技能用函数标识 2. 因而类中最常见的无非是：变量和函数的定义 #程序中的类 class OldboyStudent: school='oldboy' def learn(self): print('is learning') def eat(self): print('is eating') def sleep(self): print('is sleeping') #注意： 1.类中可以有任意python代码，这些代码在类定义阶段便会执行 2.因而会产生新的名称空间，用来存放类的变量名与函数名，可以通过OldboyStudent.__dict__查看 3.对于经典类来说我们可以通过该字典操作类名称空间的名字（新式类有限制），但python为我们提供专门的.语法 4.点是访问属性的语法，类中定义的名字，都是类的属性 #程序中类的用法 .:专门用来访问属性，本质操作的就是__dict__ OldboyStudent.school #等于经典类的操作OldboyStudent.__dict__['school'] OldboyStudent.school='Oldboy' #等于经典类的操作OldboyStudent.__dict__['school']='Oldboy' OldboyStudent.x=1 #等于经典类的操作OldboyStudent.__dict__['x']=1 del OldboyStudent.x #等于经典类的操作OldboyStudent.__dict__.pop('x') #程序中的对象 #调用类，或称为实例化，得到对象 s1=OldboyStudent() s2=OldboyStudent() s3=OldboyStudent() #如此，s1、s2、s3都一样了，而这三者除了相似的属性之外还各种不同的属性，这就用到了__init__ #注意：该方法是在对象产生之后才会执行，只用来为对象进行初始化操作，可以有任意代码，但一定不能有返回值 class OldboyStudent: ...... def __init__(self,name,age,sex): self.name=name self.age=age self.sex=sex ...... s1=OldboyStudent('李坦克','男',18) #先调用类产生空对象s1，然后调用OldboyStudent.__init__(s1,'李坦克','男',18) s2=OldboyStudent('王大炮','女',38) s3=OldboyStudent('牛榴弹','男',78) #程序中对象的用法 #执行__init__,s1.name='牛榴弹'，很明显也会产生对象的名称空间 s2.__dict__ {'name': '王大炮', 'age': '女', 'sex': 38} s2.name #s2.__dict__['name'] s2.name='王三炮' #s2.__dict__['name']='王三炮' s2.course='python' #s2.__dict__['course']='python' del s2.course #s2.__dict__.pop('course') 在程序中：先定义类，后产生对象 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:2:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"！！！细说__init__方法！！！ #方式一、为对象初始化自己独有的特征 class People: country='China' x=1 def run(self): print('-----\u003e', self) # 实例化出三个空对象 obj1=People() obj2=People() obj3=People() # 为对象定制自己独有的特征 obj1.name='egon' obj1.age=18 obj1.sex='male' obj2.name='lxx' obj2.age=38 obj2.sex='female' obj3.name='alex' obj3.age=38 obj3.sex='female' # print(obj1.__dict__) # print(obj2.__dict__) # print(obj3.__dict__) # print(People.__dict__) #方式二、为对象初始化自己独有的特征 class People: country='China' x=1 def run(self): print('-----\u003e', self) # 实例化出三个空对象 obj1=People() obj2=People() obj3=People() # 为对象定制自己独有的特征 def chu_shi_hua(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z chu_shi_hua(obj1,'egon',18,'male') chu_shi_hua(obj2,'lxx',38,'female') chu_shi_hua(obj3,'alex',38,'female') #方式三、为对象初始化自己独有的特征 class People: country='China' x=1 def chu_shi_hua(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z def run(self): print('-----\u003e', self) obj1=People() # print(People.chu_shi_hua) People.chu_shi_hua(obj1,'egon',18,'male') obj2=People() People.chu_shi_hua(obj2,'lxx',38,'female') obj3=People() People.chu_shi_hua(obj3,'alex',38,'female') # 方式四、为对象初始化自己独有的特征 class People: country='China' x=1 def __init__(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z def run(self): print('-----\u003e', self) obj1=People('egon',18,'male') #People.__init__(obj1,'egon',18,'male') obj2=People('lxx',38,'female') #People.__init__(obj2,'lxx',38,'female') obj3=People('alex',38,'female') #People.__init__(obj3,'alex',38,'female') # __init__方法 # 强调： # 1、该方法内可以有任意的python代码 # 2、一定不能有返回值 class People: country='China' x=1 def __init__(obj, name, age, sex): #obj=obj1,x='egon',y=18,z='male' # if type(name) is not str: # raise TypeError('名字必须是字符串类型') obj.name = name obj.age = age obj.sex = sex def run(self): print('-----\u003e', self) # obj1=People('egon',18,'male') obj1=People(3537,18,'male') # print(obj1.run) # obj1.run() #People.run(obj1) # print(People.run) ！！！__init__方法之为对象定制自己独有的特征 PS~~ 1. 站的角度不同，定义出的类是截然不同的，详见面向对象实战之需求分析 2. 现实中的类并不完全等于程序中的类，比如现实中的公司类，在程序中有时需要拆分成部门类，业务类…… 3. 有时为了编程需求，程序中也可能会定义现实中不存在的类，比如策略类，现实中并不存在，但是在程序中却是一个很常见的类 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"类的特殊属性(了解即可) #python为类内置的特殊属性 类名.__name__# 类的名字(字符串) 类名.__doc__# 类的文档字符串 类名.__base__# 类的第一个父类(在讲继承时会讲) 类名.__bases__# 类所有父类构成的元组(在讲继承时会讲) 类名.__dict__# 类的字典属性 类名.__module__# 类定义所在的模块 类名.__class__# 实例对应的类(仅新式类中) ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:1","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"time 模块 time 模块是内置时间模块 time.time() 是当前时间戳 返回的是float 类型的时间 是从1970 年一月一号到现在的秒数 格式化时间输出 time.strftime() 格式化时间输出 传入格式 %Y Year with century as a decimal number. %m Month as a decimal number [01,12]. %d Day of the month as a decimal number [01,31]. %H Hour (24-hour clock) as a decimal number [00,23]. %M Minute as a decimal number [00,59]. %S Second as a decimal number [00,61]. %z Time zone offset from UTC. %a Locale's abbreviated weekday name. %A Locale's full weekday name. %b Locale's abbreviated month name. %B Locale's full month name. %c Locale's appropriate date and time representation. %I Hour (12-hour clock) as a decimal number [01,12]. %p Locale's equivalent of either AM or PM. 时间对象获取 obj = time.localtime() 获取时间对象 print(obj) # 得到结果 time.struct_time(tm_year=2019, tm_mon=11, tm_mday=17, tm_hour=21, tm_min=39, tm_sec=48, tm_wday=6, tm_yday=321, tm_isdst=0) 可以从时间对象中 获取指定的数据. 获取时间对象的格式化时间, 可以是未来/过去的时间对象 获取当前格式化时间 print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()) # 个人感觉这是脱了裤子放屁, 多此一举 在strftime内第二个参数, 可以传入之前的时间对象, 把此过去/未来的时间对象格式化 字符串格式时间转换为时间对象 res = time.strptime('2018-12-13', '%Y:%m:%d') 这个返回值就是时间对象, 两个参数, 第一个是字符串时间格式, 第二个是格式化时间样式, 返回值是此格式化时间的对象 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"datatime 模块 # 获取当前年月日 obj_data = datetime.date.today() # 获取当前年月日,时分秒 obj_datatime = datatime.datatime() # 两者得到的都是时间对象, 可以分别取出 年, 月, 日, 时, 分, 秒 obj_datatime.weekday() 计算今天是周几 时区 # 获取当前时区的时间 datetime.datetime.now() # 获取UTC时间(格林尼治) datetime.datetime.utcnow() 日期/时间计算 # 首先获取时间对象. obj_time = datatime.timedelta(7) # 默认 是天 # 可以指定 week, mount等 # 获取日期时间 current_date = datetime.datetime.now() 日期时间 = 日期时间 +/- 时间对象 时间对象 = 日期时间 +/- 日期时间 获取七天后时间 later_time = current_time + time_obj ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"random 随机模块 random.random() 随机0-1之间的浮点数 random.randomint(n,m) n,m 之间的整数 random.choice(可迭代对象) 随机取出可迭代对象的一个元素 random.shuffle(可迭代对象), 对可迭代对象中的元素乱序 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"os 模块 和操作系统交互 # 获取当前执行文件的目录 os.path.dirname(__file__) # 路径要用常量 # 进行路径拼接 os.path.join(路径,字符串) # 判断“文件/文件夹”是否存在：若文件存在返回True，若不存在返回False os.path.exists(路径) # 判断是否是文件夹 True/False os.path.isdir(路径) # 创建文件夹 os.mkdir(路径) # 删除空文件夹 os.rmdir(路径) # 获取某个文件夹类所有文件的名字 os.listdir(路径) # 获取可迭代对象的索引即元素的对应关系, 对象有一个个的元组(索引, 元素) enumerate(可迭代对象) ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:4:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"sys 模块 # 获取当前python解释器的环境变量路径 sys.path # 将当前项目添加到环境变量中 BASE_PATH = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_PATH) # 获取cmd终端的命令行 python3 py文件 用户名 密码 print(sys.argv) # 返回的是列表[''] ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"hashlib 加密模块 内置很多算法, 常用的是MD5 # 首先实例化 一个对象 m = hashlib.md5() m.update(bytes 类型的字符串) res = m.hexdigest() # res 是经过加密算法得到的32位的位字符串. 可以对密码进行加盐处理 略过 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"序列化 序列化 我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"为什么要序列化? 1：持久保存状态 需知一个软件/程序的执行就在处理一系列状态的变化，在编程语言中，‘状态’会以各种各样有结构的数据类型(也可简单的理解为变量)的形式被保存在内存中。 内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。 在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。 具体的来说，你玩使命召唤闯到了第13关，你保存游戏状态，关机走人，下次再玩，还能从上次的位置开始继续闯关。或如，虚拟机状态的挂起等。 2：跨平台数据交互 序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:1","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"json \u0026 pickle 序列化 json 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： import json dic={'name':'alvin','age':23,'sex':'male'} print(type(dic))#\u003cclass 'dict'\u003e j=json.dumps(dic) print(type(j))#\u003cclass 'str'\u003e f=open('序列化对象','w') f.write(j) #-------------------等价于json.dump(dic,f) f.close() #-----------------------------反序列化\u003cbr\u003e import json f=open('序列化对象') data=json.loads(f.read())# 等价于data=json.load(f) 注意 import json #dct=\"{'1':111}\"#json 不认单引号 #dct=str({\"1\":111})#报错,因为生成的数据还是单引号:{'one': 1} dct='{\"1\":\"111\"}' print(json.loads(dct)) #conclusion: # 无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads 注意点 import pickle dic={'name':'alvin','age':23,'sex':'male'} print(type(dic))#\u003cclass 'dict'\u003e j=pickle.dumps(dic) print(type(j))#\u003cclass 'bytes'\u003e f=open('序列化对象_pickle','wb')#注意是w是写入str,wb是写入bytes,j是'bytes' f.write(j) #-------------------等价于pickle.dump(dic,f) f.close() #-------------------------反序列化 import pickle f=open('序列化对象_pickle','rb') data=pickle.loads(f.read())# 等价于data=pickle.load(f) print(data['age']) Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:2","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"collections 模块 python默认八大数据: - 整型 - 浮点型 - 字符串 - 字典 - 元组 - 列表 - 集合 - 布尔 collections模块: 提供一些python八大数据类型 “以外的数据类型” 。 具名元组: 具名元组 只是一个名字。 应用场景: - 坐标 - ``` from collections import namedtuple``` 有序字典: python中字典默认是无序 collections中提供了有序的字典 from collections import OrderedDict 示例 # 具名元组 from collections import namedtuple # 传入可迭代对象是有序的 # 应用:坐标 # 将'坐标'变成 “对象” 的名字 point = namedtuple('坐标', ['x', 'y']) # 第二个参数既可以传可迭代对象 point = namedtuple('坐标', ('x', 'y')) # 第二个参数既可以传可迭代对象 point = namedtuple('坐标', 'x y') # 第二个参数既可以传可迭代对象 # 会将 1 ---\u003e x, 2 ---\u003e y # 传参的个数，要与namedtuple第二个参数的个数一一对应 p = point(1, 3) # 本质上传了4个，面向对象讲解 print(p) print(type(p)) ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"openpyxl 模块 openpyxl模块：第三方模块 - 可以对Excle表格进行操作的模块 - 下载: pip3 install openpyxl - Excel版本: 2003之前: excle名字.xls 2003以后: excle名字.xlsx - 清华源: https://pypi.tuna.tsinghua.edu.cn/simple - 配置永久第三方源: D:\\Python36\\Lib\\site-packages\\pip\\_internal\\models\\index.py 示例 # 写入数据 from openpyxl import Workbook # 获取Excel文件对象 wb_obj = Workbook() wb1 = wb_obj.create_sheet('python13期工作表1', 1) wb2 = wb_obj.create_sheet('python13期工作表2', 2) # 修改工作表名字: 为python13期工作表1标题修改名字 ---》 tank大宝贝 print(wb1.title) wb1.title = 'tank大宝贝' print(wb1.title) # 为第一张工作表添加值 # wb1['工作簿中的表格位置'] wb1['A10'] = 200 wb1['B10'] = 1000 wb1['C10'] = '=SUM(A10:B10)' wb2['A1'] = 100 # 生成Excel表格 wb_obj.save('python13期.xlsx') print('excel表格生成成功') 读取数据 # 读取数据 from openpyxl import load_workbook wb_obj = load_workbook('python13期.xlsx') print(wb_obj) # # wb_obj['表名'] wb1 = wb_obj['tank大宝贝'] print(wb1['A10'].value) wb1['A10'] = 20 print(wb1['A10'].value) [toc] ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:1","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"subprocess 模块 用于和系统的cmd 终端进行交互. 方法比较简单 import subprocess while True: cmd = input(\"\u003e\u003e:\").strip() # 输入终端命令字符串 res = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 参数介绍. 传入命令字符串, shell = True , 打开 cmd 终端功能 stderr 接收命令错误的信息 stdout 接收命令正确的返回信息 实例化对象用stdout.read() 方法接收信息 print(res.stdout.read().decode(\"gbk\")) res.stderr.read() ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"re模块. 一：什么是正则？ 正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。 字符组: - [0-9] 可以匹配到一个0-9的字符 - [9-0]: 报错, 必须从小到大 - [a-z]: 从小写的a-z - [A-Z]: 从大写A-Z - [z-A]: 错误, 只能从小到大，根据ascii表来匹配大小。 - [A-z]: 总大写的A到小写的z。 注意: 顺序必须要按照ASCII码数值的顺序编写。 - [^...]: 表示取反的意思。 - [^ab]: 代表只去ab以外的字符。 - [^a-z]: 取a-z以外的字符。 re 模块较重要的方法: re模块三种比较重要的方法: - findall()： ----\u003e [] 可以匹配 \"所有字符\" ，拿到返回的结果，返回的结果是一个列表。 'awfwaghowiahioawhio' # a ['a', 'a', 'a', 'a'] - search()：----\u003e obj ----\u003e obj.group() 'awfwaghowiahioawhio' # a 在匹配一个字符成功后，拿到结果后结束，不往后匹配。 'a' - match()：----\u003e obj ----\u003e obj.group() 'awfwaghowiahioawhio' # a 'a' 'wfwaghowiahioawhio' # a None 从匹配字符的开头匹配,若开头不是想要的内容，则返回None。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"爬虫四步原理 1.发送请求: requests 2.获取响应数据: 对方机器直接返回的 3.解析并提取想要的数据: re 4.保存提取后的数据: with open() ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:11:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"爬蟲三部曲: 1.发送请求 2.解析数据 3.保存数据 import requests import re import os my_path = os.path.join(os.path.dirname(__file__),\"妹子图\") if not os.path.exists(my_path): os.mkdir(my_path) # 爬虫的四大步骤 \"\"\" 1 . 发送请求, 2 . 接收返回数据 3 . 数据处理 4 . 数据保存 \"\"\" # 返回每个类所有的URL def send_request(url): response = requests.get(url) data = response.text url_data = re.findall('\u003cdiv class=\"boxa\"\u003e \u003ca href=\"//(.*?)\"', data, re.S) data_url = [] for i in url_data: data_url.append(f\"https://{i}\") return data_url def send_url(img_url): response = requests.get(img_url) if response.status_code == 200: data = response.text url_data = re.findall('\u003ca href=\"//(.*?)@!w1200\".*?data-med=', data, re.S) url_data.pop(0) return url_data def save(res, num, url): data_img = requests.get(f\"http://{url}\") with open(f'{my_path}\\{res}{num}.jpg', \"wb\")as f: f.write(data_img.content) list1 = [\"xinggan\",\"qingchun\",\"xiaohua\",\"chemo\",\"qipao\"] if __name__ == '__main__': while True: for num, s in enumerate(list1): print(num,s) res = input(\"请输入要爬取类别序号\u003e\u003e:\").strip() res1 = int(res) res2 = list1[res1] print(\"开始爬取\") url = f\"https://www.plmm.com.cn/{res2}/flow/\" url_data = send_request(url) q = 0 for i in url_data: s = send_url(i) for m in s: save(res,q, m) q +=1 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"loging 模块的使用 loging 配置模板 logging配置 \"\"\" import os import logging.config # 定义三种日志输出格式 开始 standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \\ '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字 simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s' # 定义日志输出格式 结束 # ****************注意1: log文件的目录 BASE_PATH = os.path.dirname(os.path.dirname(__file__)) logfile_dir = os.path.join(BASE_PATH, 'log_dir') # print(logfile_dir) # ****************注意2: log文件名 logfile_name = 'user.log' # 如果不存在定义的日志目录就创建一个 if not os.path.isdir(logfile_dir): os.mkdir(logfile_dir) # log文件的全路径 logfile_path = os.path.join(logfile_dir, logfile_name) # ****************注意3: log配置字典 LOGGING_DIC = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'standard': { 'format': standard_format }, 'simple': { 'format': simple_format }, }, 'filters': {}, 'handlers': { #打印到终端的日志 'console': { 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' }, # 打印到文件的日志,收集info及以上的日志 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'standard', 'filename': logfile_path, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 }, }, 'loggers': { #logging.getLogger(__name__)拿到的logger配置 '': { 'handlers': ['default', 'console'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', 'propagate': True, # 向上（更高level的logger）传递 }, }, } 注意配置 def get_logger(user_type): # 1.加载log配置字典到logging模块的配置中 logging.config.dictConfig(LOGGING_DIC) # 2.获取日志对象 logger = logging.getLogger(user_type) return logger logger = get_logger('user') logger.info('学习不要浮躁，一步一个脚印!') 以上记牢即可 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:13:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"什么是包? 包指的是内部包含__init__.py的文件夹。 包的作用: 存放模块，包可以更好的管理模块。 一 什么是模块？ 模块是一系列功能的结合体。 相当于与模块包着一堆函数与代码。 模块本质上是一个个的.py文件。 模块的三种来源: 1.python内置的模块: (python解释器的) 比如: sys\\time\\os\\turtle 2.第三方的模块: (别人写的) 比如: requests 3.自定义的模块: (自己写的) 比如: 自己定义的demo.py文件 模块的四种表现形式: 1.使用python编写的py文件。（了解） 2.编译后的共享库DLL或者是C或者C++库。（了解） 3.包下面带有__init__.py的一组py文件。 - py_demo - init.py - demo.py - demo2.py 4.python解释器下的py文件。 - python解释器下的文件夹 - 一个个的py文件 二 为什么要使用模块？ 模块可以帮我们更好地管理功能代码，比如: 函数.. 可以将项目拆分成一个个的功能，分别存放在不同的py文件(模块)中。 三 如何创建，编写模块，并使用模块？ 鼠标右键创建py文件 在py文件编写python代码 在一个文件中，通过import关键字导入模块 import 模块名 注意: import 模块时，模块不能加.py后缀 在使用模块阶段，必须要注意，谁是执行文件，谁是被导入文件（被导入的模块） 模块在首次导入时，就已经固定好了，当前文件查找的顺序是先从内存中查找 模块在导入时发生的事情: 1.会先执行当前执行文件，并产生执行文件中的名称空间。 2.当执行到导入模块的代码时，被导入的模块会产生一个模块的名称空间。 3.会将被导入模块的名称空间加载到内存中。 给模块起别名 as import 模块 as 模块的别名 模块的导入方式 import 模块 在执行文件中直接import导入 from 包/模块 import 模块/(函数名、变量名、类名) 在执行文件中直接import导入 循环导入问题: model1.py from model2 import name name = ‘jason’ model2.py from model1 import name name = ’tank' 解决循环导入问题: 1.需要查找的名字放在导入模块的上方 2.在函数内部导入，将模块变成函数名称空间中的名字 软件开发目录规范: 注意: 每一次写项目时，都要新建一个文件夹与项目工程,必须让项目文件夹作为项目根目录。 项目的文件夹 conf: 用于存放配置文件的文件夹 core: 核心业务代码 .py interface: 接口， 接口内写获取数据前的逻辑代码，通过后才能获取数据 db: 用于存放文件数据 lib: 存放公共功能文件 log: 用于存放日志文件，日志用于记录用户的操作记录 bin: 里面存放启动文件 / - 启动文件 readme.txt: 项目说明书, 用户告诉使用者项目的操作 [toc] ","date":"2017-02-16","objectID":"/posts/python-15-%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/:0:0","tags":["包与模块"],"title":"python 包与模块","uri":"/posts/python-15-%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"内置函数 由python提供的函数功能, 就是内置函数, 常见内置函数有以下几种. 本节示例都是和匿名函数连用 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:0:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"max 去一个可迭代对象的最大值 , 是按照 ASCII 码的先后顺序进行比较. 参数: max(可迭代对象, key= 比较对象) 示例1 l = [2, 3, 6, 8, 1, 10] res = max(l) print(res) 示例2 # 要求, 取出薪资最大的人员 dict1 = { 'tank': 1000, 'egon':/ 500, 'sean': 200, 'jason': 500 } res= max(dict1, key = lambda x:dict1[x]) print(res) ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:1:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"min 函数 略过 和max 方法相同, 取最小值. ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:2:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"sorted 方法 排序 将 可迭代对象按照升序进行排列 dict1 = { 'tank': 1000, 'egon': 500, 'sean': 200, 'jason': 500 } # 以 key 进行排序 dict2 = sorted(dict1) print(dict2) # 以 value 进行排序, 这就需要使用到匿名函数 dict2 = sorted(dict1.items(), lambda x:x[1]) # 次函数按照key 在ASCII码顺序进行排列, 返回的是keys 组成的列表 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:3:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"map 映射 参数1 函数对象 参数2 可迭代对象 示例 l = [1, 2, 3, 4] s = map(lambda x:x+2, l) print(s) # 返回值是个 \u003cmap object at 0x000001DF3C878978\u003e \u003c!--用list 取出值--\u003e print(list(s) # [3, 4, 5, 6] ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:4:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"reduce 合并 参数1 函数对象 参数2 可迭代对象 参数3 默认初始值 res = reduce(lambda x, y: x + y, range(1, 101), 0) print(res) # 5050 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:5:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"filter 过滤 参数1 函数对象 参数2 可迭代对象 满足条件的 返回. name_list = ['egon_dsb', 'jason_dsb', 'sean_dsb', '大饼_dsb', 'tank'] filter_obj = filter(lambda name: name.endswith('_dsb'), name_list) print(filter_obj) print(list(filter_obj)) ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:6:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"面向过程编程 面向过程编程是一门编程思想。 面向 过程 编程: 核心是 ‘过程’ 二字，过程 指的是一种解决问题的步骤，即先干什么再干什么 基于该编程思想编写程序，就好比在设计一条工厂流水线，一种机械式的思维方式。 优点: 将复杂的问题流程化，进而简单化 缺点: -若修改当前程序设计的某一部分，会导致他部分同时需要修改， 扩展性差。 ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:1:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"三元表达式 三元表达式: 可以将if…else…分支变成一行。 语法: 条件成立返回左边的值 if 判断条件 else 条件不成立返回右边的值 def func(x, y): res = x if x \u003ey else y return res ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:2:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"列表生成式 可以一行实现生成列表。 语法: list = [取出的每一个值、任意值 for 可迭代对象中取出的每一个值 in 可迭代对象] for的右边是循环次数，并且可以取出可迭代对象中每一个值 for的左边可以为当前列表添加值 list = [值 for 可迭代对象中取出的每一个值 in 可迭代对象] list = [值 for 可迭代对象中取出的每一个值 in 可迭代对象 if 判断] 示例 list1 = [f'1{line}' for line in range(1, 101)] print(list1) ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:3:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"生成器表达式(生成器生成式): 列表生成式: 若数据量小时采用 [line for line in range(1, 6)] —\u003e [1, 2, 3, 4, 5] 优点: 可以依赖于索引取值，取值方便 缺点: 浪费资源 生成器生成式: 若数据量过大时采用 () —\u003e 返回生成器 (line for line in range(1, 6)) —\u003e g生成器(1, 2, 3, 4, 5) 优点: 节省资源 缺点: 取值不方便 # 生成一个有1000个值的生成器 g = (line for line in range(1, 1000001)) # \u003cgenerator object \u003cgenexpr\u003e at 0x00000203262318E0\u003e print(g) # 列表生成式实现 list1 = [line for line in range(1, 1000001)] print(list1) ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:4:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"匿名函数: 无名字的函数 左边是参数， 右边是返回值 lambda : PS: 原因,因为没有名字，函数的调用 函数名 () 匿名函数需要一次性使用。 注意: 匿名函数单独使用毫无意义，它必须配合 “内置函数” 一起使用的才有意义。 有名函数: 有名字的函数 ’’' [toc] ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:5:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"生成器理论 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:0","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"1.什么是生成器？ 生成的工具。 生成器是一个 “自定义” 的迭代器， - 本质上是一个迭代器。 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:1","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"2.如何实现生成器 但凡在函数内部定义了的yield， 调用函数时，函数体代码不会执行， 会返回一个结果，该结果就是一个生成器。 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:2","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"yield: 每一次yield都会往生成器对象中添加一个值。 yield只能在函数内部定义 yield可以保存函数的暂停状态 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:3","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"yield与return: 相同点: 返回值的个数都是无限制的。 不同点: return只能返回一次值，yield可以返回多个值 示例 自定义range def my_range(start, end=None, step=1): if end is None: end = start start = 0 while start \u003c end: yield start start += step for i in my_range(1,11,2): print(i) ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:4","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"什么是迭代器? 迭代器就是用来迭代取值的工具. 迭代 迭代是重复反馈过程的活动, 其目的是为了逼近所需目标或结果, 每一次对过程的重复称之为一次\"迭代\", 而每一次迭代得到的结果会作为下一次迭代的初始值, 单纯的重复不是迭代. 示例1- 非迭代 msg = 1 while True: print(msg) 示例2 迭代 msg = \"w shi ni baba\" index= 0 while index \u003c len(msg): print(msg[index]) index += 1 ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:0","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"可迭代对象 通过索引取值的方法实现很简单, 那么 当遇到没有索引的 集合, 字典时, 我们该怎么办呢? 这我们就需要一种不依赖索引的取值方式, 这就需要用到迭代器. 可迭代对象定义 从语法角度讲, 内置有.iter() 方法的对象都是可迭代对象, 字符串, 列表, 元组, 字典, 集合, 打开的文件, 都是可迭代对象 l = [1, 2, 3, 4,] l.__iter__() 等等 ...... ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:1","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"迭代器对象 可迭代对象调用内置.iter() 方法后返回的对象就是迭代器对象. l = [1, 2, 3, 4,] iter_l = l.__iter__() iter_l 就是迭代器对象. 迭代器对象都有内置的.next()方法 ==对于可迭代对象, 可以用内置的 iter() 方法, 和 next()方法进行取值 == list1 = [1, 2, 3, 4] i = iter(list1) print(next(i)) print(next(i)) print(next(i)) print(next(i)) ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:2","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"优点 为序列和非序列提供了一个统一取值的方法. 惰性计算: 迭代器对象本身是一个数据流, 只有在使用时才会用__next__() 计算出下一个值, 就迭代器本身来说,同一时刻在内存中只有一个值, 因此可以存放无限大的数据流. ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:3","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"缺点 除非取尽 , 否则无法获取数据的长度. 只能取一个值, 不能回到取值开始, ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:4","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"for 循环原理 代码示例 list1 = [1, 2, 3, 4, 5] # list1 是可迭代对象, 所以可以用__iter__() 方法产生迭代器对象 iter_list1 = list1.__iter__() # 循环用迭代器对象的__next__()方法取值 while True: print(iter_list1.__next__()) # 输出结果 1 Traceback (most recent call last): 2 3 4 5 File \"D:/Python_study/Project/oldboy/day12/text.py\", line 8, in \u003cmodule\u003e print(iter_list1.__next__()) StopIteration # 但是当迭代器对象内的值取尽的时候, python解释器会抛出异常, 这样就需要用到异常处理 for 循环原理 异常处理 list1 = [1, 2, 3, 4, 5] # list1 是可迭代对象, 所以可以用__iter__() 方法产生迭代器对象 iter_list1 = list1.__iter__() # 循环用迭代器对象的__next__()方法取值 while True: try: print(iter_list1.__next__()) except StopIteration: break # 这就是for 循环原理 [toc] ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:2:0","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"闭包函数 什么是闭包函数呢? 闭: 封闭 包: 包裹 比如手机是闭包函数（内层函数），被手机包装盒 (外层函数) 包裹起来， 手机可以使用包装盒中的东西，内层函数可以引用外层函数的名字。 闭包函数必须在函数内部定义 闭包函数可以引用外层函数的名字. 闭包函数是 函数嵌套, 函数对象, 名称空间与作用域的 结合体 def func(y): x = 100 # inner是闭包函数 def inner(): print(x) print(y) return inner inner = func() inner() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:1:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"什么是装饰器？ 装饰: 装饰，修饰 。 器: 工具。 装饰的工具。 “开放封闭”： 装饰器必须要遵循 “开放封闭” 原则。 开放: 对函数功能的添加是开放的。 封闭: 对函数功能修改是封闭的。 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器的作用？ 在不修改被装饰对象源代码与调用方式的前提下, 添加新的功能。 装饰器的定义必须遵循 不修改被装饰对象源代码 不修改被装饰对象调用方式 为什么使用装饰器 可以解决代码冗余问题，提高代码的可扩展性。 代码示例: - 无装饰器实现运行时间统计 def download_movie(): print('开始下载电影...') # 模拟电影下载时间 3秒 time.sleep(3) # 等待3秒 print('电影下载成功...') return '小泽.mp4' start_time = time.time() # 获取当前时间戳 download_movie() end_time = time.time() # 获取当前时间戳 print(f'消耗时间: {end_time - start_time}') # 问题: 多个被装饰对象，需要写多次统计时间的代码，导致代码冗余。 - 使用函数实现 def time_record(func): start_time = time.time() # 获取当前时间戳 # 写死了,该功能只能给一个函数使用 # download_movie() func() end_time = time.time() # 获取当前时间戳 print(f'消耗时间: {end_time - start_time}') return None # 被装饰对象的调用方式 res = time_record(download_movie) print(res) # None # 问题, 更改了调用方式. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器: 初级版 def time_record(func): def inner(*args, **kwargs): # 统计开始 start_time = time.time() # 被装饰对象， 问题1: 有返回值， 问题2: 不确定参数的 个数 res = func(*args, **kwargs) # func() ---\u003e download_movie() # 当被统计的函数执行完毕后，获取当前时间 end_time = time.time() # 统计结束，打印统计时间 print(f'消耗时间: {end_time - start_time}') return res return inner download_movie = time_record(download_movie) # inner # name = 'egon' # download_movie(name) download_movie(name='egon') ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:3","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器, 终极版. 考虑被装饰对象,有参数,有返回值的情况. def time_record(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:4","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器语法糖, ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器使用的两种方式. 装饰器使用得时候 , 需要两步, 调用装饰器函数, 并将被装饰对象传入,将返回值用 “调用函数\"的名字赋值 调用被重新赋值后的 “名字” 代码演示 download_movie= time_record(*args, **kwargs) download_movie() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"语法糖 即在被装饰对象的上方 用@+装饰器 来进行使用装饰器 语法糖是python解释器提供的, 用来简便使用装饰器的一种方式. 注意, 使用语法糖时 , 装饰器的定义要在被装饰对象之前, 不然会报错. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器的叠加. 当一个被装饰对象, 需要多个功能时, 应该使用多个不同功能的装饰器, 而==不是在一个装饰器中添加多个功能==. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:4:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器叠加原则. 装饰时 是 从下往上 调用时 是 从上往下 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:4:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰 当我们需要判断用户的权限, 就需要获取用户的身份信息, 并传入装饰器中,进行判断, 这就需要有参装饰器. 代码示例如下. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰器的定义 def outher(需要传入的参数) def wrapper(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner return wrapper ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰器的调用 def outher(需要传入的参数) def wrapper(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner return wrapper @outer(传入参数) def func(): pass func() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"warps 的使用. 在每个函数内, 我们都是需要写注释 , 来表明此函数所实现的功能,和用法. 使用装饰器的时候, 也是需要添加注释, 表明装饰器实现的是某个功能. 当装饰器和被装饰对象同时有注释的时候, 调用被装饰对象的.doc() 方法就不能看到其注释说明. 代码示例 from functools import wraps def wrapper(func): def inner(*args, **kwargs): ''' this is the doc from inner :param args: :param kwargs: :return: ''' res = func() return res return inner @wrapper def func1(): ''' this is doc from func1 :return: ''' pass print(func1.__doc__) # 输出结果 this is the doc from inner :param args: :param kwargs: :return: 由此可见, 在使用装饰器后, 被装饰对象的注释被污染, 因此可以用, wraps 进行修复. from functools import wraps def wrapper(func): @wraps(func) def inner(*args, **kwargs): ''' this is the doc from inner :param args: :param kwargs: :return: ''' res = func() return res return inner @wrapper def func1(): ''' this is doc from func1 :return: ''' pass print(func1.__doc__) 在inner的上方使用@wraps(func) 并将被装饰函数传入wraps , 即可 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:6:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"引子 如今我们已经编写一些简单的程序, 但是随着功能的增多, 代码量随之增大. 此时如果仍然不区分把实现不同的功能的代码放到一起, 将会使得程序结构不清晰, 代码的可读性差, 和代码的冗余. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:1:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"什么是函数 函数就是具备某一功能的\"工具\" ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:2:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"为什么用函数 为了解决代码的冗余 为了使代码有更强的可读性. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:3:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数应该怎么用 函数和变量一样, 应该先定义, 后使用. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的定义方式. 函数的定义是用 def 关键字进行定义, 格式如下 def index(): pass def 表示定义函数的关键字 index 表示这个函数的名字. ()形参位置 : 冒号是必须要的. 函数下代码有四个空格缩进. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:1","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的调用方式. 函数定义后, 就可以使用, 函数的定义是,在内存中开辟内存空间, 将函数体代码放进内存空间中, 并和函数名建立映射关系. # 打印函数 def index(): pass print(index) # 输出结果 \u003cfunction index at 0x000002C1C4141EA0\u003e 输出的结果是 函数所在的内存空间地址. # 函数的调用 def index(): print(\"我运行了\") index() # 用函数名+() 就是函数的调用方式. # 输出结果 我运行了 ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:2","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的分类 无参函数 在函数定义的时候, 没有形参, 即在函数运行的时候, 也没有参数的传入, 称之为无参函数 def index(): print(\"我运行了\") 有参函数 def index(a,b): print(a,b) 空函数 为什么要用空函数? 因为在写项目的时候, 会去实现很多功能, 定义空函数就是为了先进行项目的功能分类, 让项目的架构更清晰. 然后再逐一实现对象的功能函数代码 def index(): pass ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:3","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"形参和实参 形参 在函数的定义阶段, 函数名后括号内, 填入的占位用的 变量名 称之为形参. def index(a,b): pass # a,b 就是形参 实参 在函数的调用阶段, 传入的值即为实参. def index(a,b): print(a,b) index(1,2) # 1,2 就是实参. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:4","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的传参方式. 位置传参 位置参数就是, 依照前后的顺序,依次传参, 就是位置参数. def index(a,b): print(a,b) index(1,2) 这种传参方式就是位置参数. 关键字参数. 以关键字和值这种 对应的方式传参, 即为关键字参数. def index(a,b): print(a,b) index(a=1, b=2) a= 1,b=2 就是关键字参数. 默认参数 # 当一个参数的值重复传入的时候, 就可以设置默认参数, 即在 形参处 def index(name, age, gender=\"male\"): print(f\"我的名字是{name}, 年龄{age},性别{gender}\") index(\"张\", 18 ) # 输出结果 我的名字是张, 年龄18,性别male 使用默认参数时, 如果不传参,则自动传入设置的默认值. 传参的话, 覆盖掉默认值. def index(name, age, gender=\"male\"): print(f\"我的名字是{name}, 年龄{age},性别{gender}\") index(\"张\", 18 ) index(\"王\",19,\"female\") # 输出时间 我的名字是张, 年龄18,性别male 我的名字是王, 年龄19,性别female ps: 注意,当位置参数和关键字参数同时使用的时候, 位置参数要在关键字参数的前面. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:5","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"可变长参数 *args **kwargs 当用户不知道要传入几个参数的时候, 就出现会多传参的情况, 这时 我们就需要找个万能的形参来接收用户多传来的值. # *args 用来接收多传进来的位置参数, def index(a,b,*args): print(a,b) print(*args) index(1,2,3,4,5) # 输出结果 1,2 3,4,5 # 例2 def index(a,b,*args): print(a,b) print(args) index(1,2,3,4,5) # 输出结果 1,2 (3,4,5) # 原理是, 将多传入的未知参数打包到元组中, 并赋值给args , # 所以args 只是python中官方认证的方法, 可以用任意的名称 # * 打散的功能, 可以看出上面两个立体中 args和*args的区别 # * 如果后面跟的是字典, 则返回的值是字典的所有key # **kwargs # 用来接收多传进来的关键字参数, 是以字典的方式接收, 即 关键字是字典的key 值为 value def index(a, b, *args, **kwargs): print(a, b) print(kwargs) index(1, 2, 3, 4, 5, d=13, c=\"wo\") # 输出结果 1 2 {'d': 13, 'c': 'wo'} [toc] ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:6","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"一 数字类型 int 与 float 记录数字类型的事物状态 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.1 定义 age = 18 # 定义整型 weight = 63.8 # 定义浮点型 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.2 类型转换 整型和浮点型之间可以相互转换. 整型转换成浮点型 整型转换为浮点型后,会默认精确到小数点后一位, 以0 补足 a = 18 b = float(a) print (a,type(a),b,type(b)) # 输出结果 18 \u003cclass 'int'\u003e 18.0 \u003cclass 'float'\u003e 浮点型转换为整型 a = 18.333 b = int(a) print (a,type(a),b,type(b)) # 输出结果为 18.333 \u003cclass 'float'\u003e 18 \u003cclass 'int'\u003e 转换后, 浮点数的小数部分全部舍去 , 而不是四舍五入 int() 可以转换由纯数字组成的字符串, 如果字符串中含有非纯数字则会报错 a = \"123\" a = int(a) print(a,type(a)) # 输出结果 123 \u003cclass 'int'\u003e a = \"12.3\" a = int(a) print(a,type(a)) # 输出结果 a = int(a) ValueError: invalid literal for int() with base 10: '12.3' 进制之间的转换 十进制转其他进制 # 十进制转二进制 a = bin(10) # 十进制转八进制 a = oct(10) # 十进制转十六进制 a = hex(1005) 其他进制转十进制 # 使用int() 方法, 第一个参数是字符串, 是将其他进制类型的数字当字符串传入第一个参数, 第二个参数是int类型, 指明第一个单数的进制 int(\"10101010111\",2) ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.3 使用 主要用来做数学运算, 无其他特殊用途. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"二 字符串 字符串就是一串描述性文字. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.1 定义 定义字符串的三种方式: a = “abc” 用双引号引起来 即可 a = ‘abc’ 用单引号 a = ‘‘‘abc’’’ 用三引号 注意: 三种方式不可混用, 当字符串中含有\"“时 , 外面的药用 ’’ 包裹, 即成对出现 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.2 类型转换 任意类型可以转换为字符串 a = 18 print(a,type(a) # 输出结果 18 \u003c class \"int\"\u003e b = str(b) print(b,type(b) # 输出结果 18 \u003c class \"str\"\u003e ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.3 使用 呵~ 真沙雕, 我就是个分隔符~~~~~~~~~~~~~~~ 2.3.1 优先掌握的操作 正反向取值 切片 统计长度 成员运算 移除首尾指定字符 默认移除首尾空格 切分以指定字符切分字符串, 默认是以空格 遍历, 可以遍历所有单个字符 a = \"hello word\" # 1. 正/反向索引取值 print(a[6]) print(a[-3]) # 输出结果 w o # 和列表的索引取值一样 正向取值从0开始, 反向取值为:从右向左1 开始. # 字符串只能取值, 而不能修改. # 2. 切片(顾头不顾尾,步长) print(a[0:5:2]) # 0 代表其实位置, # 5 代表结束位置 (此位置不计入切片范围) # 2 代表步长 # 输出结果 hlo # 2.1 反向切片 a[::-1] # 表示从右往左依次取值 # 输出结果为 dlrow olleh # 3 len 统计字符串长度 l = len(a) print(l,type(l)) # 输出结果 11 \u003cclass 'int'\u003e # 4 成员运算 in / not in 返回False/ True print(\"hello\" in a) # 输出结果 True print(\"python\" not in a) # 输出结果 True # 5 .strip() 移除字符串首尾指定字符, 默认为空格 s = \" help me \" print(s.strip()) # 输出结果 help me s = \"******help me******\" print(s.strip(\"*\")) # 输出结果 help me # 6 .split() 切分 括号内不指定字符, 则默认以空格切分 m = \" w shi ni dad \" print(m.split()) # 输出结果 ['w', 'shi', 'ni', 'dad'] m = \"127.0.0.1\" print(m.split(\".\")) # 输出结果 ['127', '0', '0', '1'] # 输出的结果是一个列表. # 7 可以被遍历(循环取出) q = \"我是你爸爸!\" for i in q: print(i) # 输出结果 我 是 你 爸 爸 ! 2.3.2 需要掌握的操作 strip lstrip rstrip s = \"******help me******\" print(s.strip(\"*\")) # 输出结果 help me # 左侧移除 print(s.lstrip(\"*\")) # 输出结果 help me****** # 右侧移除 print(s.rstrip(\"*\")) # 输出结果 ******help me 2 .lower() .upper() 将所有字符转换为大写, 小写 m = \"My Name Is Evgeny\" print(m.lower()) print(m.upper()) # 输出结果 my name is evgeny MY NAME IS EVGENY # 能转换的只有英文字母, 中文则不变 3 .startswith, .endswith 以什么开头, 以什么结尾 s = \"hello Evgeny\" print(s.startswith(\"h\")) print(s.endswith(\"y\")) # 输出结构 True True 4 格式化输出, 有单独的一章 ,不知道在哪儿? 点我, 点我, 亲爱哒 5 split rsplit 切分 # split 是从左往右进行切分, 可以指定切分次数 s = \"我|是你爸爸\" s = s.split(\"|\",1) print(s) # 输出结果 [\"我\",\"是你爸爸\"] # rsplit 是从左往右进行切分, 可以指定切分次数 s = \"我|是|你爸爸\" s = s.rsplit(\"|\",1) print(s) # 输出结果 ['我|是', '你爸爸'] 6 join 在可迭代对象后加入多个字符 print(\"!\".join(\"hello\")) # 输出结果 h!e!l!l!o 7.replace 替换指定字符 # 用新的字符替换字符串中旧的字符 st = 'my name is Evgeny, my age is 18!' # 将Evgeny的年龄由18岁改成20岁 st = st.replace('18', '73') # 语法:replace('旧内容', '新内容') print(st) # 输出结果 my name is Evgeny, my age is 20! # 可以指定修改的个数 st = 'my name is Evgeny, my age is 18!' st = str7.replace('my', 'MY',1) # 只把一个my改为MY print(st) 'MY name is Evgeny, my age is 18!' .isdigit 判断是否是纯数字 # 判断字符串是否是纯数字组成，返回结果为True或False str1 = '1990' print(str1.isdigit()) True str2 = '123.123' print(str8.isdigit()) False # .isdigit 不能判断浮点数 2.3.3 了解操作 # 1.find,rfind,index,rindex,count # 1.1 find：从指定范围内查找子字符串的起始索引，找得到则返回数字1，找不到则返回-1 msg='tony say hello' msg.find('o',1,3) # 在索引为1和2(顾头不顾尾)的字符中查找字符o的索引 输出结果 1 # 1.2 index:同find,但在找不到时会报错 msg.index('e',2,4) # 报错ValueError # 1.3 rfind与rindex：略 1.4 count:统计字符串在大字符串中出现的次数 \u003e\u003e\u003e msg = \"hello everyone\" \u003e\u003e\u003e msg.count('e') # 统计字符串e出现的次数 4 \u003e\u003e\u003e msg.count('e',1,6) # 字符串e在索引1~5范围内出现的次数 1 # 2.center,ljust,rjust,zfill \u003e\u003e\u003e name='tony' \u003e\u003e\u003e name.center(30,'-') # 总宽度为30，字符串居中显示，不够用-填充 -------------tony------------- \u003e\u003e\u003e name.ljust(30,'*') # 总宽度为30，字符串左对齐显示，不够用*填充 tony************************** \u003e\u003e\u003e name.rjust(30,'*') # 总宽度为30，字符串右对齐显示，不够用*填充 **************************tony \u003e\u003e\u003e name.zfill(50) # 总宽度为50，字符串右对齐显示，不够用0填充 0000000000000000000000000000000000000000000000tony # 3.expandtabs \u003e\u003e\u003e name = 'tony\\thello' # \\t表示制表符(tab键) \u003e\u003e\u003e name tony hello \u003e\u003e\u003e name.expandtabs(1) # 修改\\t制表符代表的空格数 tony hello # 4.captalize,swapcase,title # 4.1 captalize：首字母大写 \u003e\u003e\u003e message = 'hello everyone nice to meet you!' \u003e\u003e\u003e message.capitalize() Hello everyone nice to meet you! # 4.2 swapcase：大小写翻转 \u003e\u003e\u003e message1 = 'Hi girl, I want make friends with you!' \u003e\u003e\u003e message1.swapcase() hI GIRL, i WANT MAKE FRIENDS WITH YOU! #4.3 title：每个单词的首字母大写 \u003e\u003e\u003e msg = 'dear my friend i miss you very much' \u003e\u003e\u003e msg.title() Dear My Friend I Miss You Very Much # 5.is数字系列 #在python3中 num1 = b'4' #bytes num2 = u'4' #unicode,python3中无需加u就是unicode num3 = '四' #中文数字 num4 = 'Ⅳ' #罗马数字 #isdigt:bytes,unicode \u003e\u003e\u003e num1.isdigit() True \u003e\u003e\u003e num2.isdigit() True \u003e\u003e\u003e num3.isdigit() False \u003e\u003e\u003e num4.isdigit() False #isdecimal:uncicode(bytes类型无isdecimal方法) \u003e\u003e\u003e num2.isdecimal() True \u003e\u003e\u003e num3.isdecimal() False \u003e\u003e\u003e num4.isdecimal() False #isnumberic:unicode,中文数字,罗马数字(bytes类型无isnumberic方法) \u003e\u003e\u003e num2.isnumeric() True \u003e\u003e\u003e num3.isnumeric() Tru","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"三 列表 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.1 定义 # 定义：在[]内,用逗号分隔开多个任意数据类型的值 l1 = [1,'a',[1,2]] # 本质:l1 = list([1,'a',[1,2]]) ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.2 类型转换 # 但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，list()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中 \u003e\u003e\u003e list('wdad') # 结果：['w', 'd', 'a', 'd'] \u003e\u003e\u003e list([1,2,3]) # 结果：[1, 2, 3] \u003e\u003e\u003e list({\"name\":\"jason\",\"age\":18}) #结果：['name', 'age'] \u003e\u003e\u003e list((1,2,3)) # 结果：[1, 2, 3] \u003e\u003e\u003e list({1,2,3,4}) # 结果：[1, 2, 3, 4] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.3 使用 3.3.1 优先掌握的操作 # 1.按索引存取值(正向存取+反向存取)：即可存也可以取 # 1.1 正向取(从左往右) \u003e\u003e\u003e my_friends=['tony','jason','tom',4,5] \u003e\u003e\u003e my_friends[0] tony # 1.2 反向取(负号表示从右往左) \u003e\u003e\u003e my_friends[-1] 5 # 1.3 对于list来说，既可以按照索引取值，又可以按照索引修改指定位置的值，但如果索引不存在则报错 \u003e\u003e\u003e my_friends = ['tony','jack','jason',4,5] \u003e\u003e\u003e my_friends[1] = 'martthow' \u003e\u003e\u003e my_friends ['tony', 'martthow', 'jason', 4, 5] # 2.切片(顾头不顾尾，步长) # 2.1 顾头不顾尾：取出索引为0到3的元素 \u003e\u003e\u003e my_friends[0:4] ['tony', 'jason', 'tom', 4] # 2.2 步长：0:4:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2的元素 \u003e\u003e\u003e my_friends[0:4:2] ['tony', 'tom'] # 3.长度 \u003e\u003e\u003e len(my_friends) 5 # 4.成员运算in和not in \u003e\u003e\u003e 'tony' in my_friends True \u003e\u003e\u003e 'xxx' not in my_friends True # 5.添加 # 5.1 append()列表尾部追加元素 \u003e\u003e\u003e l1 = ['a','b','c'] \u003e\u003e\u003e l1.append('d') \u003e\u003e\u003e l1 ['a', 'b', 'c', 'd'] # 5.2 extend()一次性在列表尾部添加多个元素 \u003e\u003e\u003e l1.extend(['a','b','c']) \u003e\u003e\u003e l1 ['a', 'b', 'c', 'd', 'a', 'b', 'c'] # 5.3 insert()在指定位置插入元素 \u003e\u003e\u003e l1.insert(0,\"first\") # 0表示按索引位置插值 \u003e\u003e\u003e l1 ['first', 'a', 'b', 'c', 'alisa', 'a', 'b', 'c'] # 6.删除 # 6.1 del \u003e\u003e\u003e l = [11,22,33,44] \u003e\u003e\u003e del l[2] # 删除索引为2的元素 \u003e\u003e\u003e l [11,22,44] # 6.2 pop()默认删除列表最后一个元素，并将删除的值返回， # 括号内可以通过加索引值来指定删除元素 \u003e\u003e\u003e l = [11,22,33,22,44] \u003e\u003e\u003e res=l.pop() \u003e\u003e\u003e res 44 \u003e\u003e\u003e res=l.pop(1) \u003e\u003e\u003e res 22 # 6.3 remove()括号内指名道姓表示要删除哪个元素，没有返回值 \u003e\u003e\u003e l = [11,22,33,22,44] \u003e\u003e\u003e res=l.remove(22) # 从左往右查找第一个括号内需要删除的元素 \u003e\u003e\u003e print(res) None # 7.reverse()颠倒列表内元素顺序 \u003e\u003e\u003e l = [11,22,33,44] \u003e\u003e\u003e l.reverse() \u003e\u003e\u003e l [44,33,22,11] # 8.sort()给列表内所有元素排序 # 8.1 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错 \u003e\u003e\u003e l = [11,22,3,42,7,55] \u003e\u003e\u003e l.sort() \u003e\u003e\u003e l [3, 7, 11, 22, 42, 55] # 默认从小到大排序 \u003e\u003e\u003e l = [11,22,3,42,7,55] \u003e\u003e\u003e l.sort(reverse=True) # reverse用来指定是否跌倒排序，默认为False \u003e\u003e\u003e l [55, 42, 22, 11, 7, 3] # 8.2 了解知识： # 我们常用的数字类型直接比较大小，但其实，字符串、列表等都可以比较大小， # 原理相同：都是依次比较对应位置的元素的大小，如果分出大小，则无需比较下一个元素，比如 \u003e\u003e\u003e l1=[1,2,3] \u003e\u003e\u003e l2=[2,] \u003e\u003e\u003e l2 \u003e l1 True # 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大 \u003e\u003e\u003e s1='abc' \u003e\u003e\u003e s2='az' \u003e\u003e\u003e s2 \u003e s1 # s1与s2的第一个字符没有分出胜负，但第二个字符'z'\u003e'b',所以s2\u003es1成立 True # 所以我们也可以对下面这个列表排序 \u003e\u003e\u003e l = ['A','z','adjk','hello','hea'] \u003e\u003e\u003e l.sort() \u003e\u003e\u003e l ['A', 'adjk', 'hea', 'hello','z'] # 9.循环 # 循环遍历my_friends列表里面的值 for line in my_friends: print(line) 'tony' 'jack' 'jason' 4 5 3.3.2 了解操作 \u003e\u003e\u003e l=[1,2,3,4,5,6] \u003e\u003e\u003e l[0:3:1] [1, 2, 3] # 正向步长 \u003e\u003e\u003e l[2::-1] [3, 2, 1] # 反向步长 # 通过索引取值实现列表翻转 \u003e\u003e\u003e l[::-1] [6, 5, 4, 3, 2, 1] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"四 元祖 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.1 作用 元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.2 定义方式 # 在()内用逗号分隔开多个任意类型的值 \u003e\u003e\u003e countries = (\"中国\"，\"美国\"，\"英国\") # 本质:countries = tuple(\"中国\"，\"美国\"，\"英国\") # 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组 \u003e\u003e\u003e countries = (\"中国\"，) # 本质:countries = tuple(\"中国\") ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.3 类型转换 # 但凡能被for循环的遍历的数据类型都可以传给tuple()转换成元组类型 \u003e\u003e\u003e tuple('wdad') # 结果：('w', 'd', 'a', 'd') \u003e\u003e\u003e tuple([1,2,3]) # 结果：(1, 2, 3) \u003e\u003e\u003e tuple({\"name\":\"jason\",\"age\":18}) # 结果：('name', 'age') \u003e\u003e\u003e tuple((1,2,3)) # 结果：(1, 2, 3) \u003e\u003e\u003e tuple({1,2,3,4}) # 结果：(1, 2, 3, 4) # tuple()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.4 使用 \u003e\u003e\u003e tuple1 = (1, 'hhaha', 15000.00, 11, 22, 33) # 1、按索引取值(正向取+反向取)：只能取，不能改否则报错！ \u003e\u003e\u003e tuple1[0] 1 \u003e\u003e\u003e tuple1[-2] 22 \u003e\u003e\u003e tuple1[0] = 'hehe' # 报错：TypeError: # 2、切片(顾头不顾尾，步长) \u003e\u003e\u003e tuple1[0:6:2] (1, 15000.0, 22) # 3、长度 \u003e\u003e\u003e len(tuple1) 6 # 4、成员运算 in 和 not in \u003e\u003e\u003e 'hhaha' in tuple1 True \u003e\u003e\u003e 'hhaha' not in tuple1 False # 5、循环 \u003e\u003e\u003e for line in tuple1: ... print(line) 1 hhaha 15000.0 11 22 33 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:4","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"五 字典 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"定义方式 第一种方式 用花括号, 将key:value 这样的键值对放入, 并以逗号隔开. d1 = {“name”:“zhang”, “age”:18} 第二种方式 使用dict方法, d1 = dict(name=“zhang”, age =18 ) 第三种方法, zip 拉链函数. # zip 有两个参数 第一个和第二个参数都为可迭代对象, 工作方式, # 第一个参数取一个值, 第二个取一个, 组成一个元组, 返回一个可迭代对象 l1 = [1,2,3,4,5] l2 = [\"a\",\"b\",\"c\"] l3 = zip(l1,l2) for i in l3: print(i) # 输出结果 (1, 'a') (2, 'b') (3, 'c') 生成字典的方法 l1 = [1,2,3,4,5] l2 = [\"a\",\"b\",\"c\"] l3 = zip(l1,l2) d1 = dict(l3) print(d1) # 输出结果 {1: 'a', 2: 'b', 3: 'c'} ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"类型转换 定义方式已有提起 {}.fromkeys(可迭代对象,值) # 使用fromkeys创建一个字典, # 第一个参数, 可迭代对象, 必须所有元素为不可变类型. # 创建的字典, 是以可迭代对象的每一个元素作为新字典的 key, 然后分别与同一个值配对. 完成创建 # 结果是, 整个字典的value是第二个参数 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"使用 5.3.1 优先掌握的操作 操作无外乎 增删改查 增 d1 = {\"a\":1,\"b\":2} # 1. update 更新, 传递的参数是一个字典, 如果有, 则更新最新value, 如果没有, 则添加. d1 = {\"a\":1,\"b\":2} d1.update({\"b\":3}) print(d1) # 输出结果 {'a': 1, 'b': 3} update 只能更新一组数据. so # 2. [] 方法 d1 = {\"a\":1,\"b\":2} d1[\"c\"] = 3 print(d1) # 输出结果 {'a': 1, 'b': 2, 'c': 3} # 3 setdefault() 两个参数, 在元组里包起来. 第一个是key 第二个是value 当 有key 存在的时候, 返回原来所对应的值, 当key 不存在 添加, 并返回最新的value 值. 删 # del 方法 万能删除. pass # pop 参数: key , 传入key 删除 对应键值对 . 并返回 对应的value值 d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.pop(\"a\") print(d2,s) # 输出结果 {'b': 2, 'c': 3} 1 # popitem 无需传入参数, 随机删除一个键值对, 并返回由删除的key,value 组成的元组. d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.popitem() print(d2,s) # 输出结果 {'a': 1, 'b': 2} ('c', 3) 改 新增的时候, 已说, 查 # 1 用.keys 查找字典所有key d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.keys()) # 打印结果 dict_keys(['a', 'b', 'c']) # 2 用 .values 查找字典所有的value d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.values()) # 返回结果 dict_values([1, 2, 3]) # 3 用 items 查找字典所有的 key 和对应的value d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.items()) # 返回结果 dict_items([('a', 1), ('b', 2), ('c', 3)]) # 4 get 方法, 传入key 查找对应的value . 如果没有key 则返回 None d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.get(\"d\") print(s) # 返回结果 None 5.3.2 需要掌握的操作 以上大部分都需要掌握 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"六 集合 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.1 作用 主要用于 查重, 和 成员运算 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.2 定义 set 是以花括号包裹,单个元素以逗号隔开的数据类型. 特点: 每个元素必须是不可变类型 集合内没有重复元素 集合内元素无序 s1 = {1,2,3} 定义空集合 因为 集合和字典都是以{}包裹, 所以 定义空集合必须需要set 方法. s1 = set() ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.3 类型转换 只要是能被for 循环遍历的 是非可变类型的元素, 都能传入set 进行查重. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.4 使用 6.4.1 关系运算 | 并集, 求两个集合中所有的元素, 重复只留一个 \u0026 交集, 求两个集合中相交的部分. “-” 差集, 前一个集合中与后一个集合不相交的部分. ^ 对称差集, 两个集合中取出相交的元素. 6.4.2 去重 去重有局限性, 只能对只有不可变元素的容器进行去重 去重后集合内元素是无序的. [toc] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:4","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"引入 当我们的cpython(C语言编写的python 解释器) 执行到定义变量的语法时, 会向系统申请内存空间来存储变量, 而 内存的容量是有限的, 那么这就牵扯到一个内存空间的回收问题. 当一个变量不再被使用, 就需要把这个变量所占用的内存空间回收. 由于变量名是访问变量值的唯一方式, 所以当一个变量值不再关联任何的变量名时, 我们就无法再访问到该变量值, 此时该变量值就是垃圾, cpython 为我们 提供了自动的垃圾回收机制来帮我们解决垃圾回收的问题 ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:1","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"垃圾回收机制 垃圾回收机制 (简称GC) 是python 解释器自带的一种机制, 是专门用来回收不可以的变量值所占用的内存空间 ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:2","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"为什么要用垃圾回收机制 程序运行中需要申请大量的内存空间, 而对于一些无用的内存空间如果不及时清除, 会导致内存耗尽,程序崩溃, 电脑(服务器) 宕机等, 引发严重问题. 因此管理内存是一件重要且繁杂的事情. ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:3","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"垃圾回收机制原理 Python 的 GC 模块主要运用了\"引用计数\"(referrence counting) 来跟踪和回收垃圾, 在引用计数基础上, 还可以通过\"标记-清除\" ( mark and sweep ) 解决容器对象可能产生的循环引用问题, 并且通过\"分代回收\"(generation collection) 以空间换取时间的方式来进一步提高垃圾回收效率 什么是引用计数 引用计数就是: 变量值被变量名关联的次数 如: age = 23 变量值 23 被 变量名 age 关联, 此时的 引用计数为1 引用计数增加 age = 23 ( 此时23 的引用计数次数为1 ) m = age ( 把 age的内存地址给了 m, 此时,. m,age 都关联23 , 所以变量值23的引用计数为2) 引用计数的减少: age = 18 ( 名字 age 先与23 解除关联, 再与18 简历关联, 此时 变量值得引用计数为1) ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:4","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"流程控制 流程控制即 控制流程, 具体指控制程序的执行流程, 而程序的流程分为三种, 顺序结构(以前写的代码都是顺序结构) 分支结构(if 判断) 循环结构(while 和 for 循环) ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"分支结构 ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"什么是分支结构 分支结构就是根据条件判断的真假去执行不同的代码块. ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"为什么要用分支结构 人类某些时候要根据条件决定做什么事情, 比如, 今天下雨, 带伞. 是最基本的逻辑判断. ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:2","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"如何使用分支结构 if 语法 用if关键字实现分支结构. if 条件1: 代码块1 ...... elif 条件2: 代码块2 ...... elif 条件3: 代码块3 ...... else: 代码块4. # 如果以上条件符合, 则执行下面相应的代码.以上代码块能且只能执行一块. # 1. python 用相同的缩进(四个空格表示一个缩进) 来标识一组代码. 同一组代码块 # 2.条件可以是任意表达式, 但执行结果必须为bool类型 # 在if 判断中的所有的数据类型都会转换为布尔类型 # None, 0 ,[],\"\",{} , 换算成bool值都为False , 非空即真 if 应用案例 # 案例1 # 如果: 女人年龄\u003e3岁, 那么叫阿姨 age = input(\"输入年龄\u003e\u003e:\") if age \u003e30: print(\"叫阿姨!\"\") # 案例2 # 如果 年龄\u003e30 叫阿姨, 否则叫姐姐 age = input(\"输入年龄\u003e\u003e:\") if age \u003e30: print(\"叫阿姨!\"\") else: print(\"叫姐姐1\") # 案例3 # 如果女人年龄\u003e= 18 并且\u003c= 22 岁 并且身高\u003e170 体重\u003c100 并且是漂亮的. 那么表白. 否则. 阿姨好 age = input(\"输入年龄\u003e\u003e:\") height = input(\"目测身高\u003e\u003e:\") is_beauty = True weight = input(\"目测体重\u003e\u003e:\") if 18\u003c= age \u003c= 22 and height \u003e170 and weight \u003c 100 and is_beauty: print(\"表白\") else: print(\"叫阿姨\") 练习登录 username_from_db = \"zhang\" password_from_db = 123 count = 0 tag = True while tag: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while tag: cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": tag = False else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") tag = False ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:3","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"循环结构 ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"while 循环语法 python中 有while 与for 两中循环机制, 其中while 称之为条件循环. while 条件: 代码1 代码2 ...... # while 的运行步骤, # 步骤1 : 如果条件成立,则依次执行代码1,代码2 ... # 步骤2: 执行完毕后, 再次判断条件,如果条件仍然成立,则再次执行代码1,代码2,代码3 案例1 用户认证 username_from_db = \"zhang\" password_from_db = 123 count = 0 while count \u003c3: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") else: print(\"用户名或密码错误,请重新收入\") count +=1 案例二 while + break 的使用 使用while 循环后, 当登录成功, 则需要后续操作, 需要结束本层循环 , 那么就需要break. break 结束本层循环. 结束后 循环内代码都不执行. username_from_db = \"zhang\" password_from_db = 123 # 记录验证错误次数 count = 0 while count \u003c3: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") break # 用于结束本层循环 else: print(\"用户名或密码错误,请重新收入\") count +=1 案例三, while 循环嵌套+ break 如果while 循环嵌套了很多层, 想要退出每层循环,则需要在每层都有一个break username_from_db = \"zhang\" password_from_db = 123 count = 0 while True: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while True: # 第二层循环 cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": break # 退出第二层循环 else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") break # 退出第一场循环 案例四, while 循环嵌套, + tag 的使用 针对嵌套多层的while循环, 如果当满足某个条件就退出所有循环, 就可以使用tag , 即 将tag 初始值为 True , 当满足某个条件后 tag 更改为False , 就会退出所有层循环 username_from_db = \"zhang\" password_from_db = 123 count = 0 tag = True while tag: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while tag: cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": tag = False else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") tag = False 案例五 while + continue 的使用. break 代表结束本层循环, continue 代表结束本次循环, 进入下一次循环 num = 10 while num \u003e1: num -=1 if num ==6: continue # 结束到本次循环, 后面的代码则不会再运行, 直接进入下一次循环. print(num) # 结果 6 则不打印, 案例六, while 与 else 的使用 . 当循环正常结束后, 执行else 后语句, 用来验证 循环是否正常结束. count = 0 while count \u003c5: count +=1 print(f\"这是第{count}次循环\") else: print(\"循环正常结束\") print(\"*\"*50) # 输出 这是第1次循环 这是第2次循环 这是第3次循环 这是第4次循环 这是第5次循环 循环正常结束 ************************************************** 如果执行过程中用break , 则不会执行else语句. count = 0 while count \u003c5: count +=1 if count ==3: break print(f\"这是第{count}次循环\") else: print(\"循环正常结束\") print(\"*\"*50) # 输出结果 这是第1次循环 这是第2次循环 ************************************************** ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:1","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"for 循环语法. 循环结构的第二种实现方法是 for 循环, for 循环可以做的事情 while循环都可以实现,之所以使用for 是因为, for循环在遍历取值时, 更为简洁. for 循环语法如下 for 变量名 in 可迭代对象: # 可迭代对象为, 字典,列表, 字符串, 等.. 代码1 代码2 # 例子 for i in [1,2,3,4]: print(i) # 输出结果 1 2 3 4 # 循环是, 将列表[1,2,3,4] 中的值分别取出并赋值给i 然后打印i 直到列表值取完. 案例1 , 打印数字1-5 # for 版本 for count in range(6): print(count) # while 版本 count = 0 while count\u003c6: print(count) count +=1 # range 有三个参数, start = 其实数字 end = 结束数字. sep =步长 # range 顾头不顾尾. 遍历字典, 得到的是字典中的key 而不是 值. for k in {\"name\":\"Evgeny\", \"age\":18} print(k) # 输出结果 name age 案例 三, for 循环嵌套. # 使用for 循环嵌套的方式打印以下图形 **** **** **** for i in range(3): for j in range(4): print(\"*\", end = \"\") print() # 表示换行 注意: break 与continue 也可以用于for循环, 使用发放与while循环相同. [toc] ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:2","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"数据类型 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"一. 什么是数据类型? 数据类型就是用来描述事物某个特征最恰当的方式, 例如: 用整数描述年龄 用浮点数描述小数 用字符串(文字类型)描述一些事物的信息. 等等等等 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"二. 类型有哪些? 怎么用? ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"2.1. 整型: int 类型 作用:记录 年龄,电话号, QQ号, 等数字 定义 age = 18 # age = int(18) print(age,type(age) # 输出结果 18 \u003cclass 'int'\u003e 定义int 类型, 是由int()这个功能函数实现的 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"2.2浮点数:float 类型 作用:记录工资,体重,身高等非整数类型数据 定义 height = 1.81 # height = float(1.81) print(height,type(height)) # 输出结果 1.81 \u003cclass 'float'\u003e 定义 int 类型,是由float()这个函数来实现的. 数字类型之间的运算 整型和浮点数 做数字运算, python 会自动将整型转换为浮点数类型. a = 10 b = 1.5 c = a*b print(c,type(c)) # 输出结果为 15.0 \u003cclass 'float'\u003e ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"字符串:str 类型 作用: 用来记录一段描述信息. 例如: 公司简介, 名称等信息 定义 可以用’ ‘,\" “,’’’ ‘‘‘定义一个字符串 name = \"Evgeny\" name1 = 'Evgeny' info = ''' company: 俄讯通文化有限公司 成立时间: 2017年 ''' print(name,type(name), name1,type(name1), info,type(info)) # 输出结果 Evgeny \u003cclass 'str'\u003e Evgeny \u003cclass 'str'\u003e company: 俄讯通文化有限公司 成立时间: 2017年 \u003cclass 'str'\u003e 区别: ’’ 和 \"” 本质上没有区别, 当同时用到的时候, 需要进行区分, 例如 print(\"my name is \"Evgeny\"\") # 输出结果 print(\"my name is \"Evgeny\"\") ^ SyntaxError: invalid syntax 这样就会报错 因为 python 解释器无法识别 哪两个\"\" 是一组. 所以会报错, 正确用法是 print(\"my name is 'Evgeny'\") ‘‘‘str’’’ 可以进行换行操作, 示例如上. str 字符串类型的运算 字符串之间可以相加 a = \"my\" b = \"name\" print(a+b) # 输出结果为 myname # 注, 字符串相加的底层操作是: - 先申请一个新的内存空间 - 将两个字符串value 拷贝,然后存入到新得内存空间 要尽量避免这种操作, 效率低下. 推荐占位符方法. 字符串可以与整型进行乘法操作 print(\"=\"*20) # 输出结果 ==================== 可以做分割线使用. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:3","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"列表 作用: 用来描述一个事物的同一种特性的不同数据, 例如: 人的爱好 定义: l = [1,2.3,\"hello\",[10,25] # l = list([1,2,3,\"hello\",[10,25]) print(l) # 输出结果 [1,2.3,\"hello\",[10,25] 由示例课件, 列表中的元素可以为整型, 字符串, 浮点数 乃至于一个列表 列表数据的取出,及索引 定义好数据之后,最终的目的是为了使用. 所以 如何正确取出列表中的数据,就变得很重要, 列表数据是按照以\"0\"为起始的下表索引. 具体请看示例 l = [10,22,33,\"hello\",[10,25] # 定义一个列表 print(l[0]) # 输出结果 10 如何取出列表内列表的值? 请看下面例子 students_info= [[\"wxx\",18,\"henan\"],[\"lxx\",24,\"hunan\"]] # 找到第二个人的省份 print(students_info[1][2]) # 输出结果 hunan 由示例可见, 想找到固定信息, 只需要按照索引,一级一级的向下找即可. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:4","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"字典 字典是以key:value 这样成组键值对出现的集合体. 作用 当一个事物有多种的特性, 特性又有多种状态的情况下, 列表已经不能满足我们的需要, 因位列表值得取用是按照列表的位置索引取用, 当数据量很大时, 取出的值并不能看出是属于哪种特性. # 举个栗子. info_evgeny = [\"evgeny\",18,\"man\",\"company\",] # 如上所示, 当想取出 这个人的\"年龄\" 信息时 , 该如何快速取出? # 当然可以用info_evgeny[1] 取出, 看了上面的代码, 我们就会发现一个问题. 这个列表只有四个值, 我们能一眼看出年龄所在列表的位置, 当 这个列表包晗的不仅仅只有这四个, 我们不能一眼看出位置索引时 , 我们应该怎么办? 那么 新的数据类型, 字典 dict 就出现了. 定义 定义列表有两种方式, # 第一种方式 dict1 = {\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"} print(dict1) # 输出结果 {'name': 'evgeny', 'age': 18, 'gender': 'man', 'name_company': 'company'} # 第二种方式 dict2 = dict({\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"}) # 输出结果 {'name': 'evgeny', 'age': 18, 'gender': 'man', 'name_company': 'company'} 使用 当字典中取某个值时, 只需要知道这组值得key, 就可以 dict1 = {\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"} age = dict1[\"age\"] print(age) # 输出结果 18 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:5","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"布尔bool 什么是布尔类型, 作用 为了记录真假 这两种状态 定义 is_ok = True is_ok = False 使用 通常用在if while 语句, 用作判断条件. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:6","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"格式化输出 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:0:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"什么是格式化输出？ 格式化输出就是将数据按照特定格式输出到屏幕上。 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:1:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"为什么要用格式化输出？ 一个事物有多种特性，当描述一个具体的事物的时候， 用一种特定的格式把此事物描述清楚，就需要用到格式化输出。 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:2:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"格式化输出有哪几种？ ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"1、%的方法 整数的输出 %o ——oct 八进制输出 %d ——dec 十进制输出 %c ——hex 十六进制输出 print(\"%o\" % 24) print(\"%d\" % 24) print(\"%x\" % 24) # 运行结果 30 24 18 # 输入的数字都是以十进制输入的。 浮点数输出 %f ——float 浮点数输出 print(\"%f\" % 25.66666666) # 运行结果 5.666667 默认保留小数后六位 print(\"%.4f\" % 12.333330) # 运行结果 12.3333 # 会根据要保留的后一位进行四舍五入。 %e ——用科学计数法输出。 print(\"%e\" % 1.11111111111) # 运行结果 1.111111e+00 默认保留小说后六位 print(\"%.3e\" % 1.11111111111) # 设置保留虚部位数 # 运行结果 1.111e+00 %g ——— 在保证6位有效数字的前提下， 使用小数计数法。 print(\"%g\" % 111.111111) # 运行结果 111.111 print('%.7g\" % 111.111111) # 取7位有效数字 # 运行结果 111.1111 print(\"%0.2g\" % 111.111111) # 取2位有效数字， 并用转换为科学计数法 # 运行结果 1.1e+02 字符串输出 %s –string 字符串输出 print(\"%s\" % \"hello world\") # 输出结果 hello world %-10s 占10个字符, 并左对齐 print(\"我是:%-10s, 今年18岁\" % \"七里塘\") # 输出结果 我是七里塘 , 今年18岁 %10s – 占用10个字符, 并右对齐 print(\"我是:%10s, 今年18岁\" % \"七里塘\") # 输出结果 我是: 七里塘, 今年18岁 %.2s –取前两个字符 print(\"我是:%.2s, 今年18岁\" % \"七里塘\") # 输出结果 我是:七里, 今年18岁 %10.2s – 取前两个字符,并且占用10个字符空间,向右对齐 print(\"我是:%10.2s, 今年18岁\" % \"七里塘\") # 输出结果 我是: 七里, 今年18岁 字符串格式代码如下 符号 说明 %s 字符串 %c 字符 %d 十进制数 %i 整数 %u 无符号整数 %o 八进制数 %x 十六进制整数 %X 十六进制整数大写 %f 浮点数1 %e 浮点数2 %E 浮点数3 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:1","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"format 方法 相对基本格式化输出采用‘%’的方法，format()功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’ ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:2","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"b.format() print(\"{} {}\".format(\"hello\", \"world\")) # 打印结果 hello world print(\"{} {}\".format(\"world\", \"hello\")) # 打印结果 world hello {0}{1}{2} 有索引位置, 会根据索引位置分别传参. print(\"{1} {0}\".format(\"world\", \"hello\")) # 输出结果 word hello 关键字传参 print(\"我叫{name}, 今年{age}岁\".format(name=\"七里塘\", age = 18)) # 输出结果 我叫七里塘,今年18岁 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:3","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"python3.6 之后新特性 在 字符串前用小写的f 进行生命花括号直接写变量名. print(f\"我叫{name}, 今年{age}岁\") # 输出结果 我叫七里塘,今年18岁 运算符 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:4","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"算数运算符 python支持的算数运算符与数学上计算的符号使用是一致的，我们以x=9，y=2为例来依次介绍它们 比较运算符 比较运算用来对两个值进行比较，返回的是布尔值True或False，我们以x=9，y=2为例来依次介绍它们 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:4:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"赋值运算符 python语法中除了有=号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值、解压赋值，这些赋值运算符存在的意义都是为了让我们的代码看起来更加精简。我们以x=9，y=2为例先来介绍一下增量赋值 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"增量赋值 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:1","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"链式复制 a = b = c = 1 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:2","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"交叉赋值 a = 1 b = 2 a, b = b, a ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:3","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"解压赋值 a, b, c, = [1,2,3] # 输出结果 a = 1 b = 2 c = 3 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:4","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"变量 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:0","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"什么是变量? 变量指的是现实生活中, 某种事物\"特性\"的某种\"衡量状态\" 变量的核心是\"变\"和\"量\" “变” 指的是,这种特性不是一成不变的 “量” 指的是这种衡量状态 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:1","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"为什么要用变量? 是为了让计算机能够像人一样,记录事物特性的状态,方便以后使用. ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:2","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"变量的使用方法 定义变量的语法 x = 1 “x” : 指的是 变量名 相当于门牌号 “=” : 赋值符号 “1” : 变量值 变量名的命名方式 # 变量名应该能提示能反应出值记录的状态 变量名是以数字、字母，下划线组成 不能以数字开头 不能使用python内置关键字 变量名的命名风格 # 推荐使用下划线 下划线 age_of_oldboy = 78 驼峰 AgeOfOldboy = 78 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:3","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"定义一个完整变量所具有的特征 id 变量类型 变量值 \u003e\u003e\u003e x = 1 \u003e\u003e\u003e id(x) 26980696 \u003e\u003e\u003e type(x) \u003ctype 'int'\u003e \u003e\u003e\u003e print(x) ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:4","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"小整数池 1、在交互式模式下 Python实现int的时候有个小整数池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题， Python解释器会在启动时创建出小整数池，范围是[-5,256]，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被GC回收 每创建一个-5到256之间的整数，都是直接从这个池里直接拿走一个值，例如 \u003e\u003e\u003e y=4 \u003e\u003e\u003e id(y) \u003e\u003e\u003e \u003e\u003e\u003e x=3 \u003e\u003e\u003e x+=1 \u003e\u003e\u003e id(x) 2、在pycharm中 但在pycharm中运行python程序，pycharm出于对性能的考虑，会扩大小整数池的范围，其他的字符串等不可变类型也都包含在内一便采用相同的方式处理了，我们只需要记住这是一种优化机制，至于范围到底多大，无需细究 [toc] ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:5","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"Python Python是一种跨平台的[计算机程序设计语言]。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:0","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"Python简介及应用领域 Python是一种解释型脚本语言，可以应用于以下领域: Web 和 Internet开发 科学计算和统计 人工智能 桌面界面开发 软件开发 后端开发 网络爬虫 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:1","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"发展历程 自从20世纪90年代初Python语言诞生至今，它已被逐渐广泛应用于系统管理任务的处理和Web编程。 Python的创始人为荷兰人吉多·范罗苏姆 [4] （Guido van Rossum）。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森的飞行马戏团》（Monty Python’s Flying Circus）。 ABC是由Guido参加设计的一种教学语言。就Guido本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，Guido 认为是其非开放造成的。Guido 决心在Python 中避免这一错误。同时，他还想实现在ABC 中闪现过但未曾实现的东西。 就这样，Python在Guido手中诞生了。可以说，Python是从ABC发展起来，主要受到了Modula-3（另一种相当优美且强大的语言，为小型团体所设计的）的影响。并且结合了[Unix shell](https://baike.baidu.com/item/Unix shell)和C的习惯。 Python [5] 已经成为最受欢迎的程序设计语言之一。自从2004年以后，python的使用率呈线性增长。Python 2于2000年10月16日发布，稳定版本是Python 2.7。Python 3于2008年12月3日发布，不完全兼容Python 2。 [4] 2011年1月，它被TIOBE编程语言排行榜评为2010年度语言。 [6] 由于Python语言的简洁性、易读性以及可扩展性，在国外用Python做科学计算的研究机构日益增多，一些知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学的编程基础、麻省理工学院的计算机科学及编程导论就使用Python语言讲授。众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。而Python专用的科学计算扩 标识 展库就更多了，例如如下3个十分经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。因此Python语言及其众多的扩展库所构成的开发环境十分适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序。2018年3月，该语言作者在邮件列表上宣布Python 2.7将于2020年1月1日终止支持。用户如果想要在这个日期之后继续得到与Python 2.7有关的支持，则需要付费给商业供应商。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:2","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"风格 Python在设计上坚持了清晰划一的风格，这使得Python成为一门易读、易维护，并且被大量用户所欢迎的、用途广泛的语言。 设计者开发时总的指导思想是，对于一个特定的问题，只要有一种最好的方法来解决就好了。这在由Tim Peters写的Python格言（称为The Zen of Python）里面表述为：There should be one– and preferably only one –obvious way to do it. 这正好和Perl语言（另一种功能类似的高级动态语言）的中心思想TMTOWTDI（There’s More Than One Way To Do It）完全相反。 Python的作者有意的设计限制性很强的语法，使得不好的编程习惯（例如if语句的下一行不向右缩进）都不能通过编译。其中很重要的一项就是Python的缩进规则。 一个和其他大多数语言（如C）的区别就是，一个模块的界限，完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号{}来明确的定出模块的边界的，与字符的位置毫无关系）。这一点曾经引起过争议。因为自从C这类的语言诞生后，语言的语法含义与字符的排列方式分离开来，曾经被认为是一种程序语言的进步。不过不可否认的是，通过强制程序员们缩进（包括if，for和函数定义等所有需要使用模块的地方），Python确实使得程序更加清晰和美观。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:3","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"第一个python程序 要开始写代码了, 好高兴呀…QAQ 运行python程序的两种方式 交互式运行 命令行运行 1 # 打开一个文本编辑工具，写入下述代码，并保存文件，此处文件的路径为D:\\test.py。强调：python解释器执行程序是解释执行，解释的根本就是打开文件读内容，因此文件的后缀名没有硬性限制，但通常定义为.py结尾 print(‘hello world’) -2、打开cmd，运行命令，如下图 注释 “#“在行尾巧两个空格 然后输入# 再加一个空格 写注释内容. print(\"我最牛逼\") # 打印我最牛逼 ’’’ 注释内容’’’/ \"”” 注释内容\"\"\" '''打印我最牛逼''' print(\"我最牛逼\") pycharm 的注释的快捷键是 ctrl+? ps: “““也可以是字符串””” print(''' 我最牛逼! 我是最牛逼的! 我在自我暗示. ''') 两者区别是 \"\"\"\"\"\" 可以换行. 代码的注释是在代码行首加上#和空格, 即这段代码被注释掉 # print(\"注释掉我最牛逼\") # 上一行代码不执行 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:4","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"一 编程语言分类 上一节已经把计算机基础讲完了, 也接触了编程语言, 那编程语言怎么分类呢? 容我慢慢装逼…. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:0","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.1 机器语言 也就是计算机能看懂的语言? 那是哪种语言呢? 就是01010101010 这种二进制语言. 开发者不仅要考虑自己的程序, 还要考虑如何调动硬件完成程序的运行 所以开发难度极大. 优点: 计算机运行效率高 缺点: 开发难度大. (这玩意儿简直不是人玩的.) 没示例, 想找示例的 自己去找. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:1","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.2 汇编语言 由于机器语言, 编程难度变态, 就有大佬对计算机进行了升级, 用英文标点代表一组二进制指令, 但是并没有从本质解决需要自己考虑如何调动硬件这件事. 所以开发难度依旧很大. 优点: 计算机相对与机器语言 , 开发效率要高 缺点: 运行效率稍微要低于机器语言. 没示例, 想找自己去找吧, 百度一大把. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:2","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.3 高级语言 高级语言就是站在人类角度, 以人类的语言进行编程. 而人类的字符是在向操作系统直接发指令的. 而不是向计算机硬件. 这里的高级指的是,高层, 开发者不必考虑硬件细节, 因而开发效率得到了极大的提升. 1.3.1 编译型语言 如(c 语言) 此类语言类似 谷歌翻译. 就是把程序代码,翻译成计算机能够识别的二进制指令. 优点: 一次编译后, 就可以重复运行,无需再次翻译 缺点: 编译型代码都是针对某平台翻译的, 所以无法直接拿到另外的平台使用, 即 跨平台能力差 1.3.2 解释型语言 解释型语言, 类似同声传译, 解释器会读取程序代码, 一边翻译, 一遍执行. 优点: 代码运行时依赖解释器的, 所以代码可以跨平台运行. 缺点:每次执行代码都需要翻译 ,所以运行效率低. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:3","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.4 总结 综上所述: 执行效率: 机器语言\u003e汇编语言\u003e编译型语言\u003e解释型语言 开发效率 解释性语言\u003e编译型语言\u003e汇编语言\u003e机器语言 跨平台性 解释性语言有很强的跨平台性 由于我们开发的是应用程序 而应用程序的运行效率更受限于运行平台. 解释性语言有极强的跨平台性, 所以这是我们选择学习python的原因. [toc] ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:4","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":" 未完待续 ","date":"0001-01-01","objectID":"/posts/11-elasticsearch%E4%B9%8B-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/:0:0","tags":null,"title":"","uri":"/posts/11-elasticsearch%E4%B9%8B-%E7%BB%84%E5%90%88%E6%9F%A5%E8%AF%A2/"},{"categories":null,"content":" from elasticsearch import Elasticsearch obj = Elasticsearch() # 创建索引（Index） result = obj.indices.create(index='user', body={\"userid\":'1','username':'lqz'},ignore=400) # print(result) # 删除索引 # result = obj.indices.delete(index='user', ignore=[400, 404]) # 插入数据 # data = {'userid': '1', 'username': 'lqz','password':'123'} # result = obj.create(index='news', doc_type='politics', id=1, body=data) # print(result) # 更新数据 ''' 不用doc包裹会报错 ActionRequestValidationException[Validation Failed: 1: script or doc is missing ''' # data ={'doc':{'userid': '1', 'username': 'lqz','password':'123ee','test':'test'}} # result = obj.update(index='news', doc_type='politics', body=data, id=1) # print(result) # 删除数据 # result = obj.delete(index='news', doc_type='politics', id=1) # 查询 # 查找所有文档 query = {'query': {'match_all': {}}} # 查找名字叫做jack的所有文档 # query = {'query': {'term': {'username': 'lqz'}}} # 查找年龄大于11的所有文档 # query = {'query': {'range': {'age': {'gt': 11}}}} allDoc = obj.search(index='news', doc_type='politics', body=query) print(allDoc['hits']['hits'][0]['_source']) ","date":"0001-01-01","objectID":"/posts/12-elasticsearch%E4%B9%8B-python%E4%BD%BF%E7%94%A8/:0:0","tags":null,"title":"","uri":"/posts/12-elasticsearch%E4%B9%8B-python%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"一 elasticsearch-dsl #安装： pip3 install elasticsearch-dsl #示例 from datetime import datetime from elasticsearch_dsl import Document, Date, Nested, Boolean, \\ analyzer, InnerDoc, Completion, Keyword, Text html_strip = analyzer('html_strip', tokenizer=\"standard\", filter=[\"standard\", \"lowercase\", \"stop\", \"snowball\"], char_filter=[\"html_strip\"] ) class Comment(InnerDoc): author = Text(fields={'raw': Keyword()}) content = Text(analyzer='snowball') created_at = Date() def age(self): return datetime.now() - self.created_at class Post(Document): title = Text() title_suggest = Completion() created_at = Date() published = Boolean() category = Text( analyzer=html_strip, fields={'raw': Keyword()} ) comments = Nested(Comment) class Index: name = 'blog' def add_comment(self, author, content): self.comments.append( Comment(author=author, content=content, created_at=datetime.now())) def save(self, ** kwargs): self.created_at = datetime.now() return super().save(** kwargs) ","date":"0001-01-01","objectID":"/posts/13-elasticsearch%E4%B9%8B-django_flask%E9%9B%86%E6%88%90/:1:0","tags":null,"title":"","uri":"/posts/13-elasticsearch%E4%B9%8B-django_flask%E9%9B%86%E6%88%90/"},{"categories":null,"content":"二 django集成 from datetime import datetime from elasticsearch_dsl import Document, Date, Nested, Boolean,analyzer, InnerDoc, Completion, Keyword, Text,Integer from elasticsearch_dsl.connections import connections connections.create_connection(hosts=[\"localhost\"]) class Article(Document): title = Text(analyzer='ik_max_word', search_analyzer=\"ik_max_word\", fields={'title': Keyword()}) author = Text() class Index: name = 'myindex' def save(self, ** kwargs): return super(Article, self).save(** kwargs) if __name__ == '__main__': # Article.init() # 创建映射 # 保存数据 # article = Article() # article.title = \"测试测试\" # article.save() # 数据就保存了 #查询数据 # s=Article.search() # s = s.filter('match', title=\"测试\") # # results = s.execute() # print(results) #删除数据 # s = Article.search() # s = s.filter('match', title=\"测试\").delete() #修改数据 # s = Article().search() # s = s.filter('match', title=\"测试\") # results = s.execute() # print(results[0]) # results[0].title=\"xxx\" # results[0].save() ","date":"0001-01-01","objectID":"/posts/13-elasticsearch%E4%B9%8B-django_flask%E9%9B%86%E6%88%90/:2:0","tags":null,"title":"","uri":"/posts/13-elasticsearch%E4%B9%8B-django_flask%E9%9B%86%E6%88%90/"}]