[{"categories":["ElasticSearch"],"content":"Elasticsearch 常用的es 查询 ","date":"2020-09-05","objectID":"/posts/elasticsearch-09-term%E4%B8%8Ematch/:0:0","tags":["配置"],"title":"Elasticsearch term 与 match","uri":"/posts/elasticsearch-09-term%E4%B8%8Ematch/"},{"categories":["ElasticSearch"],"content":"准备数据 PUT zhifou/doc/1 { \"name\":\"顾老二\", \"age\":30, \"from\": \"gu\", \"desc\": \"皮肤黑、武器长、性格直\", \"tags\": [\"黑\", \"长\", \"直\"] } PUT zhifou/doc/2 { \"name\":\"大娘子\", \"age\":18, \"from\":\"sheng\", \"desc\":\"肤白貌美，娇憨可爱\", \"tags\":[\"白\", \"富\",\"美\"] } PUT zhifou/doc/3 { \"name\":\"龙套偏房\", \"age\":22, \"from\":\"gu\", \"desc\":\"mmp，没怎么看，不知道怎么形容\", \"tags\":[\"造数据\", \"真\",\"难\"] } PUT zhifou/doc/4 { \"name\":\"石头\", \"age\":29, \"from\":\"gu\", \"desc\":\"粗中有细，狐假虎威\", \"tags\":[\"粗\", \"大\",\"猛\"] } PUT zhifou/doc/5 { \"name\":\"魏行首\", \"age\":25, \"from\":\"广云台\", \"desc\":\"仿佛兮若轻云之蔽月,飘飘兮若流风之回雪,mmp，最后竟然没有嫁给顾老二！\", \"tags\":[\"闭月\",\"羞花\"] } ","date":"2020-09-05","objectID":"/posts/elasticsearch-09-term%E4%B8%8Ematch/:0:1","tags":["配置"],"title":"Elasticsearch term 与 match","uri":"/posts/elasticsearch-09-term%E4%B8%8Ematch/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 简单操作 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:0:0","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"前言 现在，让我们启动一个节点和kibana。 接下来的一切操作都在kibana中Dev Tools下的Console里完成。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:0","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"创建一篇文档 现在，我们试图将小黑的小姨妈的个人信息录入elasticsearch。我们只要输入： PUT t1/doc/1 { \"name\": \"小黑的小姨妈\", \"age\": 18 } PUT表示创建命令。虽然命令可以小写，但是我们推荐大写。在以REST ful风格返回的结果中： { \"_index\" : \"t1\", \"_type\" : \"type1\", \"_id\" : \"1\", \"_version\" : 1, \"result\" : \"created\", \"_shards\" : { \"total\" : 2, \"successful\" : 1, \"failed\" : 0 }, \"_seq_no\" : 0, \"_primary_term\" : 1 } 结果中的result则是操作类型，现在是created，表示第一次创建。如果我们再次点击执行该命令，那么result则会是updated。我们细心则会发现_version开始是1，现在你每点击一次就会增加一次。表示第几次更改。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:1","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询所有索引 现在，我们再来学习一条命令： GET _cat/indices?v 返回的结果如下图： 上图中，展示当前集群中索引情况，包括，索引的健康状况、UUID、主副分片个数、大小等信息。你发现我们创建的t1索引了吗？ ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:2","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询指定的索引信息 我们来单独看看t1索引： GET t1 返回的结果如下： { \"t1\" : { \"aliases\" : { }, \"mappings\" : { \"doc\" : { \"properties\" : { \"age\" : { \"type\" : \"long\" }, \"name\" : { \"type\" : \"text\", \"fields\" : { \"keyword\" : { \"type\" : \"keyword\", \"ignore_above\" : 256 } } } } } }, \"settings\" : { \"index\" : { \"creation_date\" : \"1553163739688\", \"number_of_shards\" : \"5\", \"number_of_replicas\" : \"1\", \"uuid\" : \"_7jNW5XATheeK84zKkPwlw\", \"version\" : { \"created\" : \"6050499\" }, \"provided_name\" : \"t1\" } } } } 返回了t1索引的创建信息。 ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:3","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"查询文档信息 那我们来查看我们刚才创建的那篇文档： GET t1/doc/1 返回的结果如下： Copy{ \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_version\" : 2, \"found\" : true, \"_source\" : { \"name\" : \"小黑的小姨妈\", \"age\" : 18 } } 返回了我们刚才创建的文档信息。 我们再来为小黑添加两个姨妈： CopyPUT t1/doc/2 { \"name\": \"小黑的二姨妈\", \"age\": 16 } PUT t1/doc/3 { \"name\": \"小黑的三姨妈\", \"age\": 19 } 刚才，我们学会了查询小黑的一个姨妈，那么该如何查询所有姨妈呢？ GET t1/doc/_search 返回结果如下： Copy{ \"took\" : 7, \"timed_out\" : false, \"_shards\" : { \"total\" : 5, \"successful\" : 5, \"skipped\" : 0, \"failed\" : 0 }, \"hits\" : { \"total\" : 3, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"2\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的二姨妈\", \"age\" : 16 } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"1\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的小姨妈\", \"age\" : 18 } }, { \"_index\" : \"t1\", \"_type\" : \"doc\", \"_id\" : \"3\", \"_score\" : 1.0, \"_source\" : { \"name\" : \"小黑的三姨妈\", \"age\" : 19 } } ] } } 现在小黑跟他的姨妈们闹了别扭，就想删除这个姨妈，该怎么办呢？ ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:4","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"删除指定索引 我们其实直接删除这个t1索引就可以了： DELETE /t1 DELETE 是删除命令，返回结果如下： { \"acknowledged\" : true } 返回结果提示删除确认成功。 如果此时再查询索引情况，则会发现t1已经不存在了，所有的文档也就不存在了。 欢迎斧正，that’s all ","date":"2020-09-05","objectID":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/:1:5","tags":["配置"],"title":"Elasticsearch 简单操作","uri":"/posts/elasticsearch-08-es%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目 ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:0","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"Docker 配置桥接 #　创建网桥 docker network create -d bridge my-bridge # es 连接　网桥 docker network connect my-bridge es-a # kibana 连接网桥 docker network connect my-bridge kibana ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:1","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"修改kibana　配置文件 # 查看　es-a　容器　所在　公用网桥中的　ip sudo docker inspect es-a \"my-bridge\": { \"IPAMConfig\": {}, \"Links\": null, \"Aliases\": [ \"9f05d30f9f9e\" ], \"Gateway\": \"172.19.0.1\", \"IPAddress\": \"172.19.0.2\", \"IPPrefixLen\": 16, \"IPv6Gateway\": \"\", \"GlobalIPv6Address\": \"\", \"GlobalIPv6PrefixLen\": 0, \"MacAddress\": \"02:42:ac:13:00:02\", \"DriverOpts\": {} } # 可以看到　在网桥中的　ip　为　\"IPAddress\": \"172.19.0.2\", # kibana 配置文件　设置　es 容器所在的ip elasticsearch.hosts: [\"http://172.19.0.2:9200\"] # 设置完成后　需要重启容器　才能生效（真香） ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:2","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"使用elasticsearch-head　开元项目对es进行管理 git clone https://github.com/mobz/elasticsearch-head.git cd elasticsearch-head npm install npm run start open http://localhost:9100/ ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:3","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"ElasticSearch　解决跨域问题(head　与　es 连接问题) # 在es 配置文件中　加入以下配置　解决跨域问题 http.cors.enabled: true http.cors.allow-origin: \"*\" ","date":"2020-09-04","objectID":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/:0:4","tags":["配置"],"title":"Elasticsearch 与Kibana通讯及 es-head 开源管理项目","uri":"/posts/elasticsearch-07-kibana-%E4%B8%8E-es-%E8%BF%9E%E6%8E%A5/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 配置文件详解 ##################### Elasticsearch Configuration Example ##################### # # 只是挑些重要的配置选项进行注释,其实自带的已经有非常细致的英文注释了! # https://www.elastic.co/guide/en/elasticsearch/reference/current/modules.html # ################################### Cluster ################################### # 代表一个集群,集群中有多个节点,其中有一个为主节点,这个主节点是可以通过选举产生的,主从节点是对于集群内部来说的. # es的一个概念就是去中心化,字面上理解就是无中心节点,这是对于集群外部来说的,因为从外部来看es集群,在逻辑上是个整体,你与任何一个节点的通信和与整个es集群通信是等价的。 # cluster.name可以确定你的集群名称,当你的elasticsearch集群在同一个网段中elasticsearch会自动的找到具有相同cluster.name的elasticsearch服务. # 所以当同一个网段具有多个elasticsearch集群时cluster.name就成为同一个集群的标识. # cluster.name: elasticsearch #################################### Node ##################################### # https://www.elastic.co/guide/en/elasticsearch/reference/5.1/modules-node.html#master-node # 节点名称同理,可自动生成也可手动配置. # node.name: node-1 # 允许一个节点是否可以成为一个master节点,es是默认集群中的第一台机器为master,如果这台机器停止就会重新选举master. # node.master: true # 允许该节点存储数据(默认开启) # node.data: true # 配置文件中给出了三种配置高性能集群拓扑结构的模式,如下： # 1. 如果你想让节点从不选举为主节点,只用来存储数据,可作为负载器 # node.master: false # node.data: true # node.ingest: false # 2. 如果想让节点成为主节点,且不存储任何数据,并保有空闲资源,可作为协调器 # node.master: true # node.data: false # node.ingest: false # 3. 如果想让节点既不称为主节点,又不成为数据节点,那么可将他作为搜索器,从节点中获取数据,生成搜索结果等 # node.master: false # node.data: false # node.ingest: true (可不指定默认开启) # 4. 仅作为协调器 # node.master: false # node.data: false # node.ingest: false # 监控集群状态有一下插件和API可以使用: # Use the Cluster Health API [http://localhost:9200/_cluster/health], the # Node Info API [http://localhost:9200/_nodes] or GUI tools # such as \u003chttp://www.elasticsearch.org/overview/marvel/\u003e, # \u003chttp://github.com/karmi/elasticsearch-paramedic\u003e, # \u003chttp://github.com/lukas-vlcek/bigdesk\u003e and # \u003chttp://mobz.github.com/elasticsearch-head\u003e to inspect the cluster state. # A node can have generic attributes associated with it, which can later be used # for customized shard allocation filtering, or allocation awareness. An attribute # is a simple key value pair, similar to node.key: value, here is an example: # 每个节点都可以定义一些与之关联的通用属性，用于后期集群进行碎片分配时的过滤 # node.rack: rack314 # 默认情况下，多个节点可以在同一个安装路径启动，如果你想让你的es只启动一个节点，可以进行如下设置 # node.max_local_storage_nodes: 1 #################################### Index #################################### # 设置索引的分片数,默认为5 #index.number_of_shards: 5 # 设置索引的副本数,默认为1: #index.number_of_replicas: 1 # 配置文件中提到的最佳实践是,如果服务器够多,可以将分片提高,尽量将数据平均分布到大集群中去 # 同时,如果增加副本数量可以有效的提高搜索性能 # 需要注意的是,\"number_of_shards\" 是索引创建后一次生成的,后续不可更改设置 # \"number_of_replicas\" 是可以通过API去实时修改设置的 #################################### Paths #################################### # 配置文件存储位置 # path.conf: /path/to/conf # 数据存储位置(单个目录设置) # path.data: /path/to/data # 多个数据存储位置,有利于性能提升 # path.data: /path/to/data1,/path/to/data2 # 临时文件的路径 # path.work: /path/to/work # 日志文件的路径 # path.logs: /path/to/logs # 插件安装路径 # path.plugins: /path/to/plugins #################################### Plugin ################################### # 设置插件作为启动条件,如果一下插件没有安装,则该节点服务不会启动 # plugin.mandatory: mapper-attachments,lang-groovy ################################### Memory #################################### # 当JVM开始写入交换空间时（swapping）ElasticSearch性能会低下,你应该保证它不会写入交换空间 # 设置这个属性为true来锁定内存,同时也要允许elasticsearch的进程可以锁住内存,linux下可以通过 `ulimit -l unlimited` 命令 # bootstrap.mlockall: true # 确保 ES_MIN_MEM 和 ES_MAX_MEM 环境变量设置为相同的值,以及机器有足够的内存分配给Elasticsearch # 注意:内存也不是越大越好,一般64位机器,最大分配内存别才超过32G ############################## Network And HTTP ############################### # 设置绑定的ip地址,可以是ipv4或ipv6的,默认为0.0.0.0 # network.bind_host: 192.168.0.1 # 设置其它节点和该节点交互的ip地址,如果不设置它会自动设置,值必须是个真实的ip地址 # network.publish_host: 192.168.0.1 # 同时设置bind_host和publish_host上面两个参数 # network.host: 192.168.0.1 # 设置节点间交互的tcp端口,默认是9300 # transport.tcp.port: 9300 # 设置是否压缩tcp传输时的数据，默认为false,不压缩 # transport.tcp.compress: true # 设置对外服务的http端口,默认为9200 # http.port: 9200 # 设置请求内容的最大容量,默认100mb # http.max_content_length: 100mb # 使用http协议对外提供服务,默认为true,开启 # http.enabled: false ###################### 使用head等插件监控集群信息，需要打开以下配置项 ########### # http.c","date":"2020-09-03","objectID":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:0","tags":["配置"],"title":"Elasticsearch 配置文件详解","uri":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["ElasticSearch"],"content":"最新配置 cluster.name: elasticsearch # 配置的集群名称，默认是elasticsearch，es服务会通过广播方式自动连接在同一网段下的es服务，通过多播方式进行通信，同一网段下可以有多个集群，通过集群名称这个属性来区分不同的集群 node.name: \"Franz Kafka\" # 当前配置所在机器的节点名 node.master: true 指定该节点是否有资格被选举成为node（注意这里只是设置成有资格),默认true node.data: true # 指定该节点是否存储索引数据，默认为true。 index.number_of_shards: 5 # 设置默认索引分片个数，默认为5片。7.X版本以上配置无效 index.number_of_replicas: 1 # 设置默认索引副本个数，默认为1个副本。7.x版本以上配置无效 path.conf: /path/to/conf # 设置配置文件的存储路径，默认是es根目录下的config文件夹。 path.data: /path/to/data # 设置索引数据的存储路径 path.work: /path/to/work # 设置临时文件的存储路径 path.logs: /path/to/logs # 设置日志文件的存储路径 path.plugins: /path/to/plugins # 设置插件的存放路径 network.bind_host: 192.168.0.1 # 设置绑定的ip地址，可以是ipv4或ipv6的，默认为0.0.0.0，绑定这台机器的任何一个ip。 network.publish_host: 192.168.0.1 # 设置其它节点和该节点交互的ip地址，如果不设置它会自动判断，值必须是个真实的ip地址。 network.host: 192.168.0.1 # 这个参数是用来同时设置bind_host和publish_host上面两个参数。 transport.tcp.port: 9300 # 设置节点之间交互的tcp端口，默认是9300。 transport.tcp.compress: true # 设置是否压缩tcp传输时的数据，默认为false，不压缩。 http.port: 9200 # 设置对外服务的http端口，默认为9200。 http.max_content_length: 100mb # 设置内容的最大容量，默认100mb http.enabled: false # 是否使用http协议对外提供服务，默认为true，开启。 gateway.type: local # gateway的类型，默认为local即为本地文件系统，可以设置为本地文件系统，分布式文件系统，hadoop的HDFS，和amazon的s3服务器等。 cluster.routing.allocation.node_initial_primaries_recoveries: 4 # 初始化数据恢复时，并发恢复线程的个数，默认为4。 cluster.routing.allocation.node_concurrent_recoveries: 2 # 添加删除节点或负载均衡时并发恢复线程的个数，默认为4。 indices.recovery.max_size_per_sec: 0 # 设置数据恢复时限制的带宽，如入100mb，默认为0，即无限制。 indices.recovery.concurrent_streams: 5 # 设置这个参数来限制从其它分片恢复数据时最大同时打开并发流的个数，默认为5。 discovery.zen.minimum_master_nodes: 1 # 设置这个参数来保证集群中的节点可以知道其它N个有master资格的节点。默认为1，对于大的集群来说，可以设置大一点的值（2-4）。7.x版本无效 discovery.zen.ping.timeout: 3s # 设置集群中自动发现其它节点时ping连接超时时间，默认为3秒，对于比较差的网络环境可以高点的值来防止自动发现时出错。7.x版本无效 discovery.zen.ping.multicast.enabled: false # 设置是否打开多播发现节点，默认是true。7.x版本无效 discovery.zen.ping.unicast.hosts: [\"host1\", \"host2:port\", \"host3[portX-portY]\"] # 设置集群中master节点的初始列表，可以通过这些节点来自动发现新加入集群的节点。7.x版本无效 discovery.seed_hosts # 在启动此节点时传递要执行发现的主机的初始列表 cluster.initial_master_nodes # 使用初始的一组符合主节点条件的节点引导集群 ","date":"2020-09-03","objectID":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/:0:1","tags":["配置"],"title":"Elasticsearch 配置文件详解","uri":"/posts/elasticsearch-06-es-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"},{"categories":["ElasticSearch"],"content":"docker 容器安装 Kibana Kibana ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:0:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"挂载 在宿主机上创建kibana config配置目录 eg: 配置文件 mkdir /home/zhang/Document/Kibana/config ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:1:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"Kibana配置 在/home/zhang/Document/Kibana/config目录下创建kibana.yml，具体内容如下： # Kibana is served by a back end server. This setting specifies the port to use. server.port: 5602 # Specifies the address to which the Kibana server will bind. IP addresses and host names are both valid values. # The default is 'localhost', which usually means remote machines will not be able to connect. # To allow connections from remote users, set this parameter to a non-loopback address. server.host: 0.0.0.0 # Enables you to specify a path to mount Kibana at if you are running behind a proxy. # Use the `server.rewriteBasePath` setting to tell Kibana if it should remove the basePath # from requests it receives, and to prevent a deprecation warning at startup. # This setting cannot end in a slash. #server.basePath: \"\" # Specifies whether Kibana should rewrite requests that are prefixed with # `server.basePath` or require that they are rewritten by your reverse proxy. # This setting was effectively always `false` before Kibana 6.3 and will # default to `true` starting in Kibana 7.0. #server.rewriteBasePath: false # The maximum payload size in bytes for incoming server requests. #server.maxPayloadBytes: 1048576 # The Kibana server's name. This is used for display purposes. #server.name: \"your-hostname\" # The URLs of the Elasticsearch instances to use for all your queries. elasticsearch.hosts: [\"http://10.133.0.188:9201\"] # When this setting's value is true Kibana uses the hostname specified in the server.host # setting. When the value of this setting is false, Kibana uses the hostname of the host # that connects to this Kibana instance. #elasticsearch.preserveHost: true # Kibana uses an index in Elasticsearch to store saved searches, visualizations and # dashboards. Kibana creates a new index if the index doesn't already exist. #kibana.index: \".kibana\" # The default application to load. #kibana.defaultAppId: \"home\" # If your Elasticsearch is protected with basic authentication, these settings provide # the username and password that the Kibana server uses to perform maintenance on the Kibana # index at startup. Your Kibana users still need to authenticate with Elasticsearch, which # is proxied through the Kibana server. #elasticsearch.username: \"kibana\" #elasticsearch.password: \"pass\" # Enables SSL and paths to the PEM-format SSL certificate and SSL key files, respectively. # These settings enable SSL for outgoing requests from the Kibana server to the browser. #server.ssl.enabled: false #server.ssl.certificate: /path/to/your/server.crt #server.ssl.key: /path/to/your/server.key # Optional settings that provide the paths to the PEM-format SSL certificate and key files. # These files are used to verify the identity of Kibana to Elasticsearch and are required when # xpack.security.http.ssl.client_authentication in Elasticsearch is set to required. #elasticsearch.ssl.certificate: /path/to/your/client.crt #elasticsearch.ssl.key: /path/to/your/client.key # Optional setting that enables you to specify a path to the PEM file for the certificate # authority for your Elasticsearch instance. #elasticsearch.ssl.certificateAuthorities: [ \"/path/to/your/CA.pem\" ] # To disregard the validity of SSL certificates, change this setting's value to 'none'. #elasticsearch.ssl.verificationMode: full # Time in milliseconds to wait for Elasticsearch to respond to pings. Defaults to the value of # the elasticsearch.requestTimeout setting. #elasticsearch.pingTimeout: 1500 # Time in milliseconds to wait for responses from the back end or Elasticsearch. This value # must be a positive integer. #elasticsearch.requestTimeout: 30000 # List of Kibana client-side headers to send to Elasticsearch. To send *no* client-side # headers, set this value to [](an empty list). #elasticsearch.requestHeadersWhitelist: [ authorization ] # Header names and values that are sent to Elasticsearch. Any custom headers cannot be overwritten # by client-side headers, regardless of the elasticsearch.requestHeaders","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:2:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"启动 创建docker-compose.yml文件，内容如下： version: '2.2' services: kibana: image: kibana:7.6.2 volumes: - ./kibana.yml:/usr/share/kibana/config/kibana.yml ports: - '5602:5602/tcp' 启动： docker-compose up -d ","date":"2020-09-03","objectID":"/posts/elasticsearch-05-kibana/:3:0","tags":["Docker","Kibana"],"title":"Kibana Docker 容器安装","uri":"/posts/elasticsearch-05-kibana/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:0:0","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"Elasticsearch 以7.2.0为例 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:0","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"挂载 在宿主机上创建Elasticsearch的数据存储、config配置目录 eg: # 在 Document 下创建 ElasticSearch 文件夹， 然后再创建 conf data logs 文件夹 用于放置 es的数据， 配置 ， 日志文件 mkdir ELasticSearch cd ElasticSearch mkdir config mkdir logs mkdir data 新建用户 adduser es 数据存储需要赋予权限：sudo chown -R 1000:1000 ~/ELasticSearch/data ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:1","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"Elasticsearch配置 在 ~/ELasticSearch/data/config文件夹下新建elasticsearch.yml、 jvm.options 具体内容可以参考： elasticsearch.yml cluster.name: business-log node.name: es-b-188 http.port: 9200 transport.tcp.port: 9301 network.bind_host: 10.133.0.188 network.publish_host: 10.133.0.188 jvm.options ## JVM configuration ################################################################ ## IMPORTANT: JVM heap size ################################################################ ## ## You should always set the min and max JVM heap ## size to the same value. For example, to set ## the heap to 4 GB, set: ## ## -Xms4g ## -Xmx4g ## ## See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html ## for more information ## ################################################################ # Xms represents the initial size of total heap space # Xmx represents the maximum size of total heap space -Xms26g -Xmx26g ################################################################ ## Expert settings ################################################################ ## ## All settings below this section are considered ## expert settings. Don't tamper with them unless ## you understand what you are doing ## ################################################################ ## GC configuration #-XX:+UseConcMarkSweepGC #-XX:CMSInitiatingOccupancyFraction=75 #-XX:+UseCMSInitiatingOccupancyOnly ## G1GC Configuration # NOTE: G1GC is only supported on JDK version 10 or later. # To use G1GC uncomment the lines below. #-XX:-UseConcMarkSweepGC #-XX:-UseCMSInitiatingOccupancyOnly -XX:+UseG1GC -XX:InitiatingHeapOccupancyPercent=75 ## DNS cache policy # cache ttl in seconds for positive DNS lookups noting that this overrides the # JDK security property networkaddress.cache.ttl; set to -1 to cache forever -Des.networkaddress.cache.ttl=60 # cache ttl in seconds for negative DNS lookups noting that this overrides the # JDK security property networkaddress.cache.negative ttl; set to -1 to cache # forever -Des.networkaddress.cache.negative.ttl=10 ## optimizations # pre-touch memory pages used by the JVM during initialization -XX:+AlwaysPreTouch ## basic # explicitly set the stack size -Xss1m # set to headless, just in case -Djava.awt.headless=true # ensure UTF-8 encoding by default (e.g. filenames) -Dfile.encoding=UTF-8 # use our provided JNA always versus the system one -Djna.nosys=true # turn off a JDK optimization that throws away stack traces for common # exceptions because stack traces are important for debugging -XX:-OmitStackTraceInFastThrow # flags to configure Netty -Dio.netty.noUnsafe=true -Dio.netty.noKeySetOptimization=true -Dio.netty.recycler.maxCapacityPerThread=0 # log4j 2 -Dlog4j.shutdownHookEnabled=false -Dlog4j2.disable.jmx=true -Djava.io.tmpdir=${ES_TMPDIR} ## heap dumps # generate a heap dump when an allocation from the Java heap fails # heap dumps are created in the working directory of the JVM -XX:+HeapDumpOnOutOfMemoryError # specify an alternative path for heap dumps; ensure the directory exists and # has sufficient space -XX:HeapDumpPath=data # specify an alternative path for JVM fatal error logs -XX:ErrorFile=logs/hs_err_pid%p.log ## JDK 8 GC logging 8:-XX:+PrintGCDetails 8:-XX:+PrintGCDateStamps 8:-XX:+PrintTenuringDistribution 8:-XX:+PrintGCApplicationStoppedTime 8:-Xloggc:logs/gc.log 8:-XX:+UseGCLogFileRotation 8:-XX:NumberOfGCLogFiles=32 8:-XX:GCLogFileSize=64m # JDK 9+ GC logging 9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m # due to internationalization enhancements in JDK 9 Elasticsearch need to set the provider to COMPAT otherwise # time/date parsing will break in an incompatible way for some date patterns and locals 9-:-Djava.locale.providers=COMPAT 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:2","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"启动 创建docker-compose.yml文件，内容如下： version: '2.2' services: elasticsearch: image: elasticsearch:7.2.0 restart: always container_name: es-a network_mode: host volumes: - /home/zhang/Documents/ElasticSearch/data-a:/usr/share/elasticsearch/data - /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml - /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options environment: - bootstrap.memory_lock=true - ES_JAVA_OPTS= -Xms64m -Xmx128m ulimits: memlock: soft: -1 hard: -1 启动： docker-compose up -d # 在使用 docker-compose 创建容器的过程中 创建端口映射不成功 所以使用一下命令创建， 可解决此问题。 sudo docker run -id --name=es-a -p 9200:9200 -p 9300:9300 -v /home/zhang/Documents/ElasticSearch/data/data-a:/usr/share/elasticsearch/data -v /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS= -Xms1024m -Xmx1024m\" elasticsearch:7.2.0 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:3","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"备注 elasticsearch.yml、jvm.options、docker-compose.yml等每个节点都需要配置，其中elasticsearch.yml、docker-compose.yml具体节点信息需要替换。 ","date":"2020-09-02","objectID":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/:1:4","tags":["Docker"],"title":"使用docker安装Elasticsearch 集群","uri":"/posts/elasticsearch-04-docker-%E9%9B%86%E7%BE%A4/"},{"categories":["ElasticSearch"],"content":"什么是 Apache Lucene ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:0","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"有必要了解的有Apache Apache软件基金会（也就是Apache Software Foundation，简称为ASF）是专门为运作一个开源软件项目的Apache 的团体提供支持的非盈利性组织，这个开源软件的项目就是 Apache 项目。 最初，Apache基金会的开发爱好者开发并维护一个叫Apache的HTTP服务器。 后来，Apache服务器越来越火，就启动了更多的项目，比如PHP、Java Apache以及更多的子项目。比如Jakarta。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:1","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"Jakarta Jakarta是为了发展Java容器而启动的Java Apache的项目。后来随着Java的火爆而成为了囊括了众多基于Java语言开源软件子项目的项目。比如从这里孵化出了Tomcat、[ant](https://baike.baidu.com/item/apache ant/1065741?fr=aladdin)、Struts、Lucene。Jakarta ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:2","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"Lucene Lucene是Apache软件基金会4 jakarta项目的子项目。它是一个开源的全文检索引擎工具包。但它并不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。Lucene是一套用于全文检索和搜寻的开源程式库，由Apache软件基金会支持和提供。Lucene提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在Java开发环境里Lucene是一个成熟的免费开源工具。 最后，引用来自《Elasticsearch权威指南》书中关于Lucene的描述作为总结： Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:3","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"常见的开源搜索引擎 基于Lucene的搜索引擎，Java开发，包括： Lucene Solr elasticsearch katta compass 基于C++开发的： Sphinx 你可以想想Lucene的强大。接下来简要的介绍各搜索引擎的特点。 Lucene Lucene的开发语言是Java，也是Java家族中最为出名的一个开源搜索引擎，在Java世界中已经是标准的全文检索程序，它提供了完整的查询引擎和索引引擎，没有中文分词引擎，需要自己去实现，因此用Lucene去做一个搜素引擎需要自己去架构，另外它不支持实时搜索。 优点： 成熟的解决方案，有很多的成功案例。apache 顶级项目，正在持续快速的进步。庞大而活跃的开发社区，大量的开发人员。它只是一个类库，有足够的定制和优化空间：经过简单定制，就可以满足绝大部分常见的需求；经过优化，可以支持 10亿+ 量级的搜索 缺点： 需要额外的开发工作。所有的扩展，分布式，可靠性等都需要自己实现；非实时，从建索引到可以搜索中间有一个时间延迟，而当前的“近实时”(Lucene Near Real Time search)搜索方案的可扩展性有待进一步完善 Solr Solr是一个企业级的高性能、采用Java开发，基于Lucene的全文搜索服务器。 文档通过Http利用XML加到一个搜索集合中。 查询该集合也是通过 http收到一个XML/JSON响应来实现。它的主要特性包括：高效、灵活的缓存功能，垂直搜索功能，高亮显示搜索结果，通过索引复制来提高可用性，提 供一套强大Data Schema来定义字段，类型和设置文本分析，提供基于Web的管理界面等。 优点： Solr有一个更大、更成熟的用户、开发和贡献者社区 支持添加多种格式的索引，如：HTML、PDF、微软 Office 系列软件格式以及 JSON、XML、CSV 等纯文本格式 Solr比较成熟、稳定 不考虑建索引的同时进行搜索，速度更快 缺点： 建立索引时，搜索效率下降，实时索引搜索效率不高 Sphinx Sphinx一个基于SQL的全文检索引擎，特别为一些脚本语言（PHP,Python，Perl，Ruby）设计搜索API接口。 Sphinx是一个用C++语言写的开源搜索引擎，也是现在比较主流的搜索引擎之一，在建立索引的时间方面比Lucene快50%，但是索引文件比Lucene要大一倍，因此Sphinx在索引的建立方面是空间换取时间的策略，在检索速度上，和lucene相差不大，但检索精准度方面Lucene要优于Sphinx，另外在加入中文分词引擎难度方面，Lucene要优于Sphinx.其中Sphinx支持实时搜索，使用起来比较简单方便. Sphinx可以非常容易的与SQL数据库和脚本语言集成。当前系统内置MySQL和PostgreSQL 数据库数据源的支持，也支持从标准输入读取特定格式 的XML数据。通过修改源代码，用户可以自行增加新的数据源（例如：其他类型的DBMS 的原生支持） Sphinx的特点： 高速的建立索引(在当代CPU上，峰值性能可达到10 MB/秒) 高性能的搜索(在2 – 4GB 的文本数据上，平均每次检索响应时间小于0.1秒) 可处理海量数据(目前已知可以处理超过100 GB的文本数据, 在单一CPU的系统上可 处理100 M 文档) 提供了优秀的相关度算法，基于短语相似度和统计（BM25）的复合Ranking方法 支持分布式搜索 支持短语搜索 提供文档摘要生成 可作为MySQL的存储引擎提供搜索服务 支持布尔、短语、词语相似度等多种检索模式 文档支持多个全文检索字段(最大不超过32个) 文档支持多个额外的属性信息(例如：分组信息，时间戳等) 支持断词 ElasticSearch ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 优点： 分布式：节点对外表现对等，加入节点自动均衡 elasticsearch完全支持Apache Lucene的接近实时的搜索 各节点组成对等的网络结构，当某个节点出现故障时会自动分配其他节点代替期进行工作 横向可扩展性，如果你需要增加一台服务器，只需要做点配置，然后启动就完事了 高可用：提供复制（replica）机制，一个分片可以设置多个复制，使得某台服务器宕机的情况下，集群仍旧可以照常运行，并会把由于服务器宕机丢失的复制恢复到其它可用节点上；这点也类似于HDFS的复制机制（HDFS中默认是3份复制） 缺点： 不支持事物 相对吃内存 see also：Apache Lucene | 开源搜索引擎分类 | ElasticSearch vs Solr多维度分析对比 | Lucene：基于Java的全文检索引擎简介 欢迎斧正，that’s all ","date":"2020-08-31","objectID":"/posts/elasticsearch-02-apache-lucene/:0:4","tags":["Lucene"],"title":"Apache Lucene","uri":"/posts/elasticsearch-02-apache-lucene/"},{"categories":["ElasticSearch"],"content":"在linux 上安装 elasticsearch ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:0","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"前言 由于elasticsearch依赖java环境，所以，我们首先要安装java jdk。 这里我们使es和kibana的版本保持一致，环境如下： centos7.3 java1.8 elasticsearch6.7.0 kibana6.7.0 ik6.7.0 另外，要检查一下防火墙是否关闭： Copyfirewall-cmd --state # 检查防火墙是否关闭 systemctl stop firewalld.service # 停止firewall systemctl disable firewalld.service # 禁止开机启动 ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:1","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"Docker 安装 es 拉取镜像 sudo docker pull elasticsearch:7.2.0 等待下载完成， （选择docker是因为 docker比较轻便 不会出现各种各样的 java环境问题） 创建容器 # 在 Document 下创建 ElasticSearch 文件夹， 然后再创建 conf data logs 文件夹 用于放置 es的数据， 配置 ， 日志文件 mkdir ELasticSearch cd ElasticSearch mkdir conf mkdir logs mkdir data # 使用run 命令 创建 es 容器 sudo docker run -id --name=es-a -p 9200:9200 -p 9300:9300 -v /home/zhang/Documents/ElasticSearch/data/data-a:/usr/share/elasticsearch/data -v /home/zhang/Documents/ElasticSearch/config/el-a.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /home/zhang/Documents/ElasticSearch/config/jvm.options:/usr/share/elasticsearch/config/jvm.options -e \"discovery.type=single-node\" -e \"ES_JAVA_OPTS= -Xms1024m -Xmx1024m\" elasticsearch:7.2.0 sudo curl -L https://github.com/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose sudo curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0-rc2/docker-compose-Linux-x86_64 -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-compose ","date":"2020-08-31","objectID":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/:0:2","tags":["linux安装"],"title":"Linux 安装 Elasticsearch","uri":"/posts/elasticsearch-03-linux%E5%AE%89%E8%A3%85/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:0","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"什么是ElasticSearch 现在，你还离得开搜索吗？无论是Google还是百度提供的搜索入口，还是项目自己的搜索，比如QQ提供的搜索入口等等，都大大的方便了我们的工作、生活。但是你有没有想过——搭建属于自己的搜索服务，应用于你的博客项目、公司项目…… 无论你想不想，都要学习！因为随着公司业务的增长，数据也爆炸性增长。对于数据的处理、日志分析，如果还采用传统的方法，这恐怕是灾难性的。所以，我们是时候学习一个先进的搜索引擎了。 Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发语言并将其直接集成到你的应用中，更糟糕的是，Lucene非常复杂，你需要深入了解检索的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。 你以为这些就完了？elasticsearch除了Lucene和全文搜索，我们还可以描述它： 分布式的实时文件存储，每个字段都被索引并可被搜索 分布式的实时分析搜索引擎 可以扩展到上百台服务器，处理PB级结构化或非结构化数据。 并且，这些功能都被集成到一个服务里面，elasticsearch也提供的与其它语言的接口，其中包括： Java JavaScript Groovy .NET PHP Perl Python Ruby 以及社区贡献的更多接口 使用我们喜欢的语言通过RESTful API接口，访问9200端口，就可以与elasticsearch玩耍了。 上手elasticsearch非常容易，它提供了许多合理的缺省值，并对初学者隐藏了复杂的搜索引擎理论。它开箱即用（安装即可使用），只需很少的学习既可在生产环境中使用。 随着越学越深入，还可以利用Elasticsearch更多高级的功能，整个引擎可以很灵活地进行配置。可以根据自身需求来定制属于自己的Elasticsearch。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:1","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch 模糊历史 多年前，一个叫做Shay Banon的刚结婚不久的失业开发者，由于妻子要去伦敦学习厨师，他便跟着也去了。在他找工作的过程中，为了给妻子构建一个食谱的搜索引擎，他开始构建一个早期版本的Lucene。 直接基于Lucene工作会比较困难，所以Shay开始抽象Lucene代码以便Java程序员可以在应用中添加搜索功能。他发布了他的第一个开源项目，叫做“Compass”。 后来Shay找到一份工作，这份工作处在高性能和内存数据网格的分布式环境中，因此高性能的、实时的、分布式的搜索引擎也是理所当然需要的。然后他决定重写Compass库使其成为一个独立的服务叫做Elasticsearch。 第一个公开版本出现在2010年2月，在那之后Elasticsearch已经成为Github上最受欢迎的项目之一，代码贡献者超过300人。一家主营Elasticsearch的公司就此成立，他们一边提供商业支持一边开发新功能，不过Elasticsearch将永远开源且对所有人可用。 Shay的妻子依旧等待着她的食谱搜索…… ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:2","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch ： 面向文档（工作原理） 我们知道，关系型数据库以记录和行的形式存储数据，但是在elasticsearch中，是以文档的形式存储数据。 但区别在于，文档要比数据表的行更加灵活。因为文档可以是多层次的，它（文档）鼓励你将属于一个逻辑实体的数据保存在同一个文档中，而不是散落在各个表的不同行中。这样查询效率很高，因为我们无需连接其他的表，我们学习关系型数据库时，一定知道连表查询（尤其是连接多张表）是多么的费时吧！ ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:3","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"成功案例 之前有人说，elasticsearch的缺点之一是没有成熟的案例加持，那我们就来看看elasticsearch都有哪些成熟的案例： 维基百科使用Elasticsearch来进行全文搜做并高亮显示关键词，以及提供search-as-you-type、did-you-mean等搜索建议功能。 英国卫报使用Elasticsearch来处理访客日志，以便能将公众对不同文章的反应实时地反馈给各位编辑。 StackOverflow将全文搜索与地理位置和相关信息进行结合，以提供more-like-this相关问题的展现。 GitHub使用Elasticsearch来检索超过1300亿行代码，可以参考A Whole New Code Search 每天，Goldman Sachs使用它来处理5TB数据的索引，还有很多投行使用它来分析股票市场的变动。 苏宁在大数据平台使用es存储600TB数据，集群规模包括：搭建超过500+物理机，30万shards，80000index。参考 腾讯在日志实时分析中采用es，处理高并发100W/S，PE级数据。 更多参考 所以，elasticsearch可以灵活的应用于我们的项目中。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:4","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"如何学elasticsearch 除了万能的百度和Google 之外，我们还有一些其他的学习途径： elasticsearch官方文档：这个比较好点，可以多多参考 elasticsearch博客：这个吧，看看就行 elasticsearch社区：社区还是很好的 elasticsearch视频：包括入门视频什么的 elasticsearch实战：该书籍的质量还是不错的。 elasticsearch权威指南：同样的，这个也不错。 ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:5","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["ElasticSearch"],"content":"ElasticSearch 能处理的数据量 一个很好地问题，不幸的是，单一索引的极限取决于存储索引的硬件、索引的设计、如何处理数据以及你为索引备份了多少副本。 通常来说，一个Lucene索引（也就是一个elasticsearch分片）不能处理多于21亿篇文档，或者多于2740亿的唯一词条。但达到这个极限之前，我们可能就没有足够的磁盘空间了！ 当然，一个分片如何很大的话，读写性能将会变得非常差。 扯了半天的淡，让我们开始一个灵活的学习之旅吧。 see also： 入门指南 | Elasticsearch Clients | 搜索引擎选择： Elasticsearch与Solr | Elasticsearch 基本介绍及其与 Python 的对接实现 | Elasticsearch权威指南中文版（截止本博客发表，还没有翻译完…….） 欢迎斧正，that’s all ","date":"2020-08-31","objectID":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/:0:6","tags":["Es简介"],"title":"什么是ElasticSearch","uri":"/posts/elasticsearch-01-%E5%85%A5%E9%97%A8/"},{"categories":["GO"],"content":"1 接口 接口定义一个对象的行为。接口只指定了对象应该做什么，至于如何实现这个行为（即实现细节），则由对象本身去确定。 （python中 abc 模块 可以强制要求子类必须重写父类的方法 否则报错） python和go都属于鸭子类型，非侵入式接口 java：侵入式接口 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、定义接口 （接口是一系列行为的集合：一系列方法的集合） type Duck interface { run() speak() } //只要结构体绑定了接口中的所有方法，这个结构体就叫实现了Duck接口 type TDuck struct { name string age int wife string } //实现TDuck接口(绑定接口中的所有方法) func (t TDuck)Run() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我说人话\") } func (t TDuck)Speak() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我学人走路\") } //定义一个RDuck结构体 type RDuck struct { name string age int } //RDuck实现接口（实现接口中的所有方法） func (t RDuck)Run() { fmt.Println(\"我是普通肉鸭，我的名字是\",t.name,\"我阿嘎嘎叫\") } func (t RDuck)Speak() { fmt.Println(\"我是普通肉鸭，我的名字是\",t.name,\"我歪歪扭扭走路\") } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 实例化得到TDuck和 RDuck 两个对象 t:=TDuck{\"鸡哥\",88,\"凤姐\"} r:=RDuck{\"普通鸭子\",2} t.Run() t.Speak() r.Run() r.Speak() //接口也是一个类型（可以定义一个变量是接口类型） // 同一类事物的多种形态 var d DuckInterface d=t //d=r d.Speak() d.Run() //想再去t的属性，name，age，wife test(t) // {鸡哥 88 凤姐} //test(r) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 类型断言 func test(d DuckInterface) { //d.Run() //d.Speak() //var t TDuck //t=d.(TDuck) t:=d.(TDuck) //断言d是TDuck类型，如果正确，就会把d转成t fmt.Println(t.name) fmt.Println(t.wife) t.Speak() t.Run() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 类型选择 func test(d DuckInterface) { switch a:=d.(type) { case TDuck: fmt.Println(a.wife) fmt.Println(\"你是TDuck类型\") case RDuck: fmt.Println(a.name) fmt.Println(\"你是RDuck类型\") default: fmt.Println(\"不知道是什么类型\") } } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5、 空接口 //-只要一个类型，实现接口所有的方法，就叫实现该接口 //-如果一个接口是空的，一个方法都没有，所有类型都实现了空接口 //-任意类型，都可以赋值给空接口类型 var a EmptyInterface a=1 a=\"xx\" a=[3]int{1,2,3} ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:5","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6、 接口类型空值（nil） var a EmptyInterface fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:6","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"7、有名 / 匿名空接口 // 有名空接口 type EmptyInterface interface { } // 匿名空接口 func test(i interface{}) { } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:7","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"8、 实现多个接口 type DuckInterface1 interface { Run() Speak() } type HumanInterface interface { Drive() } //定义一个TDuck结构体 type TDuck1 struct { name string age int wife string } //TDuck实现接口（实现接口中的所有方法） func (t TDuck1)Run() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我说人话\") } func (t TDuck1)Speak() { fmt.Println(\"我是唐老鸭，我的名字是\",t.name,\"我学人走路\") } //实现HumanInterface接口 func (t TDuck1)Drive() { fmt.Println(\"我是唐老鸭，我开车\") } func main() { t:=TDuck1{\"鸡哥\",18,\"凤姐\"} var d DuckInterface1 var h HumanInterface d=t d.Run() d.Speak() h=t h.Drive() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:8","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"9、 接口嵌套 type DuckInterface1 interface { Run() Speak() } type HumanInterface interface { DuckInterface1 //相当于 //Run() //Speak() Drive() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:1:9","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2 并发和并行 # 并发：假如在他晨跑时，鞋带突然松了。于是他停下来，系一下鞋带，接下来继续跑 # 并行：如这个人在慢跑时，还在用他的 iPod 听着音乐 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:2:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3 go 协程 go协程 –\u003e goroutine，并不是真正的协程（线程+协程，语言层面处理了，不需要开发者去关注） package main import ( \"fmt\" \"time\" ) func hello() { fmt.Println(\"go go go！\") } func main() { fmt.Println(\"主函数开始\") go hello() //通过go关键字，开启goroutine，并发执行 go hello() go hello() go hello() fmt.Println(\"主函数结束\") time.Sleep(2*time.Second) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:3:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4 信道 goroutine直接通信 go语言不推崇共享变量方法做通信，而推崇管道通信channel（信道） ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、 信道也是一个变量（需要指明运输类型） var a chan int //定义一个int类型信道 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 信道的零值， nil类型， 它是一个引用 fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 信道初始化 var a chan int=make(chan int) fmt.Println(a) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 信道放值和取值 var a chan int=make(chan int) a\u003c-1 //放值，把1放到信道中 var b int=\u003c-a //取值 //\u003c-a //取值 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5、 默认情况下，信道的放值和取值都是阻塞的(一次一个都放不进去) package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"开始\") var a chan bool=make(chan bool) //信道是引用类型 go hello1(a) \u003c-a time.Sleep(2*time.Second) } func hello1(a chan bool) { fmt.Println(\"go go go\") a\u003c-true fmt.Println(\"xxx\") } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:5","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6、 信道案例 package main /* 输入 453 计算每一位的平方和和每一位的立方和的和 squares = (4 * 4) + (5 * 5) + (3 * 3) cubes = (4 * 4 * 4) + (5 * 5 * 5) + (3 * 3 * 3) output = squares + cubes */ import ( \"fmt\" ) func calcSquares(number int, squareop chan int) { sum := 0 for number != 0 { digit := number % 10 //% 取余数 453对10取余数--》3--》5--》4 sum += digit * digit number /= 10 // /除以 453除以10----》45--》5--》0 } squareop \u003c- sum } func calcCubes(number int, cubeop chan int) { sum := 0 for number != 0 { digit := number % 10 sum += digit * digit * digit number /= 10 } cubeop \u003c- sum } func main() { number := 4535 sqrch := make(chan int) cubech := make(chan int) go calcSquares(number, sqrch) go calcCubes(number, cubech) squares, cubes := \u003c-sqrch, \u003c-cubech //squares:= \u003c-sqrch //cubes := \u003c-cubech fmt.Println(\"Final output\", squares + cubes) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:6","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"7、 死锁 、 单项信道 与 信道关闭 package main func main() { //1 死锁 //var a chan int=make(chan int) //a\u003c-1 //一直阻塞在这，报死锁错误 //\u003c-a //一直阻塞在这，报死锁错误 //2 单向信道（只写或者只读） //sendch := make(chan int) //定义一个可写可读信道 //go sendData(sendch) //fmt.Println(\u003c-sendch) //只能往里写值，取值报错 //3 信道的关闭 close //sendch := make(chan int) //close(sendch) } func sendData(sendch chan\u003c- int) { //转成只写信道 sendch \u003c- 10 //\u003c-sendch //只要读就报错 } package main import ( \"fmt\" ) func producer(chnl chan int) { for i := 0; i \u003c 10; i++ { chnl \u003c- i } close(chnl) } func main() { ch := make(chan int) go producer(ch) for v := range ch { //如果信道没关闭，一直取值，直到没有值，会报死锁 fmt.Println(\"Received \",v) } } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:4:7","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"5 缓冲信道 有缓冲的信道， 可以放多个值 ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"1、 缓冲信道的定义和死锁问题 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var a chan int =make(chan int,2) //长度为4的有缓冲信道 a\u003c-1 a\u003c-2 //管子满了 //a\u003c-5 //报死锁错误 //推断出无缓冲信道 var a chan int =make(chan int,0) fmt.Println(\u003c-a) fmt.Println(\u003c-a) //管子没有东西了，再取，报死锁 //fmt.Println(\u003c-a) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:1","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"2、 信道的容量和长度 //长度是目前管道中有几个值，容量是管道最多能容纳多少值 var a chan int =make(chan int,4) fmt.Println(len(a)) fmt.Println(cap(a)) a\u003c-1 a\u003c-2 fmt.Println(len(a)) fmt.Println(cap(a)) ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:2","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"3、 小案例 (通过信道实现goroutine的同步) var a chan int =make(chan int,3) //b:=\u003c-a go test3(a) fmt.Println(\u003c-a) fmt.Println(\u003c-a) func test3(a chan int) { a\u003c-1 time.Sleep(time.Second*2) fmt.Println(\"假设我在运算\") a\u003c-2 close(a) } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:3","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"4、 通过 waitgroup 实现同步 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { no := 3 var wg sync.WaitGroup //值类型，没有初始化，有默认值 for i := 0; i \u003c no; i++ { wg.Add(1) go process(i, \u0026wg) } wg.Wait() //add了几次，必须有几个wg.Done()对应，否则一直等在这 fmt.Println(\"All go routines finished executing\") } func process(i int, wg *sync.WaitGroup) { fmt.Println(\"started Goroutine \", i) time.Sleep(2 * time.Second) fmt.Printf(\"Goroutine %d ended\\n\", i) wg.Done() } ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:5:4","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"6 异常处理 defer:延迟执行，即便程序出现严重错误，也会执行 panic：主动抛出异常 raise recover：恢复程序，继续执行 //异常处理 package main import \"fmt\" //func main() { // f1() // f2() // f3() //} //func f1() { // fmt.Println(\"f1\") //} // //func f2() { // fmt.Println(\"f2\") // //如果这个地方出了异常 //} //func f3() { // fmt.Println(\"f3\") //} //defer:延迟执行，即便程序出现严重错误，也会执行 //panic：主动抛出异常 raise //recover：恢复程序，继续执行 //func main() { // //defer fmt.Println(\"我最后才执行\") //先注册，等函数执行完成后，逆序执行defer注册的代码 // //defer fmt.Println(\"ddddd\") // defer func() { // fmt.Println(\"我最后才执行\") // }() // defer func() { // fmt.Println(\"我最后才执行\") // //出异常 // //这个代码执行不到了 // }() // // fmt.Println(\"111\") // fmt.Println(\"222\") // panic(\"我出错了\") //主动抛出异常 // //var a []int =make([]int,2,3) // //fmt.Println(a[9]) // fmt.Println(\"这句话还会执行吗 ？不会了\") //} //在defer中恢复程序，继续执行 func main() { f1() f2() f3() } func f1() { fmt.Println(\"f1\") } func f2() { defer func() { //recover() //恢复程序继续执行 if err:=recover();err!=nil{ //err 如果不为nil(空），表示出了异常 fmt.Println(err) //把异常信息打印出来 } }() fmt.Println(\"f2\") //如果这个地方出了异常 panic(\"我出错了\") fmt.Println(\"永远执行不到\") } func f3() { fmt.Println(\"f3\") } // python中 //print('ssss') //try: // print('ssss') // raise(\"xxxx\") // print('我永远不会执行') //except Exception as e: // print(e) //finally: // print('我永远会执行') //go 中 //print('ssss') //defer func() { // if err:=recover();err!=nil{ // fmt.Println(err) // } // //finally 写在这 // print('我永远会执行') //}() //print('ssss') //panic(\"xxxx\") //print('我永远不会执行') [toc] ","date":"2020-01-09","objectID":"/posts/go-09-%E6%8E%A5%E5%8F%A3/:6:0","tags":["golang","接口"],"title":"Go 接口 协程 信道 异常处理","uri":"/posts/go-09-%E6%8E%A5%E5%8F%A3/"},{"categories":["GO"],"content":"指针 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、定义指针 // 指向int类型的指针（指向什么类型指针，就是在什么类型前加星号） var a *int ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、指针的零值 fmt.Println(a) //nil ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、使用指针 var a *int var b int=100 // a指针指向b （取谁的地址，就是在谁前面加一个\u0026） a=\u0026b fmt.Println(a) // 0xc0000b4008 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、了解（骚操作） var a *int var b **int= \u0026a var c ***int= \u0026b var d ****int =\u0026c fmt.Println(d) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、 解引用 （把指针反解成值）（在指针变量前加*，表示解引用） fmt.Println(*a) fmt.Println(***d) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、 向函数传递指针参数 var a int =100 ////在函数中把a的值改成101 fmt.Println(a) test2(\u0026a) fmt.Println(a) func test2(a *int) { //解引用然后，自增1 //*a++ *a=*a+100 fmt.Println(*a) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、不要向函数传递数组指针， 而应该使用切片 var a [4]int = [4]int{1,2,3} fmt.Println(a) //test3(\u0026a) test4(a[:]) fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、go 不支持指针运算(在c中可以通过数组指针的运算进行取值) var b int=100 var a *int=\u0026b //a++ ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、 指针数组和数组指针 // 指针数组 --\u003e 数组里面放指针 var a int =10 var b int =20 var c int =30 var d [3]*int=[3]*int{\u0026a,\u0026b,\u0026c} fmt.Println(d) // 数组指针 --\u003e 指针数组指针 var a [3]int=[3]int{1,3,4} var b *[3]int=\u0026a fmt.Println(b) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:1:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"结构体 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、 什么是结构体 //结构体,go语言中的面向对象 //结构体是用户定义的类型,表示若干个字段（Field）的集合 //类比面向对象中的类，只有属性，没有方法 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、 定义一个结构体 // type关键字 结构体名字 struct关键字 {一个一个的字段} type Person struct { name string age int sex string } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、使用结构体 //（结构体的零值，是属性的零值)不是nil，它不是引用类型，是值类型 var a Person fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、 定义并初始化 // 1 var a Person=Person{} // 2 var a Person=Person{name:\"lqz\",age:19,sex:\"男\"} // 3 var a =Person{name:\"lqz\",age:19,sex:\"男\"} // 4 a :=Person{name:\"lqz\",age:19,sex:\"男\"} // 5 a :=Person{sex:\"男\",name:\"lqz\",age:19} // 6 a :=Person{sex:\"男\",name:\"lqz\"} //按位置初始化(固定位置，并且都传) a :=Person{\"lqz\",19,\"男\"} fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、 使用结构体 var a Person=Person{name:\"zhang\",age:19,sex:\"男\"} fmt.Println(a.name) a.name=\"wang\" fmt.Println(a) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、 匿名结构体（没有名字,没有type关键字，定义在函数内部） //什么情况下用？只使用一次，数据整合在一起 a:=struct { name string age int sex string }{\"lqz\",19,\"男\"} fmt.Println(a.name) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、结构体的指针（结构体是值类型） var a *Person=\u0026Person{\"zhang\",19,\"男\"} fmt.Println(a) //Go 语言允许我们在访问 字段时，可以使用 emp8.firstName 来代替显式的解引用 (*emp8).firstName fmt.Println((*a).name) fmt.Println(a.name) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、 匿名字段（字段没有名字,不允许有多个同类型的字段） 有什么用？用来做字段提升，面向对象中的继承 type Person struct { string int } //按位置实例化 a:=Person{\"zhang\",19} //按关键字实例化 a:=Person{int:19,string:\"zhang\"} fmt.Println(a) fmt.Println(a.string) fmt.Println(a.int) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、嵌套结构体（结构体套结构体） 不管是结构体名字还是字段名字，大写字母开头，表示导出字段，表示在外部包可以使用 //面向对象封装（python __） type Person struct { Name string Age int Sex string hobby Hobby } type Hobby struct { HobbyId int HobbyName string } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"10、 提升字段 type Person struct { Name string Age int Sex string Hobby } type Hobby struct { HobbyId int HobbyName string } // 此处就相当于是python中 类的继承， 求中 Hobby 是父类 Person 是子类 // 提升字段可以直接在Person 结构体的实例中以点的方式进行访问 11、字段冲突 type Person struct { Name string Age int Sex string Hobby } type Hobby struct { HobbyId int Name string } // 当父结构体（父类）Hobby 中有Name Person中也有Name 当进行实例化的时候， 优先访问的是子结构体Person中的name 这也是子类重写父类的属性。 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:2:10","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"方法 结构体+方法就是实现面向对象中的类 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:0","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"1、 什么是方法 方法其实就是一个函数，在 func 这个关键字和方法名中间加入了一个特殊的接收器类型。接收器可以是结构体类型或者是非结构体类型。接收器是可以在方法的内部访问的 python中什么是方法， 什么是函数？ \"\"\" 1、 方法是面向对象中的概念，对象绑定方法，类的绑定方法，可以自动传值， 2、 类中不加任何装饰器定义的函数，是对象的绑定方法，对象来调用，可以自动传值，类也可以来掉，如果类来调用，他就是普通函数，有几个值就传几个值 3、 类的绑定方法，类来调用，会把类自动传入 \"\"\" ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:1","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"2、方法的定义 //定义一个结构体 type Person struct { name string age int sex string } //给结构体绑定方法(无参数) func (p Person1)PrintName() { fmt.Println(p.name) } // 绑定一个修改名字的方法(有参数) func (p Person1)ChangeName(name string) { p.name=name fmt.Println(\"--------\",p) } //普通函数 func PrintName(p Person1) { fmt.Println(p.name) } p:=Person1{\"zhang\",19,\"男\"} p.PrintName() // zhang ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:2","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"3、 为什么要有结构体的绑定方法 Go 不是纯粹的面向对象编程语言，而且Go不支持类。因此，基于类型的方法是一种实现和类相似行为的途径。 相同的名字的方法可以定义在不同的类型上，而相同名字的函数是不被允许的。假设我们有一个 Square 和 Circle 结构体。可以在 Square 和 Circle 上分别定义一个 Area 方法。见下面的程序。 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:3","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"4、值接收器和指针接收器 //指针类型接收器，修改age的方法 func (p *Person1)ChangeAge(age int) { p.age=age //(*p).age=age //正常操作 fmt.Println(\"--------\",p) } p:=Person1{\"zhang\",19,\"男\"} p.ChangeName(\"wang\") // 值接收器，改新的，不会影响原来的，不会影响当前的p对象 fmt.Println(p) // 调用指针类型接收器的方法 p.ChangeAge(100) //指针类型接收器，会影响原来的，会影响当前的p对象 fmt.Println(p) ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:4","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"5、值接收器和指针接收器的应用场景 //用指针接收器的情况 //1 方法内部的改变，影响调用者 //2 当拷贝一个结构体的代价过于昂贵时 ,就用指针接收器 //其他情况，值接收器和指针接收器都可以 ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:5","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"6、匿名字段的方法（重点） p:=Person1{\"wang\",19,\"男\",Hobby1{1,\"篮球\"}} //匿名字段，属性可以提升 //匿名字段，方法也提升 p.printName() // 也提升了 子类对象调用父类中的方法，子类中没有，就是调用父类的--》 对象.方法名 p.Hobby1.printName() // 正常操作 直接指名道姓的调用父类中的方法---》 super().方法名 // 子类中重写了父类的方法（嵌套结构体中有重名的方法） p.printName() ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:6","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"7、在方法中使用值接收器 与 在函数中使用值参数 type Person1 struct { name string age int sex string } //方法中使用值接收器 func (p Person1)printName() { fmt.Println(p.name) } p:=Person1{\"zhang\",19,\"男\"} p.printName() // zhang printName(p) //在函数中使用值参数 func printName(p Person1) { fmt.Println(p.name) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:7","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"8、在方法中使用指针接收器 与 在函数中使用指针参数 type Person1 struct { name string age int sex string } //在方法中使用指针接收器 func (p *Person1)printName() { fmt.Println(p.name) } //在函数中使用指针参数 func printName(p *Person1) { fmt.Println(p.name) // printName(\u0026a) } ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:8","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"9、在非结构体上的方法 // 给数据类型加方法 // 错误方式 func (i int)add() { i=i+i } // 自己定义类型， 可以绑定方法 type myInt int func (i *myInt)add() { (*i)++ fmt.Println(*i) } i:=10 i.add() [toc] ","date":"2020-01-08","objectID":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/:3:9","tags":["golang","指针"],"title":"Go 指针/结构体/方法","uri":"/posts/go-08-%E6%8C%87%E9%92%88%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["GO"],"content":"数组 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、定义 //1 基本使用：定义 //定义了一个大小为3的int类型数组 //数组在定义阶段，大小和类型就固定了 var a [3]int //只定义，没有初始化 fmt.Println(a) // 因int 类型的0值是0 所以， 未初始化数组是[0,0,0] ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、使用数组 var a [3]int a[2]=100 fmt.Println(a) // [0,0,100] fmt.Println(a[0]) // 100 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、定义并赋值 // 方式1 var a [3]int=[3]int{1,2,3} // 方式2 var a =[3]int{1,2,3} // 方式3 a := [3]int{1, 2, 3} //只给第2个位置设为99 a := [3]int{2:99} // 进阶版 a := [3]int{2:99,1:88} fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、数组的大小是类型的一部分 //这两个不是一个类型 var a [2]int var b [3]int a=b // 类型不一样 无法赋值 fmt.Println(a\u003eb) // 类型不一样 无法比较 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、数组是值类型（当参数传递到函数中，修改不会改变原来的值） // go语言中，都是copy传递 /* python中都是引用传递，一切皆对象，就是地址，当做参数传递是把地址传过去了 python中比较特殊：可变类型和不可变类型 */ var a [3]int=[3]int{5,6,7} fmt.Println(a) test1(a) fmt.Println(a) func test(a int){ a[0]=999 fmt.Println(a) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、数组长度（len()） var a [3]int=[3]int{5,6,7} fmt.Println(len(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、循环数组 //方式一 var a [3]int=[3]int{5,6,7} for i:=0;i\u003clen(a);i++{ fmt.Println(a[i]) } //方式二 range:是一个关键字 var a [3]int=[3]int{5,6,7} for i,v:=range a{ fmt.Println(i) //索引 fmt.Println(v) //数组的值 } //函数如果返回两个值，必须用两个值来接收 //range可以用一个值来接收，如果用一个值来接收，就是索引 for i:=range a{ fmt.Println(i) //索引 } //只取值，不取索引 for _,v:=range a{ fmt.Println(v) //值 } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、多维数组 var a [3][2]int=[3][2]int{{1,2},{4,5},{9,70}} //a[1][0]=999 // fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:1:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"切片 切片是由数组建立的一种方便、灵活且功能强大的包装（Wrapper）。切片本身不拥有任何数据。它们只是对现有数组的引用。 切片底层依附于数组 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、创建切片 // 先创建数组 var a [9]int = [9]int{1,2,3,4,5,6,7,8,9} // []int 就是切片的一种类型 var b []int b = a[0:3] // 前闭后开 // 没有 -1 没有步长 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、使用切片 fmt.Println(b[0]) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、切片的修改会影响底层数组， 数组的修改也会影响切片 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[0:3] //前闭后开 fmt.Println(a) fmt.Println(b) a[0]=999 b[2]=888 fmt.Println(a) fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、切片的长度和容量 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[2:3] //前闭后开 fmt.Println(len(b)) // 切片的长度是1 //切片容量是9，意思是，可以往里追加值，追加成9个 fmt.Println(cap(b)) 注意 切片的容量不是源数组的长度， 是源数组从开始切的位置到数组末尾的长度 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、追加值 var a [9]int=[9]int{1,2,3,4,5,6,7,8,9} var b []int=a[2:3] //前闭后开 b=append(b,1) b=append(b,11,22,33,44,55) fmt.Println(len(b)) fmt.Println(cap(b)) fmt.Println(b) fmt.Println(a) //到了数组的尾部，继续追加值 b=append(b,999) fmt.Println(len(b)) fmt.Println(cap(b)) //容量是14 //总结1：当切片追加值，超过了切片容量，切片容量会翻倍，在原来容量基础上乘以2 //b=append(b,222,333,444,555,666,7,8) //fmt.Println(len(b)) //fmt.Println(cap(b)) //容量是14 //总结2：一旦超过了原数组， 就会重新申请数组，把数据copy到新数组，切片和原数组就没有关系了 //fmt.Println(a) //fmt.Println(b) //a[8]=7777 //fmt.Println(a) //fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、通过 make创建切片（底层也是依附于数组） var a []int // 切片的零值是什么？ nil类型： 是所有引用类型的空值 fmt.Println(a) if a==nil{ fmt.Println(\"我是空的\") } var a []int=make([]int,3,4) // 3是长度，4是容量 a=append(a,55) fmt.Println(a) fmt.Println(len(a)) // 3 fmt.Println(cap(a)) // 4 ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、切片定义并赋初值 var a []int=[]int{1,2,3} fmt.Println(a) fmt.Println(len(a)) fmt.Println(cap(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、切片是引用类型，当参数传递， 会修改掉原来的值 var a []int=[]int{1,2,3} fmt.Println(a) test3(a) fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"9、多维切片 var a [][]int=make([][]int,2,3) fmt.Println(a) fmt.Println(a[0]==nil) a[0][0]=999 // 这样赋值会报错， 因为make 只是初始化了最外层， 即第一层[] 第二层[] 没有初始化。 // 解决， 可以使用for循环进行初始化 a[0]=make([]int,2,3) a[0][1]=999 fmt.Println(a) a[1][0]=99999 // 定义并赋初始值常用 var a [][]int=[][]int{{1,2,3},{4,5,6,7,7,8}} //跟上面不一样 var a [][3]int=[][3]int{{1,2,3},{4,5,6}} fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:9","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"10、切片拷贝 var a[]int = make([]int,3,4) var b[]int=make([]int,2,6) a[0]=11 a[1]=22 a[2]=33 b[0]=999 copy(b,a) fmt.Println(b) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:10","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"11、切片越界 var a[]int = make([]int,3,4) a[0]=11 a[1]=22 a[2]=33 a=append(a,000) // 中括号取值， 只能取到长度， 不能取到容量大小 fmt.Println(a[3]) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:2:11","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"Maps: hash, 字典 (key:value) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:0","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"1、map的定义和使用 // map[key]value 类型： key 的类型必须是可hash的， key值： 数字， 字符串 // map的零值是 nil， 它是一个引用类型 var a map[int]string fmt.Println(a) if a==nil{ fmt.Println(\"我是空的\") } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:1","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"2、map的使用 // 定义未初始化 var map[int]string // 定义并初始化 使用make var map[int]string = make(map[int]string) // 使用[] 添加/修改， a[1]=\"zhang\" a[2]:\"wang\" a[3]:\"qilitang\" // a[\"xx\"] key 值不能乱写 fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:2","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"3、获取元素 var a map[int]string=make(map[int]string) fmt.Println(a[0]) //取出value值的空值 \"\" 统一的方案来判断value值是否存在 //a[0] 可以返回两个值，一个是value值（可能为空），另一个是true或false var a map[int]int=make(map[int]int) a[0]=0 v,ok:=a[0] fmt.Println(v) fmt.Println(ok) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:3","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"4、map 删除元素 var a map[int]int=make(map[int]int) a[1]=11 a[2]=22 fmt.Println(a) //根据key删（内置函数） delete(a,1) fmt.Println(a) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:4","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"5、map长度 var a map[int]int=make(map[int]int) fmt.Println(len(a)) a[1]=11 a[2]=22 fmt.Println(len(a)) ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:5","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"6、map是引用类型 var a map[int]int=make(map[int]int) a[1]=11 test4(a) fmt.Println(a) func test4(a map[int]int) { a[1]=999 fmt.Println(a) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:6","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"7、 map的相等性 var a map[string]string=make(map[string]string) a[\"name\"]=\"zhang\" var b map[string]string=make(map[string]string) b[\"name\"]=\"zhang\" // 不能判断， map只能跟nil比较 if a==nil { } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:7","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"8、循环map // 需要借助内置range循环 var a map[string]string=map[string]string{\"name\":\"zhang\",\"age\":\"19\",\"sex\":\"男\"} for k,v:=range a{ fmt.Println(k) fmt.Println(v) } ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:8","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"9、map是无序的 // 如何让map变为有序 [toc] ","date":"2020-01-07","objectID":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/:3:9","tags":["golang"],"title":"Go 数组/切片/map","uri":"/posts/go-07-%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87/"},{"categories":["GO"],"content":"if else 基本使用 package main import \"fmt\" // if else if else func main() { a := 10 if a == 10 { fmt.Println(\"13\") } else if a \u003e 10 { fmt.Println(\"a大于10\") } else { fmt.Println(\"a小于10\") } } 不能换行（go语言每一行结尾，需要加一个; ,每当换行，会自动加;） 在条件里可以进行初始化操作,(作用域范围的区别) package main import \"fmt\" func main() { a := 10 if a \u003c 10 { fmt.Println(\"xxx\") } else { fmt.Println(\"yyyy\") } } // 2 package main import \"fmt\" func main() { if a:=10 ;a \u003c 10 { fmt.Println(\"xxx\") } else { fmt.Println(\"yyyy\") } } ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:1","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"for 循环 基本语法 package main import \"fmt\" func main() { // 基本语法 // for 初始化; 条件判断; 自增/自减 { 循环体内容} // 打印1=9 for i:=1; i\u003c10; i++{ fmt.Println(i) } } 省略第一部分 package main import \"fmt\" func main() { // 2 省略第一部分（初始化）,作用域范围不一样 i:=0 for ;i\u003c10 ; i++ { fmt.Println(i) } } 省略第三部分 package main import \"fmt\" func main() { //3 省略第三部分 for i:=0;i\u003c10 ; { i++ fmt.Println(i) } } 省略第一部分和第三部分 package main import \"fmt\" func main() { //4 省略第一和第三部分 i := 0 for ; i \u003c 10; { i++ fmt.Println(i) } } package main import \"fmt\" func main() { //for 条件 {} i := 0 for i \u003c 10 { i++ fmt.Println(i) } // 死循环 for true{ fmt.Println(1) } // 死循环 for { fmt.Println(1) } } break continue(和python 中一样) ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:2","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"switch 语句 //switch package main func main() { // 1 switch 基本使用 //a:=10 //switch a { //case 1: // fmt.Println(\"1\") //case 2: // fmt.Println(2) //case 9: // fmt.Println(9) //case 10: // fmt.Println(\"10\") //} //2 default //a:=15 //switch a { //case 1: // fmt.Println(\"1\") //case 2: // fmt.Println(2) //case 9: // fmt.Println(9) //case 10: // fmt.Println(\"10\") //default: // fmt.Println(\"不知道\") //} //3 多条件 //a:=3 //switch a { //case 1,2,3: // fmt.Println(\"1\") //case 4,5,6: // fmt.Println(2) //case 7,9: // fmt.Println(9) //case 10,16: // fmt.Println(\"10\") //default: // fmt.Println(\"不知道\") //} //4 无表达式 //a:=3 //switch { //case a==1 || a==3: // fmt.Println(\"1\") //case a==4||a==5: // fmt.Println(2) //default: // fmt.Println(\"不知道\") //} //5 fallthrough,无条件执行下一个case //a:=1 //switch { //case a==1 || a==3: // fmt.Println(\"1\") // //fallthrough //fallthrough 会无条件执行下一个case //case a==4||a==5: // fmt.Println(2) // fallthrough //default: // fmt.Println(\"不知道\") //} } [toc] ","date":"2020-01-06","objectID":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/:0:3","tags":["golang"],"title":"Go if-else/ for 循环/ switch","uri":"/posts/go-05-if-else%E8%AF%AD%E5%8F%A5/"},{"categories":["GO"],"content":"包 //1 在同一个包下（文件夹下），包名必须一致 //2 以后，包名就是文件夹的名字 //3 同一个包下，同名函数只能有一个（init除外） //4 一个包（当成一个文件），同一包下的函数，直接调用即可 //5 导包的位置，从src路径开始 //6 包只要在src路径下就可以导入 //7 大写表示导出，在外部包可以使用，小写只能再包内部适应 //8 使用第三方包：go get github.com/astaxie/beego （放到gopath的src路径下） package main import \"github.com/astaxie/beego\" func main() { beego.Run() } ","date":"2020-01-06","objectID":"/posts/go-06-%E5%8C%85/:0:1","tags":["golang"],"title":"Go 包","uri":"/posts/go-06-%E5%8C%85/"},{"categories":["GO"],"content":"mode模式 //1 包导入 import . \"github.com/astaxie/beego\" 类似于python中form xx import * //2 包导入 import _ \"github.com/go-sql-driver/mysql\" 触发init的执行，但是不试用包内的函数 //3 包导入 import f \"fmt\" 重命名，以后直接用f //4 对比python中__init__.py //在代码中导入模块 import xx 实质上触发__init__.py 的执行(在__init__.py中也可以执行其他代码，对应到go中就是init函数) 一般情况下，在__init__.py写from xx import 会使用到的函数，导过来 以后再用 xx.函数() //5 go mod没有之前，可以设置多个gopath，开发某个项目，切到不同的gopath，类似于虚拟环境 //6 go env -GO111MODULE=\"off\" 表示go mod模式是关闭的，用gopath -一旦开启了go mod模式，代码不需要放在src路径下（任意位置都可以） -在项目路径下要有 go.mod 文件（文件里记录了，go版本，项目依赖的包，包的版本） -写代码，建自己的包即可 -一般情况下，项目有一个main.go 内部是main包，main函数，整个程序的入口 [toc] ","date":"2020-01-06","objectID":"/posts/go-06-%E5%8C%85/:0:2","tags":["golang"],"title":"Go 包","uri":"/posts/go-06-%E5%8C%85/"},{"categories":["GO"],"content":"变量的定义方式 package main import \"fmt\" func main() { // 方式一 // var 变量名 变量类型=变量值 // 注意 变量定义后 必须使用, 不适使用报错 // 导入的包必须使用 不适用报错 var age int =18 // 定义并赋值 var name string // 定义 name = \"我是你爸爸\" //赋值 fmt.Println(name, age) // 方式二 类型推导(不需要加类型) var salary = 1000 fmt.Println(salary) fmt.Printf(\"salary的类型是:%T, 值是%d\\n\",salary,salary) // Printf 表示格式化输出 // 方式三 简略声明 male := 100 fmt.Println(male) // 同时定义多个变量(3种方式都可以) var a, b,c = 1,\"2\",\"3\" fmt.Println(a,b,c) } 注意 变量不能重复定义 变量要先定义后使用 简略声明方式定义特殊, 冒号前至少有一个未定义变量则不报错. 变量类型是固定的. 变量定义了, 必须使用,否则报错 包导入则必须使用, 不使用就报错 ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:1:0","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"常量 // 常量 : 恒定不变得量 , 建议全部大写 // 程序在运行过程中, 不会改变值, 例如: 数据库链接地址, 端口号等 package main // 批量声明 const ( notFound = 404 statusOk = 200 ) // 当 出现 n2 n3 这样的没有被赋值的声明 则默认为 n1 const ( n1 =100 n2 n3 ) func main() { //1 const关键字 常量名 常量类型 =值 const A int =99 //2 常量可以定义了不使用 const B int =99 //3 类型可以省略 const C =99 fmt.Printf(\"%T\",b) //4 同时定义多个常量 const ( AGE=19 NAME=\"zyz\" sex=\"男\" ) fmt.Println(AGE) //5 改变常量(不允许) // AGE=199 //fmt.Println(AGE) } ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:0","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"Iota iota 是go语言中的常量计数器, 只能在常量的表达式中使用. iota 在const 关键字出现时 将被重置为 0 , const 中每新增一行常量声明将使iota 计数加一次, 类似 枚举. 在定义枚举时候很有用. 举例说明: const ( n1 = iota n2 n3 n4 n5 ) ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:1","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"常见的几个iota 例子 使用_ 跳过某些值 const ( n1 = iota //0 n2 //1 _ n4 //3 ) iota声明中间插队 const ( n1 = iota //0 n2 = 100 //100 n3 = iota //2 n4 //3 ) const n5 = iota //0 多个常量声明在一行 const ( a, b = iota + 1, iota + 2 //1,2 c, d //2,3 e, f //3,4 ) 定义数量级 （这里的\u003c\u003c表示左移操作，1\u003c\u003c10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2\u003c\u003c2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。 const ( _ = iota KB = 1 \u003c\u003c (10 * iota) MB = 1 \u003c\u003c (10 * iota) GB = 1 \u003c\u003c (10 * iota) TB = 1 \u003c\u003c (10 * iota) PB = 1 \u003c\u003c (10 * iota) ) [toc] ","date":"2020-01-04","objectID":"/posts/go-02-%E5%8F%98%E9%87%8F/:2:2","tags":["golang"],"title":"Go 变量","uri":"/posts/go-02-%E5%8F%98%E9%87%8F/"},{"categories":["GO"],"content":"go语言介绍 # 诞生于09年, 是谷歌公司推出的. -python 1989年 -java 1990年 # 缺点: 生态不是特别好 Go 语言特性 # 跨平台编译型语言 # 语法接近C # 有垃圾回收机制(gc) # 支持面向对象和面向过程式的编程模式.(没有class 但是支持) Go 语言发展 # 目前最新的是1.14.2 版本. go语言向下兼容. 不用考虑版本问题 Go 语言应用 # 国内的很多大型的互联网公司, 腾讯, 百度, 京东, 知乎等 # 国外 谷歌. facebook Go 应用领域 # 服务开发 # 并发 # 分布式 # 微服务方向 Go 语言项目 # Docker # K8s (kubernetes) # 区块链 Go 语言发展前景 # 新兴语言 最牛逼! 不解释 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"环境搭建 # go 开发包安装 # go ide 安装(gplang, vscode, sublime text) # 安装完成后 go version 查看版本 # go env 查看go环境变量 GO111MODULE=\"\" # 当此配置 为空或者off 则代表没有开启 go mode 模式, 用的是gopath 模式 GOROOT=\"/usr/local/Cellar/go/1.14.2_1/libexec\" # go 开发安装路径 GOPATH=\"/Users/zhang/go\" # 代码的存放路径 # go mode 模式: 代码可以存放在任意路径 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"Hello World // 单行注释 /* 多行注释 */ package main // 表示声明包, 每一个go代码第一行都必须写这个 import \"fmt\" // 导入fmt包 类比 python中 import os.path func main() { // 声明 main 函数 函数体 放在 {}之中. fmt.Println(\"Hello, World\") // Println 是输入至控制台, 类比python中的print } // 程序的执行入口是 main包下的 main函数 // 编译型语言都有入口, 对比 python中 一个py文件就是一个 main 函数. // 一个项目只能有一个 main函数 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"常用命令 build go build 文件 # 生成本机环境的可执行文件 fmt go fmt 文件 # 代码格式化 install # 编译并安装包和依赖 run go run 文件 # 编译并运行go程序 ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:1","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"规范 1 变量：go语言中变量区分大小写，建议用驼峰 var Name=\"lqz\" var name=\"lqz\" fmt.Println(Name) fmt.Println(name) 2 文件名：建议用下划线 3 大写字母开头，表示导出字段（外部包可以使用） 4 先导入第三方包，内置包，自己写的包 5 不像python中缩进代表同一段代码块 var a =10 fmt.Println(a) fmt.Println(\"xxx\") [toc] ","date":"2020-01-04","objectID":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:2","tags":["golang"],"title":"Go语言介绍及环境搭建","uri":"/posts/go-01%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["GO"],"content":"函数 go为编译型语言, 需要先编译后执行, 所以 go中函数不会像python 一样需要先定义后执行, go 中函数 可以写在任意位置 语法 // 语法 func(关键字) 函数名() {} 无参 无返回值函数 package main import \"fmt\" func main() { t1() } // 无参数, 无返回值 func t1() { fmt.Println(\"231\") } 有参数 无返回值 package main import \"fmt\" func main() { t1(132) } // 有参数 无返回值 // go中函数没有关键字参数, 所有的都是位置参数, 也没有默认参数 func t1( i int) { fmt.Println(i) } 多个参数 无返回值 package main import \"fmt\" func main() { t1(132,456) } // go中函数没有关键字参数, 所有的都是位置参数, 也没有默认参数 func t1( i int, m int) { fmt.Println(i) } // 如果参数为同一个类型, 可以简写 func t1( i,m int) { fmt.Println(i) } 多个参数有一个返回值(需要指明返回值的类型) package main import \"fmt\" func main() { i := t1(132, 456) fmt.Println(i) } // 多个参数 有一个返回值 func t1(i,m int) int{ return i+m } 多个参数 多个返回值 package main import \"fmt\" func main() { i,m := t1(132, 456) fmt.Println(i,m) } // 多个参数 有一个返回值 func t1(i,m int) (int,int){ c := i+m d := i*m return c,d } 补充 //func test(a,b int)(){} //func test(a,b int)(int){} //func test(a,b int)(int,string,int){} //func test(a,b int)int{} 可变长参数 // 可变长参数 package main import \"fmt\" func main() { i, m := t1(132, 456, 321) fmt.Println(i, m) } func t1(m int, i ...int) (int, int) { c := m + i[0] d := i[0] * i[1] return c, d } 函数是一等公民**(头等函数), 在go 中函数也是一个类型 返回值时函数类型 package main import \"fmt\" func main() { i := t1() i() } func t1() func() { var a func()=func (){ fmt.Println(\"我是内层函数\") } return a } //func t1() func() { // return func (){ // fmt.Println(\"我是内层函数\") // } //} 闭包函数(定义在函数内部, 对外部作用域的引用) 闭包函数的本质: 多了一种传参方式 func t1(b int) func() { a:= func() { fmt.Println(b) } return a } // 在go 语言中没有装饰器语法糖, 需要自己手动实现装饰器 闭包函数高级 func t1(b int) func(x,y int) { var a func(x,y int) a= func(x,y int) { fmt.Println(b+x+y) } return a } // 禁止套娃! 匿名空接口 // 可边长参数补充 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) } // a ... interface{} 为 匿名空接口 补充， 命名返回值 func test(x,y int)(a int) { a=x+y return } // 在指定返回值数据类型时， 可以指定要返回的内部名称变量。 // 上面例子中 就是将返回值命名给a 给类型重命名 package main import \"fmt\" func main() { var a MyFunc a(1,2) } //func(x,y int) 类型命名为MyFunc type MyFunc func(x,y int) func test() MyFunc { return func(x,y int) { fmt.Println(x+y) fmt.Println(\"xxx\") } } ","date":"2020-01-04","objectID":"/posts/go-04-%E5%87%BD%E6%95%B0/:1:0","tags":["函数"],"title":"函数","uri":"/posts/go-04-%E5%87%BD%E6%95%B0/"},{"categories":["GO"],"content":"装饰器的实现 package main import ( \"fmt\" \"time\" ) func main() { test := director(test) a:=test() fmt.Println(a) } func director(fun func() int) func() int{ a := func() int { start_time := time.Now().Unix() fmt.Println(start_time) time.Sleep(time.Second) res := fun() end_time := time.Now().Unix() fmt.Println(end_time) return res } return a } func test() int{ fmt.Println(\"我是主函数\") return 0 } // 套娃套到头疼! [toc] ","date":"2020-01-04","objectID":"/posts/go-04-%E5%87%BD%E6%95%B0/:1:1","tags":["函数"],"title":"函数","uri":"/posts/go-04-%E5%87%BD%E6%95%B0/"},{"categories":["GO"],"content":"基本数据类型 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"整型 整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64 其中，uint8就是我们熟知的byte型，int16对应C语言中的short型，int64对应C语言中的long型。 有符号整型：（长度不同，表示的数字范围不一样） -int:在32位机器上是int32，在64位机器上是int64 -int8 ：8个bit位，一个字节，正负 2的7次方-1的范围 -int16: 正负 2的15次方-1的范围 -int32: -int64: 无符号整数： -uint8 ：2的8次方-1 -uint16： -uint32 -uint64 复数： -complex类型：（了解，不知道更好）实部和虚部 其他： -byte：uint8的别名 -rune:int32的别名 特殊整型 int : 在32位机器上是int32，在64位机器上是int64 uint : 在32位机器上是uint32，在64位机器上是uint64 uintptr: 无符号整型, 用于存放一个指针 注意 在使用int 和uint类型时, 不能假定它是32位或者64位整型, 而是要考虑int 和uint 在不同平台的差异 注意事项 获取对象的长度的内建len()函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用int来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用int和 uint。 进制转换 package main import \"fmt\" func main(){ // 十进制 var a int = 10 fmt.Printf(\"%d \\n\", a) // 10 fmt.Printf(\"%b \\n\", a) // 1010 占位符%b表示二进制 // 八进制 以0开头 var b int = 077 fmt.Printf(\"%o \\n\", b) // 77 // 十六进制 以0x开头 var c int = 0xff fmt.Printf(\"%x \\n\", c) // ff fmt.Printf(\"%X \\n\", c) // FF } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"浮点型 Go语言支持两种浮点型数：float32和float64。这两种浮点型数据格式遵循IEEE 754标准： float32 的浮点数的最大范围约为 3.4e38，可以使用常量定义：math.MaxFloat32。 float64 的浮点数的最大范围约为 1.8e308，可以使用一个常量定义：math.MaxFloat64。 打印浮点数时，可以使用fmt包配合动词%f，代码如下： package main import ( \"fmt\" \"math\" ) func main() { fmt.Printf(\"%f\\n\", math.Pi) fmt.Printf(\"%.2f\\n\", math.Pi) } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:2","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"复数 complex64和complex128 var c1 complex64 c1 = 1 + 2i var c2 complex128 c2 = 2 + 3i fmt.Println(c1) fmt.Println(c2) 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:3","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"布尔值 Go语言中以bool类型进行声明布尔型数据，布尔型数据只有true（真）和false（假）两个值。 注意： 布尔类型变量的默认值为false。 Go 语言中不允许将整型强制转换为布尔型. 布尔型无法参与数值运算，也无法与其他类型进行转换。 ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:4","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串 Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。 Go 语言里的字符串的内部实现使用UTF-8编码。 字符串的值为双引号(\")中的内容，可以在Go语言的源码中直接添加非ASCII码字符， 用双引号包裹的内容,反引号 `` 反引号可以换行 注意 双引号包含的是字符串 单引号包含的是字符 例如： var a string= \"我是你爸爸\" ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:5","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串转义符 Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。 转义符 含义 \\r 回车符（返回行首） \\n 换行符（直接跳到下一行的同列位置） \\t 制表符 \\' 单引号 \\\" 双引号 \\\\ 反斜杠 举个例子，我们要打印一个Windows平台下的一个文件路径： package main import ( \"fmt\" ) func main() { fmt.Println(\"str := \\\"c:\\\\Code\\\\lesson1\\\\go.exe\\\"\") } ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:6","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"字符串的常用操作 方法 介绍 len(str) 求长度 +或fmt.Sprintf 拼接字符串 strings.Split 分割 strings.contains 判断是否包含 strings.HasPrefix,strings.HasSuffix 前缀/后缀判断 strings.Index(),strings.LastIndex() 子串出现的位置 strings.Join(a[]string, sep string) join操作 4 补充类型零值 // 补充：类型的默认值 var a int var b float32 var c string var d bool fmt.Println(a) fmt.Println(b) fmt.Println(c) fmt.Println(d) ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:7","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["GO"],"content":"数据类型的转换 //类型转换(强类型:不通类型之间不能做运算) //类型转换 //var a int =19 //var b float32=18.1 //float转成int类型，小数点后直接弃用，不是四舍五入 //fmt.Println(a+int(b)) //var b float32=18.9999 //fmt.Println(int(b)) //恶心的地方(了解) //var a int =199 //64为操作系统int64 //var b int64=199 ////int和int64不是一个类型 //fmt.Println(a+int(b)) [toc] ","date":"2020-01-04","objectID":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["golang"],"title":"基本数据类型","uri":"/posts/go-03-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Docker"],"content":"1 Docker的安装 # 1 yum 包更新到最新 yum update # 2 安装所需要的软件包, yum-util 提供yum-config-manager 功能, 另外两个是 devicemapper驱动以来的 yum install -y yum-utils device-mapper-persistent-data lvm2 # 3 设置yum 源 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo # 4 安装docker 出现输入的界面都按y yum install -y docker-ce # 5 查看docker的版本, 验证是否安装成功 docker -v ","date":"2018-12-02","objectID":"/posts/docker/:1:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"2 Docker 架构 ","date":"2018-12-02","objectID":"/posts/docker/:2:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"3 配置镜像加速器 ","date":"2018-12-02","objectID":"/posts/docker/:3:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"4 Docker 服务相关命令 启动docker服务 systemctl start docker 停止docker服务 systemctl stop docker 重启docker服务 systemctl restart docker 查看docker服务状态 systemctl status docker 开机启动docker服务 systemctl enable docker 查看docker 日志 docker logs 容器名 ","date":"2018-12-02","objectID":"/posts/docker/:4:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"5 Docker 镜像相关命令 查看本地镜像 docker images # REPOSITORY 指的是容器 # TAG 指的是版本号 # IMAGE ID 镜像的id # CREATED 创建时间 # SIZE 大小 搜索镜像 docker search redis 下载镜像 docker pull redis # 不写版本号 默认是 lastest # 我们在hub.docker.com 搜索 软件版本号 docker pull redis:5.0 # 下载 5.0 版本的 redis 删除镜像 # id 删除 docker rmi 镜像id # 版本删除 docker rmi redis:版本 # 查看所有镜像的id docker images -q # 删除所有镜像 docker rmi `docker images -q` ","date":"2018-12-02","objectID":"/posts/docker/:5:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"6 Docker 容器相关命令 创建容器 # 1 查看镜像 docker images # 创建容器 docker run -it --name=c1 mysql:5.7 /bin/bash # -i 表示 容器一直运行着 # -t 表示 给容器加个伪终端 # -d 以守护式 模式创建容器 # -name 表示 起名字 后面可以 = 或者空格 # 指定镜像 mysql:5.7 # /bin/bash 表示进入容器时的初始化指令 默认是 /bin/bash # 使用exit 退出容器 注意 : # 使用 -it 创建的容器 # 创建成功会立马进入容器 # 在退出容器后会立马停止容器 创建后台运行的容器 # 创建的容器会在后台运行. docker run -id --name=m2 mysql:5.7 查看容器 # 查看正在运行的容器 docker ps # 查看所有容器 docker ps -a 进入容器 docker exec -it 容器名 /bin/bash 启动容器 docker start 容器名 停止容器 docker stop 容器名 删除容器 docker rm 容器名 # 开启的容器是不能被删除 容器其他信息 docker inspect 容器名 查看容器日志 docker logs 容器名 容器启动错误解决 Errcode: 13 - Permission denied) # 在创建容器时 加上 -–privileged=true ","date":"2018-12-02","objectID":"/posts/docker/:6:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"7 Docker 容器的 数据卷 数据卷的简介 配置数据卷 ","date":"2018-12-02","objectID":"/posts/docker/:7:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"数据卷容器 简介 配置数据卷容器 数据卷目录 位置查找 # 查找容器的具体信息 docker inspect 容器名 查找宿主机数据目录与容器对应目录 ","date":"2018-12-02","objectID":"/posts/docker/:7:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"小结 ","date":"2018-12-02","objectID":"/posts/docker/:7:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"8 Docker的应用部署 ","date":"2018-12-02","objectID":"/posts/docker/:8:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 mysql 1 搜索 mysql docker search mysql 2 拉取mysql 镜像 docker pull mysql:5.7 3 创建容器 # 1 在/root 下创建mysql 目录 用于存储mysql数据信息 mkdir ~/mysql cd ~/mysql docker run -id \\ -p 3306:3306 \\ --name=c_mysql \\ -v $PWD/conf:/etc/mysql/conf.d \\ -v $PWD/logs:/logs \\ -v $PWD/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=951228 \\ mysql:5.7 参数说明 -p 3307:3306 将容器的3306端口映射到宿主机的3307端口 -v $pwd/conf:/etc/mysql/conf.d 将主机当前目录下的conf/my.cnf 挂在到容器的 /etc.mysql/my.cnf 配置目录 -v $pwd/logs:/logs 将 主机当前目录下的logs 目录挂在到容器的/logs 日志目录 -v $pwd/data:/var/lib/mysql 讲主机当前目录下的data 目录 挂载到容器的 /var/lib/mysql 数据目录 -e MYSQL_ROOT_PASSWORD=123456 初始化root用户的密码 Mysql 5.7 默认配置文件 # For advice on how to change settings please see # http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html [mysqld] # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. # innodb_buffer_pool_size = 128M # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # These are commonly set, remove the # and set as required. # basedir = ..... # datadir = ..... # port = ..... # server_id = ..... # socket = ..... # Remove leading # to set options mainly useful for reporting servers. # The server defaults are faster for transactions and fast SELECTs. # Adjust sizes as needed, experiment to find the optimal values. # join_buffer_size = 128M # sort_buffer_size = 2M # read_rnd_buffer_size = 2M sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES docker 中配置默认路径 /usr/my.cnf ","date":"2018-12-02","objectID":"/posts/docker/:8:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Tomcat # 注意 需要进入 tomcat 容器内 把 webapps.disp 改名为 webapps , 不然访问不到主页 1 搜索tomcat镜像 docker search tomcat 2 拉去tomcat 镜像 docker pull tomcat 3 创建容器, 设置端口映射, 目录映射 mkdir ~/tomcat cd ~/tomcat docker run -id --name=c_tomcat \\ -p 8080:8080 \\ -v $PWD:/usr/local/tomcat/webapps \\ tomcat 参数解释同上 ","date":"2018-12-02","objectID":"/posts/docker/:8:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Nginx # 注意, 首先要创建nginx.conf 文件 用于管理 容器的nginx # 在 宿主nginx 文件夹下创建/conf/nginx.conf 用于映射 容器nginx配置文件 Nginx 原始配置文件 搜索nginx镜像 docker search nginx 拉去nginx 镜像 docker pull nginx 创建nginx 容器 mkdir ~/nginx cd mkdir ~/nginx # 创建 conf 文件夹 mkdir conf # 在conf 文件夹下创建 nginx.conf 文件, 粘贴下面内容 vim nginx.conf 准备好 nginx 配置文件 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf; } 创建nginx 容器 docker run -id --name=c_nginx \\ -p 80:80 \\ -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v $PWD/logs:/var/log/nginx \\ -v $PWD/html:/usr/share/nginx/html \\ nginx 参数说明 # -p 80:80 宿主机80 端口 映射 容器的80端口 # -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf 使用宿主机 nginx.conf 配置文件映射到 容器的配置文件 # -v $PWD/logs:/var/log/nginx 挂在log 目录文件 # -v $PWD/html:/usr/share/nginx/html ","date":"2018-12-02","objectID":"/posts/docker/:8:3","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 部署 Redis 1 搜索 Redis docker search redis 2 拉去镜像 docker pull redis:5.0 3 创建容器 映射端口 docker run -id --name=c_redis -p 6379:6379 redis:5.0 ","date":"2018-12-02","objectID":"/posts/docker/:8:4","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"9 Docker 镜像原理 ","date":"2018-12-02","objectID":"/posts/docker/:9:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"10 Docker 镜像制作 ","date":"2018-12-02","objectID":"/posts/docker/:10:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"第一种方式 容器转镜像 ","date":"2018-12-02","objectID":"/posts/docker/:10:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"第二种方式 dockerfile 关键字 Dockerfile 案例1 构建镜像 docker built -f centos_dockerfile -t itheima_centos:1.0 # -f 找到 dockerfile 文件 # -t 指定 新镜像的名称及版本 Dockerfile 案例2 ","date":"2018-12-02","objectID":"/posts/docker/:10:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"11 Docker的服务编排 ","date":"2018-12-02","objectID":"/posts/docker/:11:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"介绍 ","date":"2018-12-02","objectID":"/posts/docker/:11:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker Compose 1 安装 Docker Compose # Compose 目前已经完全支持Linux , Macos 和Windows, 在我们安装Compose 之前, 需要先安装Docker, 下面我们以编译好的二进制包方式安装在Linux系统中. curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose=`uname -s`-`uname -m` -o /usr/local/bin/docker-compose # 设置文件可执行权限 chmod +x /usr/local/bin/docker-compose # 查看版本信息 docker-compose -version 2 卸载 Docker Compose # 而今之宝方式安装的, 删除二进制文件即可 rm /usr/local/bin/docker-compose 3 使用 1 创建 docker-compose 目录 mkdir ~/docker-compose cd ~/docker-compose 2 编写 docker-compose.yml文件 version: '3' services: nginx: image: nginx ports: - 80:80 links: - app valumes: - ./nginx/conf.d:/etc/nginx/conf.d app: image: app expose: - \"8080\" 3 创建./nginx/conf.d 目录 mkdir -p ./nginx/conf.d # -p 表示是在父文件夹 4 在 ./nginx/conf.d 目录下 编写 nginx 的 conf 文件. 文件必须是 conf 文件 名字无所谓 server { listen 80; access_log off; location / { proxy_pass http://app:8080; } } 5 在 ~/docker-compose 目录下 使用 docker-compose 启动容器 docker-compose up 6 测试访问 直接访问 nginx ","date":"2018-12-02","objectID":"/posts/docker/:11:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"12 Docker 私有仓库 ","date":"2018-12-02","objectID":"/posts/docker/:12:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"一 私有仓库的搭建 # 1 拉去私有仓库镜像 docker pull registry # 2 启动私有仓库容器 docker run -id --name=registry -p 5000:5000 registry # 3 打开浏览器 输入地址 http://私有仓库服务器ip:5000/v2/_catalog , 看到 {\"repositories\":[]} 表示私有仓库 搭建成功 # 4 修改daemon.json vim /etc/docker/daemon.json # 在上述稳健者添加一个key, 保存退出. 此步用于让docker 新人私有仓库地址; 注意 讲次有仓库服务器ip 修改为自己私有仓库服务器的真是ip {\"insecure-registries\":[\"私有仓库服务器ip:5000\"]} # 5 重启 docker 服务 systemctl restart docker docker start registry ","date":"2018-12-02","objectID":"/posts/docker/:12:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"二 将 镜像上传至私有仓库 # 1 标记镜像为私有仓库镜像 docker tag centos:7 私有仓库服务器ip\"5000/contos:7 # 2 上传标记镜像 docker push 私有仓库服务器ip:5000/centos:7 ","date":"2018-12-02","objectID":"/posts/docker/:12:2","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"三 私有仓库的镜像拉到本地 docker pull 仓库ip:5000/centos:7 # 拉取镜像到本地 ","date":"2018-12-02","objectID":"/posts/docker/:12:3","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"13 Docker 与 虚拟机的对比 ","date":"2018-12-02","objectID":"/posts/docker/:13:0","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker 容器虚拟化 与 创痛虚拟机比较 [toc] ","date":"2018-12-02","objectID":"/posts/docker/:13:1","tags":["Docker"],"title":"Docker 详解","uri":"/posts/docker/"},{"categories":["Docker"],"content":"Docker容器间通信 Docker会为每个创建的容器自动分配一个虚拟IP，这个虚拟IP无法从容器外侧进行访问，只是Docker环境内部容器间彼此通信的标识，容器间的网络是互通互联的。 但是通过这种虚拟IP方式，进行容器间的通信，有一些局限性。因为在Docker中创建一个容器非常容易，比如说新创建的MySQL容器可能会替代之前创建的MySQL容器，而此时Tomcat服务器中配置的是之前的MySQL容器的Ip地址，因此随着新容器的创建，之前Tomcat配置的Ip地址需要不断的变更，并重启服务。当有很多Tomcat服务器同时连接MySQL数据库时，这个修改工作就是一个很大的工作量。 那这个问题如何解决呢？ 容器创建时进行命名，配置连接时不在配置IP地址，而是配置容器的名字，这样以后再创建容器时，只要名字不变，就可以自动连接到新创建的容器。 举例说明： （1）创建web服务 # 创建容器 运行Tomcat服务 --name 为容器命名 docker run -d --name webserver tomcat （2）创建数据库服务（模拟） docker run -d --name database -it centos /bin/bash 注：命令添加中的-d -it 和**/bin/bash** 是因为centos容器创建完成后，默认就进入退出状态。如果想让其保持运行状态，后台必须保持一个进程在运行，/bin/bash表示启动容器后启动bash。 （3）查看正在运行的容器 （4）查看连个容器的虚拟IP地址 通过docker inspect [OPTIONS] NAME|ID 命令查看 docker inspect : 获取容器/镜像的元数据。 首先查看webserver容器的Ip地址 docker inspect webserver 查看database容器的IP地址 docker inspect database （5）进入webserver容器内容，测试网络 docker exec -it webserver /bin/bash 但是直接ping database却是不通的，因为我们并没有进行相应的网络设置，docker并不知道database和哪个IP是对应的，因此我们可以在创建webserver容器时指定webserver到database的单向通信。 ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:0","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"1、容器间单向通信 移除上面创建的web容器，并重新创建 # 强制移除webserver容器 docker rm -f webserver # 重新创建webserver容器 --link 要链接的容器名称 （--link 可以使新生成的容器链接到已在运行的容器） docker run -d --name webserver --link database tomcat Tomcat中的数据库连接配置文件中的url中的IP地址即可换成database ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:1","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"2、容器间双向通信 图中的网桥充当了Docker容器和外界宿主机之间的通信源，使得容器内部也可以访问互联网 例如在webserver内部可以访问百度 网桥也可以用于容器内部，实现容器间的双向通信。不仅如此网桥还有另一个重要作用，就是对容器从网络层面进行分组 （1）通过【docker network ls 】列出当前网络状况明细 上图中列出的bridge即为容器和外界通信的桥梁，如果我们想实现容器内部的双向通信也可以创建一个网桥，具体操作过程如下： （2）创建网桥 # 创建网桥 docker network create -d bridge my-bridge # 执行命令进行查看 docker network ls （3）将需要通信的容器添加到网桥中 docker network connect my-bridge webserver docker network connect my-bridge database （4）进入容器进行验证是否能够互相通信 网桥的原理：创建一个网桥，就相当于在宿主机上安装了一个虚拟网卡，这个虚拟网卡也承担了网关的作用。虚拟网卡和物理网卡之间需要做地址转换 ","date":"2018-09-03","objectID":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/:1:2","tags":["Docker"],"title":"Docker 容器间通讯","uri":"/posts/docker-%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E8%AE%AF/"},{"categories":["Docker"],"content":"安装 docker-compose ","date":"2018-09-03","objectID":"/posts/docker-compose/:0:1","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"切换到root 用户 下载 curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` \u003e /usr/local/bin/docker-compose 修改权限 chmod +x /usr/local/bin/docker-compose 检查是否成功 docker-compose -version 此外，因为 docker-compose 使用 Python 编写，所以可以使用 pip 直接安装： $ pip install -U docker-compose 1 ","date":"2018-09-03","objectID":"/posts/docker-compose/:0:2","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"第一个 Compose file version: '3' services: spider: build: context: . dockerfile: Dockerfile volumes: - $PWD:/code - /data1/datascience/scrapy-data:/data command: scrapy crawl comment 12345678910 说明： version 指定了 compose file 的版本，最新的版本为 3.4 services 下定义服务，这里定义了一个爬虫服务 spider build 指定构建镜像上下文、Dockerfile 文件和 ARGS 等。 volumes 用于创建卷并挂载，这里挂载了源码目录和数据存储目录 command 指定服务启动时执行的命令，参考 Dockerfile COMMAND。 ","date":"2018-09-03","objectID":"/posts/docker-compose/:1:0","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["Docker"],"content":"Compose file 指令 先来看一份 docker-compose.yml 文件： version: '2' services: web: image: dockercloud/hello-world ports: - 8080 networks: - front-tier - back-tier redis: image: redis links: - web networks: - back-tier lb: image: dockercloud/haproxy ports: - 80:80 links: - web networks: - front-tier - back-tier volumes: - /var/run/docker.sock:/var/run/docker.sock networks: front-tier: driver: bridge back-tier: driver: bridge 可以看到一份标准配置文件应该包含 version、services、networks 三大部分，其中最关键的就是 services 和 networks 两个部分，下面先来看 services 的书写规则。 image: 指定容器启动的镜像，对应 Dockerfile FROM。 在 services 标签下的第二级标签是 web，这个名字是用户自己自定义，它就是服务名称。image 则是指定服务的镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。 image: redis image: ubuntu:14.04 image: tutum/influxdb image: example-registry.com:4000/postgresql image: a4bc65fd build: 服务除了可以基于指定的镜像，还可以基于一份 Dockerfile，在使用 up 启动之时执行构建任务，这个构建标签就是 build，它可以指定 Dockerfile 所在文件夹的路径。Compose 将会利用它自动构建这个镜像，然后使用这个镜像启动服务容器。 最简单的直接利用 Dockerfile 构建，只需要指定上下文或者 Dockerfile 位置： version: '2' services: webapp: build: . 如果需要更细粒度的配置，需要使用 context, dockerfile, args, labels 等选项。 # Dockerfile ARG buildno ARG password RUN echo \"Build number: $buildno\" RUN script-requiring-password.sh \"$password\" # docker-compose file version: '2' services: webapp: image: webapp:tag build: context: ./dir dockerfile: Dockerfile-alternate args: buildno: 1 password: secret command: 使用 command 可以覆盖容器启动后默认执行的命令。 command: bundle exec thin -p 3000 command: [\"bundle\", \"exec\", \"thin\", \"-p\", \"3000\"] container_name: 指定运行时容器名称，而不使用默认格式（\u003c项目名称\u003e\u003c服务名称\u003e\u003c序号\u003e）。 container_name: my-web-container depends_on: 指明服务之间依赖，解决了容器的依赖、启动先后的问题。 version: '3' services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres 被依赖的服务会优先启动（显然） 若服务启动时被依赖服务没有启动，则自动被启动 dns: 指定 DNS 服务器。 dns: 8.8.8.8 dns: - 8.8.8.8 - 9.9.9.9 tmpfs: 挂载临时目录到容器内部，与 run 的参数一样效果： tmpfs: /run tmpfs: - /run - /tmp entrypoint: 在 Dockerfile 中有一个指令叫做 ENTRYPOINT 指令，用于指定接入点，在 docker-compose.yml 中可以定义接入点，覆盖 Dockerfile 中的定义。 entrypoint: /code/entrypoint.sh env_file: 专门存放变量的文件。如果通过 docker-compose -f FILE 指定了配置文件，则 env_file 中路径会使用配置文件路径。如果有变量名称与 environment 指令冲突，则以后者为准。格式如下： env_file: .env env_file: - ./common.env - ./apps/web.env - /opt/secrets.env 文件格式如： RACK_ENV=development 注意的是这里所说的环境变量是对宿主机的 Compose 而言的，如果在配置文件中有 build 操作，这些变量并不会进入构建过程中，如果要在构建中使用变量还是首选前面刚讲的 arg 标签。 environment: 与上面的 env_file 标签完全不同，反而和 arg 有几分类似，这个标签的作用是设置镜像变量，它可以保存变量到镜像里面，也就是说启动的容器也会包含这些变量设置，这是与 arg 最大的不同。 一般 arg 标签的变量仅用在构建过程中。而 environment 和 Dockerfile 中的 ENV 指令一样会把变量一直保存在镜像、容器中，类似 docker run -e 的效果。 environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET: environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET expose: 这个标签与 Dockerfile 中的 EXPOSE 指令一样，用于指定暴露的端口，但是只是作为一种参考，实际上 docker-compose.yml 的端口映射还得 ports 这样的标签。 expose: - \"3000\" - \"8000\" external_links: 在使用 Docker 过程中，我们会有许多单独使用docker run启动的容器，为了使 Compose 能够连接这些不在 docker-compose.yml 中定义的容器，我们需要一个特殊的标签，就是 external_links，它可以让 Compose 项目里面的容器连接到那些项目配置外部的容器（前提是外部容器中必须至少有一个容器是连接到与项目内的服务的同一个网络里面）。 external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts: 添加主机名的标签，就是往 /etc/hosts 文件中添加一些记录、 extra_hosts: - \"somehost:162.242.195.82\" - \"otherhost:50.31.209.229\" labels: 向容器添加元数据，和 Dockerfile 的 LABEL 指令一个意思。 labels: com.example.description: \"Accounting webapp\" com.example.department: \"Finance\" com.example.label-with-empty-value: \"\" labels: - \"com.example.description=Accounting webapp\" - \"com.example.department=Finance\" - \"com.example.label-with-empty-value\" links: 上面的 depends_on 标签解决的是启动顺序问题，这个标签解决的是容器连接问题，与 Docker client 的 –link 一样效果，会连接到其它服务中的容器。。 web: links: - db - db:database - redis 使用的别名将会自动在服务容器中的 /etc/hosts 里创建。 相应的环境变量也将被创建。 logging: 用于配置日志服务。默认的 driver 是 json-file。 logging: driver: syslog options: syslog-address: \"tcp://192.168.0.42:123\" pid: 将 PID 模式设置为主机 PID 模式，跟主机系统共享进程命名空间。容器使用这个标签将能够访问和操纵其他容器和宿主机的名称空间。 pid: \"host\" ports: 映射端口的标签。使用 HOST:CONTAINER 格式或者只是指定容器的端口，宿主机会随机映射端口。 ports: - \"3000\" - \"8000:8000\" - \"49100:22\" - \"127.0.0.1:8001:8001\" 12345 注意：当使用 HOST:CONTAINER","date":"2018-09-03","objectID":"/posts/docker-compose/:2:0","tags":["Docker"],"title":"Docker-compose","uri":"/posts/docker-compose/"},{"categories":["爬虫"],"content":"爬虫 Scrapy高级 使用 ","date":"2017-07-09","objectID":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/:0:0","tags":["爬虫","scrapy"],"title":"动作链","uri":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/"},{"categories":["爬虫"],"content":"动作链 from selenium import webdriver from selenium.webdriver import ActionChains import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get('https://www.runoob.com/try/try.php?filename=jqueryui-api-droppable') bro.implicitly_wait(10) #切换frame（很少） bro.switch_to.frame('iframeResult') div=bro.find_element_by_xpath('//*[@id=\"draggable\"]') # 使用动作链 #得到一个动作练对象 action=ActionChains(bro) # 使用动作链 #点击并且夯住 action.click_and_hold(div) # 直接把上面的div移动到某个元素上 # action.move_to_element(元素控件) # 移动x坐标，y坐标 # 三种移动方式 # action.move_by_offset() # 通过坐标 # action.move_to_element() # 到另一个标签 # action.move_to_element_with_offset() # 到另一个标签，再偏移一部分 for i in range(5): action.move_by_offset(10,10) # 直接把上面的div移动到某个元素上的某个位置 # action.move_to_element_with_offset() # 调用它，会动起来 action.perform() time.sleep(1) #释放动作链 action.release() time.sleep(5) bro.close() ","date":"2017-07-09","objectID":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/:1:0","tags":["爬虫","scrapy"],"title":"动作链","uri":"/posts/spider-7%E5%8A%A8%E4%BD%9C%E9%93%BE%E8%87%AA%E5%8A%A8%E7%99%BB%E5%BD%9512306/"},{"categories":["爬虫"],"content":"爬虫 Scrapy高级 使用 ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:0:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"scrapy 请求传参 # 1 放 ：yield Request(url,callback=self.parser_detail,meta={'item':item}) # 2 取：response.meta.get('item') # 3 指定解析函数 callback=self.解析函数. class CnblogSpider(scrapy.Spider): name = 'cnblog' # allowed_domains = ['https://www.cnblogs.com/'] start_urls = ['https://www.cnblogs.com/sitehome/p/1'] num = 0 # post_list \u003e div:nth-child(19) \u003e div def parse(self, response): article_list = response.css(\".post_item_body\") for article in article_list: item = CrawlCnblogsItem() title = article.css(\".titlelnk::text\").extract_first() url = article.css(\".titlelnk::attr(href)\").extract_first() desc = article.css(\"p::text\").extract()[-1] author = article.css(\".post_item_foot\u003ea::text\").extract_first() comment = article.xpath(\".//*[contains(@class,'post_item_foot')]/span[1]/a/text()\").extract_first() view = article.xpath(\".//*[contains(@class,'post_item_foot')]/span[2]/a/text()\").extract_first() item[\"title\"] = title.strip() item[\"url\"] = url item[\"desc\"] = desc item[\"author\"] = author.strip() item[\"comment\"] = comment.strip() item[\"view\"] = view.strip() yield item nextpage = f'https://www.cnblogs.com{response.css(\".pager\u003e a:last-child::attr(href)\").extract_first()}' if nextpage and (self.num \u003c 10): yield Request(url=nextpage, callback=self.parse) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:1:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"提高爬取效率 - 在配置文件中进行相关的配置即可:(默认还有一套setting) #1 增加并发： 默认scrapy开启的并发线程为32个，可以适当进行增加。在settings配置文件中修改CONCURRENT_REQUESTS = 100值为100,并发设置成了为100。 #2 提高日志级别： 在运行scrapy时，会有大量日志信息的输出，为了减少CPU的使用率。可以设置log输出信息为INFO或者ERROR即可。在配置文件中编写：LOG_LEVEL = ‘INFO’ # 3 禁止cookie： 如果不是真的需要cookie，则在scrapy爬取数据时可以禁止cookie从而减少CPU的使用率，提升爬取效率。在配置文件中编写：COOKIES_ENABLED = False # 4禁止重试： 对失败的HTTP进行重新请求（重试）会减慢爬取速度，因此可以禁止重试。在配置文件中编写：RETRY_ENABLED = False # 5 减少下载超时： 如果对一个非常慢的链接进行爬取，减少下载超时可以能让卡住的链接快速被放弃，从而提升效率。在配置文件中进行编写：DOWNLOAD_TIMEOUT = 10 超时时间为10s ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:2:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"下载中间件 # 2大中间件：下载中间件，爬虫中间件 # 1 写在middlewares.py中（名字随便命名） # 2 配置生效（） SPIDER_MIDDLEWARES = { 'cnblogs_crawl.middlewares.CnblogsCrawlSpiderMiddleware': 543, } DOWNLOADER_MIDDLEWARES = { 'cnblogs_crawl.middlewares.CnblogsCrawlDownloaderMiddleware': 543, } # 2 下载中间件 -process_request：（请求去，走） # - return None: 继续处理当次请求，进入下一个中间件 # - return Response： 当次请求结束，把Response丢给引擎处理（可以自己爬，包装成Response） # - return Request ： 相当于把Request重新给了引擎，引擎再去做调度 # - 抛异常：执行process_exception -process_response：（请求回来，走） # - return a Response object ：继续处理当次Response，继续走后续的中间件 # - return a Request object：重新给引擎做调度 # - or raise IgnoreRequest ：process_exception -process_exception：（出异常，走） # - return None: continue processing this exception # - return a Response object: stops process_exception() chain ：停止异常处理链，给引擎（给爬虫） # - return a Request object: stops process_exception() chain ：停止异常处理链，给引擎（重新调度） ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:3:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"集成 selenium # 在爬虫已启动，就打开一个chrom浏览器，以后都用这一个浏览器来爬数据 # 1 在爬虫中创建bro对象 bro = webdriver.Chrome(executable_path='./chromedriver') # 2 中间件中使用： spider.bro.get(request.url) text=spider.bro.page_source response=HtmlResponse(url=request.url,status=200,body=text.encode('utf-8')) return response # 3 关闭，在爬虫中 def close(self, reason): self.bro.close() ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:4:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"fack-useragent # 请求头中的user-agent list=['',''] # pip3 install fake-useragent # https://github.com/hellysmile/fake-useragent from fake_useragent import UserAgent ua=UserAgent(verify_ssl=False) print(ua.random) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:5:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"去重源码分析 # 去重源码分析 # from scrapy.core.scheduler import Scheduler # Scheduler下：def enqueue_request(self, request)方法判断是否去重 if not request.dont_filter and self.df.request_seen(request): Requests对象，RFPDupeFilter对象 # 如果要自己写一个去重类 -写一个类，继承BaseDupeFilter类 -重写def request_seen(self, request): -在setting中配置：DUPEFILTER_CLASS = '项目名.dup.UrlFilter' # scrapy起始爬取的地址 def start_requests(self): for url in self.start_urls: yield Request(url) 增量爬取 -增量爬取（100链接，150个链接） -已经爬过的，放到某个位置（mysql，redis中：集合） -如果用默认的，爬过的地址，放在内存中，只要项目一重启，就没了，它也不知道我爬过那个了，所以要自己重写去重方案 -你写的去重方案，占得内存空间更小 -bitmap方案 -BloomFilter布隆过滤器 from scrapy.http import Request from scrapy.utils.request import request_fingerprint # 这种网址是一个 requests1=Request(url='https://www.baidu.com?name=lqz\u0026age=19') requests2=Request(url='https://www.baidu.com?age=18\u0026name=lqz') ret1=request_fingerprint(requests1) ret2=request_fingerprint(requests2) print(ret1) print(ret2) # bitmap去重 一个小格表示一个连接地址 32个连接，一个比特位来存一个地址 # https://www.baidu.com?age=18\u0026name=lqz ---》44 # https://www.baidu.com?age=19\u0026name=lqz ---》89 # c2c73dfccf73bf175b903c82b06a31bc7831b545假设它占4个bytes，4*8=32个比特位 # 存一个地址，占32个比特位 # 10个地址，占320个比特位 #计算机计量单位 # 比特位：只能存0和1 # 8个比特位是一个bytes # 1024bytes=1kb # 1024kb=1m # 1024m=1g # 布隆过滤器：原理和python中如何使用 def request_seen(self, request): # 把request对象传入request_fingerprint得到一个值：aefasdfeasd # 把request对象，唯一生成一个字符串 fp = self.request_fingerprint(request) #判断fp，是否在集合中，在集合中，表示已经爬过，return True，他就不会再爬了 if fp in self.fingerprints: return True # 如果不在集合中，放到集合中 self.fingerprints.add(fp) if self.file: self.file.write(fp + os.linesep) ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:6:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"分布式爬虫 # 1 安装pip3 install scrapy-redis # 1 原来的爬虫继承 from scrapy_redis.spiders import RedisSpider class CnblogsSpider(RedisSpider): #start_urls = ['http://www.cnblogs.com/'] redis_key = 'myspider:start_urls' # 2 在setting中配置 SCHEDULER = \"scrapy_redis.scheduler.Scheduler\" DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\" ITEM_PIPELINES = { 'scrapy_redis.pipelines.RedisPipeline': 300 } # 3 多台机器上启动scrapy # 4 向reids中发送起始url lpush myspider:start_urls https://www.cnblogs.com ","date":"2017-07-08","objectID":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/:7:0","tags":["爬虫","scrapy"],"title":"Scrapy高级","uri":"/posts/spider-6scrapy%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"爬虫 Scrapy框架 使用 ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:0:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"1 Scrapy 介绍/架构 Scrapy一个开源和协作的框架，其最初是为了页面抓取 (更确切来说, 网络抓取 )所设计的，使用它可以以快速、简单、可扩展的方式从网站中提取所需的数据。但目前Scrapy的用途十分广泛，可用于如数据挖掘、监测和自动化测试等领域，也可以应用在获取API所返回的数据(例如 Amazon Associates Web Services ) 或者通用的网络爬虫。 Scrapy 是基于twisted框架开发而来，twisted是一个流行的事件驱动的python网络框架。因此Scrapy使用了一种非阻塞（又名异步）的代码来实现并发。整体架构大致如下 Components： 引擎(EGINE) 引擎负责控制系统所有组件之间的数据流，并在某些动作发生时触发事件。有关详细信息，请参见上面的数据流部分。 调度器(SCHEDULER) 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL的优先级队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址 下载器(DOWLOADER) 用于下载网页内容, 并将网页内容返回给EGINE，下载器是建立在twisted这个高效的异步模型上的 爬虫(SPIDERS) SPIDERS是开发人员自定义的类，用来解析responses，并且提取items，或者发送新的请求 项目管道(ITEM PIPLINES) 在items被提取后负责处理它们，主要包括清理、验证、持久化（比如存到数据库）等操作 下载器中间件(Downloader Middlewares) 位于Scrapy引擎和下载器之间，主要用来处理从EGINE传到DOWLOADER的请求request，已经从DOWNLOADER传到EGINE的响应response，你可用该中间件做以下几件事 process a request just before it is sent to the Downloader (i.e. right before Scrapy sends the request to the website); change received response before passing it to a spider; send a new Request instead of passing received response to a spider; pass response to a spider without fetching a web page; silently drop some requests. 爬虫中间件(Spider Middlewares) 位于EGINE和SPIDERS之间，主要工作是处理SPIDERS的输入（即responses）和输出（即requests） 官网链接：https://docs.scrapy.org/en/latest/topics/architecture.html ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:1:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"2 Scripy框架的安装和启动 安装 #Windows平台 1、pip3 install wheel #安装后，便支持通过wheel文件安装软件，wheel文件官网：https://www.lfd.uci.edu/~gohlke/pythonlibs 3、pip3 install lxml 4、pip3 install pyopenssl 5、下载并安装pywin32：https://sourceforge.net/projects/pywin32/files/pywin32/ 6、下载twisted的wheel文件：http://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted 7、执行pip3 install 下载目录\\Twisted-17.9.0-cp36-cp36m-win_amd64.whl 8、pip3 install scrapy #Linux和 mac平台 1、pip3 install scrapy 创建 scrapy startproject #创建项目 scrapy genspider #创建爬虫程序 启动 scrapy crawl 爬虫名字 # 启动爬虫 scrapy crawl 爬虫名字 --nolog # 不打印日志启动 从文件启动 from scrapy.cmdline import execute # execute(['scrapy','crawl','chouti','--nolog']) execute(['scrapy','crawl','chouti']) ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:2:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"3 配置文件和目录介绍 目录介绍 -crawl_chouti # 项目名 -crawl_chouti # 跟项目一个名，文件夹 -spiders # spiders：放着爬虫 genspider生成的爬虫，都放在这下面 -__init__.py -chouti.py # 抽屉爬虫 -cnblogs.py # cnblogs 爬虫 -items.py # 对比django中的models.py文件 ,写一个个的模型类 -middlewares.py # 中间件（爬虫中间件，下载中间件），中间件写在这 -pipelines.py # 写持久化的地方（持久化到文件，mysql，redis，mongodb） -settings.py # 配置文件 -scrapy.cfg # 不用关注，上线相关的 配置文件 # 配置文件 ROBOTSTXT_OBEY = False # 是否遵循爬虫协议，强行运行 USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36' # 请求头中的ua LOG_LEVEL='ERROR' # 这样配置，程序错误信息才会打印， #启动爬虫直接 scrapy crawl 爬虫名 就没有日志输出 # scrapy crawl 爬虫名 --nolog 爬虫文件 class ChoutiSpider(scrapy.Spider): name = 'chouti' # 爬虫名字 allowed_domains = ['https://dig.chouti.com/'] # 允许爬取的域 start_urls = ['https://dig.chouti.com/'] # 起始爬取的位置，爬虫一启动，会先向它发请求 def parse(self, response): # 解析，请求回来，自动执行parser，在这个方法中做解析 print('---------------------------',response) 数据解析 使用bs4 # 1 解析，可以使用bs4解析 from bs4 import BeautifulSoup soup=BeautifulSoup(response.text,'lxml') soup.find_all() 使用内置解析器 response.css response.xpath # 解析 # 所有用css或者xpath选择出来的都放在列表中 # 取第一个:extract_first() # 取出所有extract() # css选择器取文本和属性： response.css(\".link-title::text\") response.css(\".link-title::attr(href)\") # xpath选择器取文本和属性 response.xpath('.//a[contains(@class,\"link-title\")/text()]') response.xpath('//a[contains(@class,\"link-title\")/@href]') ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:3:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"4 数据持久化 # 方式一 -1 parser解析函数，return 列表，列表套字典 -2 scrapy crawl chouti -o aa.json (支持：('json', 'jsonlines', 'jl', 'csv', 'xml', 'marshal', 'pickle') # 方式二 pipline的方式（管道） -1 在items.py中创建模型类 -2 在爬虫中chouti.py，引入，把解析的数据放到item对象中（要用中括号） -3 yield item对象 -4 配置文件配置管道 ITEM_PIPELINES = { # 数字表示优先级（数字越小，优先级越大） 'crawl_chouti.pipelines.CrawlChoutiPipeline': 300, 'crawl_chouti.pipelines.CrawlChoutiRedisPipeline': 301， } -5 pipline.py中写持久化的类 # 在保存数据之前执行的函数 -spider_open # 在执行数据持久化之后执行的函数 -spider_close -process_item（在这写保存到哪） [toc] ","date":"2017-07-07","objectID":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/:4:0","tags":["爬虫","scrapy"],"title":"Scrapy框架","uri":"/posts/spider-5scrapy%E6%A1%86%E6%9E%B6/"},{"categories":["爬虫"],"content":"爬虫 selenium 模块使用 ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:0:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"介绍 selenium最初是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题 可以操作浏览器(火狐，谷歌（建议你用谷歌），ie)，模拟人的行为（人可以干啥，代码控制就可以干啥） ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:1:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"selenium的简单使用 # pip3 install selenium # 1 基本使用 from selenium import webdriver # import time # # 得到 一个谷歌浏览器对象 # # 代码不能直接操作浏览器，需要有一个浏览器驱动（配套的） # # 下载谷歌浏览器驱动：http://npm.taobao.org/mirrors/chromedriver/ # # 谷歌浏览器驱动要跟谷歌版本对应 # # http://npm.taobao.org/mirrors/chromedriver/80.0.3987.106/ ：80.0.3987.149（正式版本） # # 指定一下驱动的位置（相对路径/绝对路径） # bro=webdriver.Chrome(executable_path='./chromedriver') # # bro.get(\"https://www.baidu.com\") # # # 页面内容 # # ret.text 相当于它，可以使用bs4解析数据，或者用selenium自带的解析器解析 # print(bro.page_source) # time.sleep(5) # bro.close() ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:2:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"selenium的高级用法 常用方法 bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") 解析器 # 1、find_element_by_id # id找 # 2、find_element_by_link_text # a标签上的文字找 # 3、find_element_by_partial_link_text # a标签上的文字模糊 # 4、find_element_by_tag_name # 根据标签名字找 # 5、find_element_by_class_name # 根据类名字找 # 6、find_element_by_name # name='xx' 根据name属性找 # 7、find_element_by_css_selector # css选择器找 # 8、find_element_by_xpath #xpath选择器找 在输入框中输入美女（自带的解析器，查找输入框空间） # //*[@id=\"kw\"] # input_search=bro.find_element_by_xpath('//*[@id=\"kw\"]') input_search=bro.find_element_by_css_selector('#kw') 写文字 input_search.send_keys(\"美女\") 查找搜索按钮 enter=bro.find_element_by_id('su') 点击按钮 enter.click() 关闭浏览器 bro.close() 小案例 import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") # # 隐士等待(最多等待10s) # 只有控件没有加载出来，才会等，控件一旦加载出来，直接就取到 bro.implicitly_wait(10) submit_button=bro.find_element_by_link_text('登录') submit_button.click() user_button=bro.find_element_by_id('TANGRAM__PSP_10__footerULoginBtn') user_button.click() user_input=bro.find_element_by_id('TANGRAM__PSP_10__userName') user_input.send_keys(\"ssssss@qq.com\") pwd_input=bro.find_element_by_id('TANGRAM__PSP_10__password') pwd_input.send_keys(\"123456\") submit_input=bro.find_element_by_id('TANGRAM__PSP_10__submit') submit_input.click() time.sleep(5) bro.close() 获取 cookie # 登陆之后，拿到cookie：就可以自己搭建cookie池（requests模块发请求，携带者cookie） import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.baidu.com\") print(bro.get_cookies()) bro.close() # #搭建cookie池和代理池的作用是什么？封ip ，封账号（弄一堆小号，一堆cookie） 无界面浏览器 from selenium.webdriver.chrome.options import Options chrome_options = Options() chrome_options.add_argument('window-size=1920x3000') #指定浏览器分辨率 chrome_options.add_argument('--disable-gpu') #谷歌文档提到需要加上这个属性来规避bug chrome_options.add_argument('--hide-scrollbars') #隐藏滚动条, 应对一些特殊页面 chrome_options.add_argument('blink-settings=imagesEnabled=false') #不加载图片, 提升速度 chrome_options.add_argument('--headless') #浏览器不提供可视化页面. linux下如果系统不支持可视化不加这条会启动失败 bro=webdriver.Chrome(executable_path='./chromedriver',options=chrome_options) bro.get(\"https://www.baidu.com\") print(bro.get_cookies()) bro.close 获取标签属性(重点) print(tag.get_attribute('src')) print(tag.get_attribute('href')) 获取标签文本(重点) print(tag.text) 获取标签ID，位置，名称，大小（了解） print(tag.id) print(tag.location) print(tag.tag_name) print(tag.size) 显示等待与隐式等待 # 隐士等待(最多等待10s) bro.implicitly_wait(10) # 只有控件没有加载出来，才会等，控件一旦加载出来，直接就取到 # 显示等待（每个控件，都要写等待），不要使用 元素交互操作 # 点击click，清空clear，输入文字send_keys 执行js import time bro=webdriver.Chrome(executable_path='./chromedriver') # bro.get(\"https://www.cnblogs.com\") # 执行js代码 # bro.execute_script('alert(1)') # window.scrollTo(0,document.body.scrollHeight) # 使页面滚动到最低层 bro.execute_script('window.scrollTo(0,document.body.scrollHeight)') time.sleep(5) bro.close() 模拟浏览器的前进后头 import time bro=webdriver.Chrome(executable_path='./chromedriver') bro.get(\"https://www.cnblogs.com\") time.sleep(1) bro.get(\"https://www.baidu.com\") time.sleep(1) bro.get(\"https://www.jd.com\") #退到上一个 bro.back() time.sleep(1) # 前进一下 bro.forward() time.sleep(5) bro.close() 选项卡管理 import time from selenium import webdriver # browser=webdriver.Chrome(executable_path='./chromedriver') browser.get('https://www.baidu.com') browser.execute_script('window.open()') # 本质上是执行的js代码 print(browser.window_handles) #获取所有的选项卡 browser.switch_to_window(browser.window_handles[1]) browser.get('https://www.taobao.com') time.sleep(2) browser.switch_to_window(browser.window_handles[0]) browser.get('https://www.sina.com.cn') browser.close() 异常处理 from selenium import webdriver from selenium.common.exceptions import TimeoutException,NoSuchElementException,NoSuchFrameException try: browser=webdriver.Chrome(executable_path='./chromedriver') browser.get('http://www.baidu.com') browser.find_element_by_id(\"xxx\") # except Exception as e: # print(e) finally: browser.close() ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:3:0","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"小案例 ######## # 爬取京东商品信息 ####### from selenium import webdriver import time from selenium.webdriver.common.keys import Keys bro=webdriver.Chrome(executable_path='./chromedriver') def get_goods(bro): # find_elements_by_class_name 找所有 # find_element_by_class_name 找一个 li_list=bro.find_elements_by_class_name('gl-item') # ul_list=bro.find_elements_by_css_selector('.gl-item') for li in li_list: url=li.find_element_by_css_selector('.p-img\u003ea').get_attribute('href') url_img=li.find_element_by_css_selector('.p-img img').get_attribute(\"src\") if not url_img: url_img='https:'+li.find_element_by_css_selector('.p-img img').get_attribute(\"data-lazy-img\") price=li.find_element_by_css_selector('.p-price i').text name=li.find_element_by_css_selector('.p-name em').text commit=li.find_element_by_css_selector('.p-commit a').text print(''' 商品名字：%s 商品价格：%s 商品图片地址：%s 商品地址：%s 商品评论数：%s '''%(name,price,url,url_img,commit)) #查找下一页按钮 next=bro.find_element_by_partial_link_text('下一页') time.sleep(1) next.click() #继续抓取下一页 get_goods(bro) try: bro.get('https://www.jd.com') #隐士等待 bro.implicitly_wait(10) input_search=bro.find_element_by_id('key') input_search.send_keys(\"精品内衣\") #模拟键盘操作(模拟键盘敲回车) input_search.send_keys(Keys.ENTER) get_goods(bro) except Exception as e: print(e) finally: bro.close() [toc] ","date":"2017-07-06","objectID":"/posts/spider-4selenium/:3:1","tags":["爬虫","代理池"],"title":"selenium","uri":"/posts/spider-4selenium/"},{"categories":["爬虫"],"content":"爬虫 代理池 模块使用 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:0:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"免费代理池 # https://github.com/jhao104/proxy_pool # 收费的：提供给你一个接口，每掉一次这个接口，获得一个代理 # 免费：用爬虫爬取，免费代理，放到我的库中，flask，django搭一个服务（删除代理，自动测试代理可用性），每次发一个请求，获取一个代理 # 带你配置 # 1 下载，解压，用pycharm打开 # 2 安装依赖 pip install -r requirements.txt # 3 配置Config/setting.py: DB_TYPE = getenv('db_type', 'redis').upper() DB_HOST = getenv('db_host', '127.0.0.1') DB_PORT = getenv('db_port', 6379) DB_PASSWORD = getenv('db_password', '') # 4 本地启动redis-server # 5 可以在cli目录下通过ProxyPool.py -python proxyPool.py schedule :调度程序，他会取自动爬取免费代理 -python proxyPool.py webserver:启动api服务，把flask启动起来 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:1:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"验证码破解 # 1 简单验证码，字母，数字 # 2 高级的，选择，你好，12306选择乒乓球，滑动验证（极验） # 打码平台（自动破解验证码，需要花钱）云打码，超级鹰（12306） http://www.yundama.com/ http://www.chaojiying.com/ # 注册账号，（充钱）把demo下载下来，运行即可 ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:2:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"爬取段子发送给女朋友 ##### # 1 爬取糗事百科，微信自动发送 ##### # https://www.qiushibaike.com/text/ # https://www.qiushibaike.com/text/page/1/ import requests from bs4 import BeautifulSoup ret=requests.get('https://www.qiushibaike.com/text/page/1/') # print(ret.text) ll=[] soup=BeautifulSoup(ret.text,\"lxml\") article_list=soup.find_all(name='div',id=True,class_='article') for article in article_list: content=article.find(name='div',class_='content').span.text # content=article.find(name='div',class_='content').text # content=article.find(class_='content').text # print(content) # 入库 #我们放到列表中 ll.append(content) print(ll) # 微信自动发消息 # wxpy：实现了web微信的接口 # pip3 install wxpy from wxpy import * # 实例化得到一个对象，微信机器人对象 import random bot=Bot(cache_path=True) @bot.register() # 接收从指定好友发来的消息，发送者即recv_msg.sender为指定好友girl_friend def recv_send_msg(recv_msg): print('收到的消息：',recv_msg.text) # recv_msg.text取得文本 return random.choice(ll) embed() ","date":"2017-07-06","objectID":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/:3:0","tags":["爬虫","代理池"],"title":"代理池","uri":"/posts/spider-3%E4%BB%A3%E7%90%86%E6%B1%A0/"},{"categories":["爬虫"],"content":"爬虫 bs4 模块使用 ","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:0","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"bs4的使用 从html或者xml中提取数据的python库，修改xml # 安装 pip3 install beautifulsoup4 # 使用 from bs4 import BeautifulSoup # 实例化得到对象，传入要解析的文本，解析器 # html.parser内置解析器，速度稍微慢一些，但是不需要装第三方模块 # lxml：速度快一些，但是需要安装 pip3 install lxml soup=BeautifulSoup(ret.text,'html.parser') # soup=BeautifulSaoup(open('a.html','r')) # find（找到的第一个） # find_all(找到的所有) 遍历文档树 from bs4 import BeautifulSoup html_doc = \"\"\" \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"id=\"id_p\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \"\"\" # pip3 install lxml soup=BeautifulSoup(html_doc,'lxml') # 美化 # print(soup.prettify()) Tag 对象 from bs4.element import Tag #1、用法（通过.来查找，只能找到第一个） # head=soup.head # title=head.title # # print(head) # print(title) 获取标签名称 # p=soup.body # print(type(p)) # print(p.name) 获取标签属性 p=soup.p # 方式一 # 获取class属性,可以有多个，拿到列表 print(p['class']) print(p['id']) print(p.get('id')) # 方式二 print(p.attrs['class']) print(p.attrs.get('id')) 获取标签内容 p=soup.p print(p.text) # 所有层级都拿出来拼到一起 print(p.string) # 只有一层，才能去除 print(list(p.strings)) # 把每次都取出来，做成一个生成器 嵌套选择 title=soup.head.title print(title) 子节点 子孙节点 p1=soup.p.children # 迭代器 p2=soup.p.contents # 列表 print(list(p1)) print(p2) 父节点 祖先节点 p1=soup.p.parent # 直接父节点 p2=soup.p.parents print(p1) # print(len(list(p2))) print(list(p2)) 兄弟节点 print(soup.a.next_sibling) #下一个兄弟 print(soup.a.previous_sibling) #上一个兄弟 print(list(soup.a.next_siblings)) #下面的兄弟们=\u003e生成器对象 print(soup.a.previous_siblings) #上面的兄弟们=\u003e生成器对象 查找文档树 # 查找文档树（find，find_all），速度比遍历文档树慢 # 两个配合着使用（soup.p.find()） 五种过滤器(# 以find为例) 字符串 #1 字符串查找 引号内是字符串 p=soup.find(name='p') p=soup.find(name='body') print(p) # 查找类名是title的所有标签,class是关键字，class_ ret=soup.find_all(class_='title') href属性为http://example.com/elsie的标签 ret=soup.find_all(href='http://example.com/elsie') 找id为xx的标签 ret=soup.find_all(id='id_p') print(ret) 正则表达式 import re # reg=re.compile('^b') # ret=soup.find_all(name=reg) #找id以id开头的标签 reg=re.compile('^id') ret=soup.find_all(id=reg) print(ret) 列表 ret=soup.find_all(name=['body','b']) ret=soup.find_all(id=['id_p','link1']) ret=soup.find_all(class_=['id_p','link1']) # and 关系 ret=soup.find_all(class_='title',name='p') print(ret) True # 所有有名字的标签 ret=soup.find_all(name=True) #所有有id的标签 ret=soup.find_all(id=True) # 所有有herf属性的 ret=soup.find_all(href=True) print(ret) 方法 def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id') print(soup.find_all(has_class_but_no_id)) 其他使用 ret=soup.find_all(attrs={'class':\"title\"}) ret=soup.find_all(attrs={'id':\"id_p1\",'class':'title'}) print(ret) 拿到标签取属性, 去text ret=soup.find_all(attrs={'id':\"id_p\",'class':'title'}) print(ret[0].text) limit(限制条数) soup.find() # 就是find_all limit=1 ret=soup.find_all(name=True,limit=2) print(len(ret)) recursive recursive=False (只找儿子)不递归查找，只找第一层 ret=soup.body.find_all(name='p',recursive=False) print(ret) ","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:1","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":["爬虫"],"content":"css 和 xpath 选择器 css 选择器 # 重点 # Tag对象.select(\"css选择器\") # #ID号 # .类名 # div\u003ep：儿子 和div p：子子孙孙 # 找div下最后一个a标签 div a:last-child # bs4：自己的选择器，css选择器 # lxml：css选择器，xpath选择器 # selenium：自己的选择器，css选择器，xpath选择器 # scrapy框架：自己的选择器，css选择器，xpath选择器 # #select('.article') #该模块提供了select方法来支持css,详见官网:https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id37 html_doc = \"\"\" \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"\u003e \u003cb\u003eThe Dormouse's story\u003c/b\u003e Once upon a time there were three little sisters; and their names were \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003e \u003cspan\u003eElsie\u003c/span\u003e \u003c/a\u003e \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; \u003cdiv class='panel-1'\u003e \u003cul class='list' id='list-1'\u003e \u003cli class='element'\u003eFoo\u003c/li\u003e \u003cli class='element'\u003eBar\u003c/li\u003e \u003cli class='element'\u003eJay\u003c/li\u003e \u003c/ul\u003e \u003cul class='list list-small' id='list-2'\u003e \u003cli class='element'\u003e\u003ch1 class='yyyy'\u003eFoo\u003c/h1\u003e\u003c/li\u003e \u003cli class='element xxx'\u003eBar\u003c/li\u003e \u003cli class='element'\u003eJay\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e and they lived at the bottom of a well. \u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \"\"\" from bs4 import BeautifulSoup soup=BeautifulSoup(html_doc,'lxml') ### css 选择器 print(soup.p.select('.sister')) print(soup.select('.sister span')) print(soup.select('#link1')) print(soup.select('#link1 span')) print(soup.select('#list-2 .element.xxx')) print(soup.select('#list-2')[0].select('.element')) #可以一直select,但其实没必要,一条select就可以了 # xpath选择 # / 从根节点选取 /a 从根节点开始，往下找a标签（子） # //从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 //a 从根节点开始找a标签（子子孙孙中所有a） # . 选取当前节点。 # .. 选取当前节点的父节点。 # @ 选取属性。 ######## # 2 xpath选择器 ######## # XPath 是一门在 XML 文档中查找信息的语言 # xpath选择 # / 从根节点选取 /a 从根节点开始，往下找a标签（子） # //从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置 //a 从根节点开始找a标签（子子孙孙中所有a） # 取值 /text() # 取属性 /@属性名 # //*[@id=\"auto-channel-lazyload-article\"]/ul[1] # //ul[1] # //*[@id=\"focus-1\"]/div[1]/ul/li[3]/h2 # #focus-1 \u003e div.focusimg-pic \u003e ul \u003e li:nth-child(3) \u003e h2 doc=''' \u003chtml\u003e \u003chead\u003e \u003cbase href='http://example.com/' /\u003e \u003ctitle\u003eExample website\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id='images'\u003e \u003ca href='image1.html' id=\"xxx\"\u003eName: My image 1 \u003cbr /\u003e\u003cimg src='image1_thumb.jpg' /\u003e\u003c/a\u003e \u003ch5\u003etest\u003c/h5\u003e \u003ca href='image2.html'\u003eName: My image 2 \u003cbr /\u003e\u003cimg src='image2_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image3.html'\u003eName: My image 3 \u003cbr /\u003e\u003cimg src='image3_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image4.html'\u003eName: My image 4 \u003cbr /\u003e\u003cimg src='image4_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image5.html' class='li li-item' name='items'\u003eName: My image 5 \u003cbr /\u003e\u003cimg src='image5_thumb.jpg' /\u003e\u003c/a\u003e \u003ca href='image6.html' name='items'\u003e\u003cspan\u003e\u003ch5\u003etest\u003c/h5\u003e\u003c/span\u003eName: My image 6 \u003cbr /\u003e\u003cimg src='image6_thumb.jpg' /\u003e\u003c/a\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ''' from lxml import etree html=etree.HTML(doc) # 传字符串 # html=etree.parse('search.html',etree.HTMLParser()) # 文件 # 1 所有节点 # a=html.xpath('//*') # 2 指定节点（结果为列表） # a=html.xpath('//head') # 3 子节点，子孙节点 # a=html.xpath('//div/a') # a=html.xpath('//body/a') #无数据 # a=html.xpath('//body//a') # 4 父节点 # a=html.xpath('//body//a[@href=\"image1.html\"]/..') # a=html.xpath('//body//a[@href=\"image1.html\"]') # a=html.xpath('//body//a[1]/..') # 也可以这样 # a=html.xpath('//body//a[1]/parent::*') # 5 属性匹配 # a=html.xpath('//body//a[@href=\"image1.html\"]') # 6 文本获取 标签后加：/text() ********重点 # a=html.xpath('//body//a[@href=\"image1.html\"]/text()') # a=html.xpath('//body//a/text()') # 7 属性获取 标签后：/@href ********重点 # a=html.xpath('//body//a/@href') # # 注意从1 开始取（不是从0） # a=html.xpath('//body//a[3]/@href') # 8 属性多值匹配 # a 标签有多个class类，直接匹配就不可以了，需要用contains # a=html.xpath('//body//a[@class=\"li\"]') # a=html.xpath('//body//a[@href=\"image1.html\"]') # a=html.xpath('//body//a[contains(@class,\"li\")]') # a=html.xpath('//body//a[contains(@class,\"li\")]/text()') # a=html.xpath('//body//a[contains(@class,\"li\")]/@name') # 9 多属性匹配 or 和 and （了解） # a=html.xpath('//body//a[contains(@class,\"li\") or @name=\"items\"]') # a=html.xpath('//body//a[contains(@class,\"li\") and @name=\"items\"]/text()') # a=html.xpath('//body//a[contains(@class,\"li\"","date":"2017-07-04","objectID":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/:0:2","tags":["爬虫","bs4"],"title":"爬虫入门/bs4","uri":"/posts/spider-2%E7%88%AC%E8%99%AB%E9%AB%98%E7%BA%A7/"},{"categories":null,"content":"爬虫 requests 模块使用 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:0","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"爬虫介绍 # 1 本质：模拟发送http请求（requests）----》解析返回数据（re，bs4，lxml，json）---》入库（redis，mysql，mongodb） # 2 app爬虫：本质一模一样 # 3 为什么python做爬虫最好：包多，爬虫框架：scrapy：性能很高的爬虫框架，爬虫界的django，大而全（爬虫相关的东西都集成了） # 4 百度，谷歌，就是个大爬虫 在百度搜索，其实是去百度的服务器的库搜的，百度一直开着爬虫，一刻不停的在互联网上爬取，把页面存储到自己库中 # 5 全文检索：全文检索 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:1","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"requests 模块 requests模块是基于urllib2 内置库的基础上封装的一个模块, 被广泛应用 安装方法 pip3 install requests 基本使用 返回值的属性 import requests # # 发送http请求 # # get,delete,post。。本质都是调用request函数 # ret=requests.get('https://www.cnblogs.com') # print(ret.status_code) # 响应状态码 # print(ret.text) # 响应体，转成了字符串 # print(ret.content) # 响应体，二进制 # ret=requests.post()\\ # ret=requests.request(\"get\",) # ret=requests.delete() ## get 请求 带参数 get请求带参数 方式一 ret = requests.get('https://www.baidu.com/', headers={ 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36', }) 方式二（建议用方式二）中文会自动转码 ret=requests.get('http://0.0.0.0:8001/',params={'name':\"美女\",'age':18}) print(ret.text) 带 headers ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', headers={ # 标志，什么东西发出的请求，浏览器信息，django框架，从哪取？（meta） 'User-Agent': 'request', # 上一个页面的地址，图片防盗链 'Referer': 'xxx' }) print(ret) # 图片防盗链：如果图片的referer不是我自己的网站，就直接禁止掉 \u003cimg src=\"https://www.lgstatic.com/lg-community-fed/community/modules/common/img/avatar_default_7225407.png\"\u003e 带 cookie # 带cookie,随机字符串(用户信息：也代表session)，不管后台用的token认证，还是session认证 # 一旦登陆了，带着cookie发送请求，表示登陆了（下单，12306买票，评论） 方式一 ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', headers={ 'cookie': 'key3=value;key2=value', }) 方式二 ret = requests.get('http://0.0.0.0:8001/?name=%E7%BE%8E%E5%A5%B3', cookies={\"islogin\":\"xxx\"}) print(ret) 发送post 请求 5 发送post请求（注册，登陆），携带数据（body） data=None, json=None # data:urlencoded编码 ret=requests.post('http://0.0.0.0:8001/',data={'name':\"lqz\",'age':18}) # json:json编码 import json data=json.dumps({'name':\"lqz\",'age':18}) ret=requests.post('http://0.0.0.0:8001/',json=data) print(ret) # 注意：编码格式是请求头中带的，所有我可以手动修改，在headers中改 session 对象 session=requests.session() # 跟requests.get/post用起来完全一样，但是它处理了cookie # 假设是一个登陆，并且成功 session.post() # 再向该网站发请求，就是登陆状态，不需要手动携带cookie session.get(\"地址\") 响应对象 print(respone.text) # 响应体转成str print(respone.content) # 响应体二进制（图片，视频） print(respone.status_code) # 响应状态码 print(respone.headers) # 响应头 print(respone.cookies) # 服务端返回的cookie print(respone.cookies.get_dict()) # 转成字典 print(respone.cookies.items()) print(respone.url) # 当次请求的地址 print(respone.history) # 如果有重定向，放到一个列表中 ret=requests.post('http://0.0.0.0:8001/') ret=requests.get('http://0.0.0.0:8001/admin') #不要误解 ret=requests.get('http://0.0.0.0:8001/user') print(ret.history) print(respone.encoding) # 编码方式 response.iter_content() # 视频，图片迭代取值 with open(\"a.mp4\",'wb') as f: for line in response.iter_content(): f.write(lin 乱码问题 # 加载回来的页面，打印出来，乱码（我们用的是utf8编码），如果网站用gbk， ret.encoding='gbk' ret=requests.get('http://0.0.0.0:8001/user') # ret.apparent_encoding当前页面的编码 ret.encoding=ret.apparent_encoding 解析json # 返回数据，有可能是json格式，有可能是html格式 ret=requests.get('http://0.0.0.0:8001/') print(type(ret.text)) print(ret.text) # a=ret.json() print(a['name']) print(type(a)) 使用代理 proxies={} # 正向代理 # django如何拿到客户端ip地址 META.get(\"REMOTE_ADDR\") # 如何去获取代理，如何使用（用自己项目验收） # 使用代理有什么用 ret=requests.get('http://0.0.0.0:8001/',proxies={'http':'地址'}) print(type(ret.text)) print(ret.text) 异常处理 # 用try except捕获一下 就用它就型了：Exception 上传文件 (爬虫用的比较少，后台写服务，) file={'myfile':open(\"1.txt\",'rb')} ret=requests.post('http://0.0.0.0:8001/',files=file) print(ret.content) ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:2","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"爬梨视频 ############ # 2 爬取视频 ############# #categoryId=9 分类id #start=0 从哪个位置开始，每次加载12个 # https://www.pearvideo.com/category_loading.jsp?reqType=5\u0026categoryId=9\u0026start=0 import requests import re ret=requests.get('https://www.pearvideo.com/category_loading.jsp?reqType=5\u0026categoryId=9\u0026start=0') # print(ret.text) # 正则取解析 reg='\u003ca href=\"(.*?)\" class=\"vervideo-lilink actplay\"\u003e' video_urls=re.findall(reg,ret.text) print(video_urls) for url in video_urls: ret_detail=requests.get('https://www.pearvideo.com/'+url) reg='srcUrl=\"(.*?)\",vdoUrl=srcUrl' mp4_url=re.findall(reg,ret_detail.text)[0] #type:str # 下载视频 video_content=requests.get(mp4_url) video_name=mp4_url.rsplit('/',1)[-1] with open(video_name,'wb') as f: for line in video_content.iter_content(): f.write(line) ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:3","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":null,"content":"模拟登陆 ############ # 3 模拟登陆某网站 ############# import requests ret = requests.post('http://www.aa7a.cn/user.php', data={ 'username': '616564099@qq.com', 'password': 'lqz123', 'captcha': 'f5jn', 'remember': '1', 'ref': 'http://www.aa7a.cn/', 'act': 'act_login', }) cookie=ret.cookies.get_dict() print(cookie) # 如果不出意外，咱么就登陆上了,再向首页发请求，首页返回的数据中就有616564099@qq.com ret1=requests.get('http://www.aa7a.cn/',cookies=cookie) # ret1=requests.get('http://www.aa7a.cn/') print('616564099@qq.com' in ret1.text) # 秒杀小米手机，一堆小号 # 定时任务：一到时间，就可以发送post请求，秒杀手机 # 以后碰到特别难登陆的网站，代码登陆不进去怎么办？ # 之所以要登陆，就是为了拿到cookie，下次发请求（如果程序拿不到cookie，自动登陆不进去） # 就手动登陆进去，然后用程序发请求 ","date":"2017-07-03","objectID":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/:0:4","tags":["爬虫","requests模块"],"title":"Request模块","uri":"/posts/spider-1%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/"},{"categories":["异步"],"content":"celery 的简单使用 ","date":"2017-06-03","objectID":"/posts/celery/:0:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"官方 Celery 官网：http://www.celeryproject.org/ Celery 官方文档英文版：http://docs.celeryproject.org/en/latest/index.html Celery 官方文档中文版：http://docs.jinkan.org/docs/celery/ ","date":"2017-06-03","objectID":"/posts/celery/:1:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery异步任务框架 \"\"\" 1）可以不依赖任何服务器，通过自身命令，启动服务(内部支持socket) 2）celery服务为为其他项目服务提供异步解决任务需求的 注：会有两个服务同时运行，一个是项目服务，一个是celery服务，项目服务将需要异步处理的任务交给celery服务，celery就会在需要时异步完成项目的需求 人是一个独立运行的服务 | 医院也是一个独立运行的服务 正常情况下，人可以完成所有健康情况的动作，不需要医院的参与；但当人生病时，就会被医院接收，解决人生病问题 人生病的处理方案交给医院来解决，所有人不生病时，医院独立运行，人生病时，医院就来解决人生病的需求 \"\"\" ","date":"2017-06-03","objectID":"/posts/celery/:2:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery架构 Celery的架构由三部分组成，消息中间件（message broker）、任务执行单元（worker）和 任务执行结果存储（task result store）组成。 ","date":"2017-06-03","objectID":"/posts/celery/:3:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"消息中间件 Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成。包括，RabbitMQ, Redis等等 ","date":"2017-06-03","objectID":"/posts/celery/:3:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"任务执行单元 Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。 ","date":"2017-06-03","objectID":"/posts/celery/:3:2","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"任务结果存储 Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括AMQP, redis等 ","date":"2017-06-03","objectID":"/posts/celery/:3:3","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"使用场景 异步执行：解决耗时任务 延迟执行：解决延迟任务 定时执行：解决周期(周期)任务 ","date":"2017-06-03","objectID":"/posts/celery/:3:4","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery的安装配置 pip install celery 消息中间件：RabbitMQ/Redis app=Celery(‘任务名’, broker=‘xxx’, backend=‘xxx’) ","date":"2017-06-03","objectID":"/posts/celery/:4:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"两种celery任务结构：提倡用包管理，结构更清晰 # 如果 Celery对象:Celery(...) 是放在一个模块下的 # 1）终端切换到该模块所在文件夹位置：scripts # 2）执行启动worker的命令：celery worker -A 模块名 -l info -P eventlet # 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info # 注：模块名随意 # 如果 Celery对象:Celery(...) 是放在一个包下的 # 1）必须在这个包下建一个celery.py的文件，将Celery(...)产生对象的语句放在该文件中 # 2）执行启动worker的命令：celery worker -A 包名 -l info -P eventlet # 注：windows系统需要eventlet支持，Linux与MacOS直接执行：celery worker -A 模块名 -l info # 注：包名随意 ","date":"2017-06-03","objectID":"/posts/celery/:4:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"Celery执行异步任务 ","date":"2017-06-03","objectID":"/posts/celery/:5:0","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"包架构封装 project ├── celery_task # celery包 │ ├── __init__.py # 包文件 │ ├── celery.py # celery连接和配置相关文件，且名字必须交celery.py │ └── tasks.py # 所有任务函数 ├── add_task.py # 添加任务 └── get_result.py # 获取结果 ","date":"2017-06-03","objectID":"/posts/celery/:5:1","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"基本使用 celery.py # 1）创建app + 任务 # 2）启动celery(app)服务： # 非windows # 命令：celery worker -A celery_task -l info # windows： # pip3 install eventlet # celery worker -A celery_task -l info -P eventlet # 3）添加任务：手动添加，要自定义添加任务的脚本，右键执行脚本 # 4）获取结果：手动获取，要自定义获取任务的脚本，右键执行脚本 from celery import Celery broker = 'redis://127.0.0.1:6379/1' backend = 'redis://127.0.0.1:6379/2' app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) tasks.py from .celery import app import time @app.task def add(n, m): print(n) print(m) time.sleep(10) print('n+m的结果：%s' % (n + m)) return n + m @app.task def low(n, m): print(n) print(m) print('n-m的结果：%s' % (n - m)) return n - m add_task.py from celery_task import tasks # 添加立即执行任务 t1 = tasks.add.delay(10, 20) t2 = tasks.low.delay(100, 50) print(t1.id) # 添加延迟任务 from datetime import datetime, timedelta eta=datetime.utcnow() + timedelta(seconds=10) tasks.low.apply_async(args=(200, 50), eta=eta) get_result.py from celery_task.celery import app from celery.result import AsyncResult id = '21325a40-9d32-44b5-a701-9a31cc3c74b5' if __name__ == '__main__': async = AsyncResult(id=id, app=app) if async.successful(): result = async.get() print(result) elif async.failed(): print('任务失败') elif async.status == 'PENDING': print('任务等待中被执行') elif async.status == 'RETRY': print('任务异常后正在重试') elif async.status == 'STARTED': print('任务已经开始被执行') ","date":"2017-06-03","objectID":"/posts/celery/:5:2","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"高级使用 celery.py # 1）创建app + 任务 # 2）启动celery(app)服务： # 非windows # 命令：celery worker -A celery_task -l info # windows： # pip3 install eventlet # celery worker -A celery_task -l info -P eventlet # 3）添加任务：自动添加任务，所以要启动一个添加任务的服务 # 命令：celery beat -A celery_task -l info # 4）获取结果 from celery import Celery broker = 'redis://127.0.0.1:6379/1' backend = 'redis://127.0.0.1:6379/2' app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) # 时区 app.conf.timezone = 'Asia/Shanghai' # 是否使用UTC app.conf.enable_utc = False # 任务的定时配置 from datetime import timedelta from celery.schedules import crontab app.conf.beat_schedule = { 'low-task': { 'task': 'celery_task.tasks.low', 'schedule': timedelta(seconds=3), # 'schedule': crontab(hour=8, day_of_week=1), # 每周一早八点 'args': (300, 150), } } tasks.py from .celery import app import time @app.task def add(n, m): print(n) print(m) time.sleep(10) print('n+m的结果：%s' % (n + m)) return n + m @app.task def low(n, m): print(n) print(m) print('n-m的结果：%s' % (n - m)) return n - m get_result.py from celery_task.celery import app from celery.result import AsyncResult id = '21325a40-9d32-44b5-a701-9a31cc3c74b5' if __name__ == '__main__': async = AsyncResult(id=id, app=app) if async.successful(): result = async.get() print(result) elif async.failed(): print('任务失败') elif async.status == 'PENDING': print('任务等待中被执行') elif async.status == 'RETRY': print('任务异常后正在重试') elif async.status == 'STARTED': print('任务已经开始被执行') ","date":"2017-06-03","objectID":"/posts/celery/:5:3","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["异步"],"content":"django中使用 celery.py \"\"\" celery框架django项目工作流程 1）加载django配置环境 2）创建Celery框架对象app，配置broker和backend，得到的app就是worker 3）给worker对应的app添加可处理的任务函数，用include配置给worker的app 4）完成提供的任务的定时配置app.conf.beat_schedule 5）启动celery服务，运行worker，执行任务 6）启动beat服务，运行beat，添加任务 重点：由于采用了django的反射机制，使用celery.py所在的celery_task包必须放置项目的根目录下 \"\"\" # 一、加载django配置环境 import os os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"luffyapi.settings.dev\") # 二、加载celery配置环境 from celery import Celery # broker broker = 'redis://127.0.0.1:6379/0' # backend backend = 'redis://127.0.0.1:6379/1' # worker app = Celery(broker=broker, backend=backend, include=['celery_task.tasks']) # 时区 app.conf.timezone = 'Asia/Shanghai' # 是否使用UTC app.conf.enable_utc = False # 任务的定时配置 from datetime import timedelta from celery.schedules import crontab app.conf.beat_schedule = { 'update-banner-list': { 'task': 'celery_task.tasks.update_banner_list', 'schedule': timedelta(seconds=10), 'args': (), } } tasks.py from .celery import app from django.core.cache import cache from home import models, serializers from django.conf import settings @app.task def update_banner_list(): queryset = models.Banner.objects.filter(is_delete=False, is_show=True).order_by('-orders')[:settings.BANNER_COUNT] banner_list = serializers.BannerSerializer(queryset, many=True).data # 拿不到request对象，所以头像的连接base_url要自己组装 for banner in banner_list: banner['image'] = 'http://127.0.0.1:8000%s' % banner['image'] cache.set('banner_list', banner_list, 86400) return True ","date":"2017-06-03","objectID":"/posts/celery/:5:4","tags":["celery"],"title":"Celery","uri":"/posts/celery/"},{"categories":["Python基础"],"content":"GIL 全局解释器锁 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:0","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"什么是GIL 全局解释器锁 \"\"\" In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) \"\"\" GIL 本质就是一把互斥锁， 本质上是将并发变为串行 每个进程内都会存在一把GIl ， 同一进程内的多个线程必须要抢到GIL才行使用Cpython解释器来执行自己的代码， 即 同一进程下的多个线程无法实现并行，但是可以实现并发。 在Cpython 解释器下， 如果想实现并行可以开启多个进行 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:1","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"为什么要有GIL Python的内存管理不是线程安全的原因就是 垃圾回收机制。 因为Cpython 解释器的垃圾回收机制不是线程安全的 ","date":"2017-03-05","objectID":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/:1:2","tags":["GC"],"title":"python GIL全局解释器锁","uri":"/posts/python-23-gil-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81/"},{"categories":["Python基础"],"content":"一 isinstance(obj,cls)和issubclass(sub,super) isinstance(obj,cls)检查是否obj是否是类 cls 的对象 1 class Foo(object): 2 pass 3 4 obj = Foo() 5 6 isinstance(obj, Foo) issubclass(sub, super)检查sub类是否是 super 类的派生类 1 class Foo(object): 2 pass 3 4 class Bar(Foo): 5 pass 6 7 issubclass(Bar, Foo) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:1:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"二 反射 1 什么是反射 反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。这一概念的提出很快引发了计算机科学领域关于应用反射性的研究。它首先被程序语言的设计领域所采用,并在Lisp和面向对象方面取得了成绩。 2 python面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射） 四个可以实现自省的函数 下列方法适用于类和对象（一切皆对象，类本身也是一个对象） hasattr(object,name) def hasattr(*args, **kwargs): # real signature unknown \"\"\" Return whether the object has an attribute with the given name. This is done by calling getattr(obj, name) and catching AttributeError. \"\"\" pass getattr(object, name, default=None) def getattr(object, name, default=None): # known special case of getattr \"\"\" getattr(object, name[, default]) -\u003e value Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y. When a default argument is given, it is returned when the attribute doesn't exist; without it, an exception is raised in that case. \"\"\" pass **setattr(x, y, v) ** def setattr(x, y, v): # real signature unknown; restored from __doc__ \"\"\" Sets the named attribute on the given object to the specified value. setattr(x, 'y', v) is equivalent to ``x.y = v'' \"\"\" pass delattr(x, y) def delattr(x, y): # real signature unknown; restored from __doc__ \"\"\" Deletes the named attribute from the given object. delattr(x, 'y') is equivalent to ``del x.y'' \"\"\" pass 四个方法的使用演示 class BlackMedium: feature='Ugly' def __init__(self,name,addr): self.name=name self.addr=addr def sell_house(self): print('%s 黑中介卖房子啦,傻逼才买呢,但是谁能证明自己不傻逼' %self.name) def rent_house(self): print('%s 黑中介租房子啦,傻逼才租呢' %self.name) b1=BlackMedium('万成置地','回龙观天露园') #检测是否含有某属性 print(hasattr(b1,'name')) print(hasattr(b1,'sell_house')) #获取属性 n=getattr(b1,'name') print(n) func=getattr(b1,'rent_house') func() # getattr(b1,'aaaaaaaa') #报错 print(getattr(b1,'aaaaaaaa','不存在啊')) #设置属性 setattr(b1,'sb',True) setattr(b1,'show_name',lambda self:self.name+'sb') print(b1.__dict__) print(b1.show_name(b1)) #删除属性 delattr(b1,'addr') delattr(b1,'show_name') delattr(b1,'show_name111')#不存在,则报错 print(b1.__dict__) 四个方法的使用演示 类也是对象 class Foo(object): staticField = \"old boy\" def __init__(self): self.name = 'wupeiqi' def func(self): return 'func' @staticmethod def bar(): return 'bar' print getattr(Foo, 'staticField') print getattr(Foo, 'func') print getattr(Foo, 'bar') 反射当前模块成员 #!/usr/bin/env python # -*- coding:utf-8 -*- import sys def s1(): print 's1' def s2(): print 's2' this_module = sys.modules[__name__] hasattr(this_module, 's1') getattr(this_module, 's2') 反射当前模块成员 导入其他模块，利用反射查找该模块是否存在某个方法 module_test.py 1 #!/usr/bin/env python 2 # -*- coding:utf-8 -*- 3 4 \"\"\" 5 程序目录： 6 module_test.py 7 index.py 8 9 当前文件： 10 index.py 11 \"\"\" 12 13 import module_test as obj 14 15 #obj.test() 16 17 print(hasattr(obj,'test')) 18 19 getattr(obj,'test')() 3 为什么用反射之反射的好处 好处一：实现可插拔机制 有俩程序员，一个lili，一个是egon，lili在写程序的时候需要用到egon所写的类，但是egon去跟女朋友度蜜月去了，还没有完成他写的类，lili想到了反射，使用了反射机制lili可以继续完成自己的代码，等egon度蜜月回来后再继续完成类的定义并且去实现lili想要的功能。 总之反射的好处就是，可以事先定义好接口，接口只有在被完成后才会真正执行，这实现了即插即用，这其实是一种‘后期绑定’，什么意思？即你可以事先把主要的逻辑写好（只定义接口），然后后期再去实现接口的功能 **egon还没有实现全部功能 ** class FtpClient: \"ftp客户端, 但是没有实现具体功能\" def __init__(self,addr): pass 不影响lili的代码编写 #from module import FtpClient f1=FtpClient('192.168.1.1') if hasattr(f1,'get'): func_get=getattr(f1,'get') func_get() else: print('----\u003e不存在此方法') print('处理其他的逻辑') 不影响lili的代码编写 好处二：动态导入模块（基于反射当前模块成员） ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:2:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"三 setattr,delattr,getattr 三者的用法演示 class Foo: x=1 def __init__(self,y): self.y=y def __getattr__(self, item): print('----\u003e from getattr:你找的属性不存在') def __setattr__(self, key, value): print('----\u003e from setattr') # self.key=value #这就无限递归了,你好好想想 # self.__dict__[key]=value #应该使用它 def __delattr__(self, item): print('----\u003e from delattr') # del self.item #无限递归了 self.__dict__.pop(item) #__setattr__添加/修改属性会触发它的执行 f1=Foo(10) print(f1.__dict__) # 因为你重写了__setattr__,凡是赋值操作都会触发它的运行,你啥都没写,就是根本没赋值,除非你直接操作属性字典,否则永远无法赋值 f1.z=3 print(f1.__dict__) #__delattr__删除属性的时候会触发 f1.__dict__['a']=3#我们可以直接修改属性字典,来完成添加/修改属性的操作 del f1.a print(f1.__dict__) #__getattr__只有在使用点调用属性且属性不存在的时候才会触发 f1.xxxxxx ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:3:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"四 二次加工标准类型(包装) 包装：python为大家提供了标准数据类型，以及丰富的内置方法，其实在很多场景下我们都需要基于标准数据类型来定制我们自己的数据类型，新增/改写方法，这就用到了我们刚学的继承/派生知识（其他的标准类型均可以通过下面的方式进行二次加工） 二次加工标准类型(基于继承实现) class List(list): #继承list所有的属性，也可以派生出自己新的，比如append和mid def append(self, p_object): ' 派生自己的append：加上类型检查' if not isinstance(p_object,int): raise TypeError('must be int') super().append(p_object) @property def mid(self): '新增自己的属性' index=len(self)//2 return self[index] l=List([1,2,3,4]) print(l) l.append(5) print(l) # l.append('1111111') #报错，必须为int类型 print(l.mid) #其余的方法都继承list的 l.insert(0,-123) print(l) l.clear() print(l) 二次加工标准类型(基于继承实现) 练习（clear加权限限制） class List(list): def __init__(self,item,tag=False): super().__init__(item) self.tag=tag def append(self, p_object): if not isinstance(p_object,str): raise TypeError super().append(p_object) def clear(self): if not self.tag: raise PermissionError super().clear() l=List([1,2,3],False) print(l) print(l.tag) l.append('saf') print(l) # l.clear() #异常 l.tag=True l.clear() 练习（clear加权限限制） 授权：授权是包装的一个特性, 包装一个类型通常是对已存在的类型的一些定制,这种做法可以新建,修改或删除原有产品的功能。其它的则保持原样。授权的过程,即是所有更新的功能都是由新类的某部分来处理,但已存在的功能就授权给对象的默认属性。 实现授权的关键点就是覆盖__getattr__方法 授权示范一 import time class FileHandle: def __init__(self,filename,mode='r',encoding='utf-8'): self.file=open(filename,mode,encoding=encoding) def write(self,line): t=time.strftime('%Y-%m-%d %T') self.file.write('%s %s' %(t,line)) def __getattr__(self, item): return getattr(self.file,item) f1=FileHandle('b.txt','w+') f1.write('你好啊') f1.seek(0) print(f1.read()) f1.close() 授权示范一 授权示范二 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' #我们来加上b模式支持 import time class FileHandle: def __init__(self,filename,mode='r',encoding='utf-8'): if 'b' in mode: self.file=open(filename,mode) else: self.file=open(filename,mode,encoding=encoding) self.filename=filename self.mode=mode self.encoding=encoding def write(self,line): if 'b' in self.mode: if not isinstance(line,bytes): raise TypeError('must be bytes') self.file.write(line) def __getattr__(self, item): return getattr(self.file,item) def __str__(self): if 'b' in self.mode: res=\"\u003c_io.BufferedReader name='%s'\u003e\" %self.filename else: res=\"\u003c_io.TextIOWrapper name='%s' mode='%s' encoding='%s'\u003e\" %(self.filename,self.mode,self.encoding) return res f1=FileHandle('b.txt','wb') # f1.write('你好啊啊啊啊啊') #自定制的write,不用在进行encode转成二进制去写了,简单,大气 f1.write('你好啊'.encode('utf-8')) print(f1) f1.close() 练习题（授权） #练习一 class List: def __init__(self,seq): self.seq=seq def append(self, p_object): ' 派生自己的append加上类型检查，覆盖原有的append' if not isinstance(p_object,int): raise TypeError('must be int') self.seq.append(p_object) @property def mid(self): '新增自己的方法' index=len(self.seq)//2 return self.seq[index] def __getattr__(self, item): return getattr(self.seq,item) def __str__(self): return str(self.seq) l=List([1,2,3]) print(l) l.append(4) print(l) # l.append('3333333') #报错，必须为int类型 print(l.mid) #基于授权，获得insert方法 l.insert(0,-123) print(l) #练习二 class List: def __init__(self,seq,permission=False): self.seq=seq self.permission=permission def clear(self): if not self.permission: raise PermissionError('not allow the operation') self.seq.clear() def __getattr__(self, item): return getattr(self.seq,item) def __str__(self): return str(self.seq) l=List([1,2,3]) # l.clear() #此时没有权限，抛出异常 l.permission=True print(l) l.clear() print(l) #基于授权，获得insert方法 l.insert(0,-123) print(l) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:4:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"五 __getattribute __ 回顾__getattr__ class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print('执行的是我') # return self.__dict__[item] f1=Foo(10) print(f1.x) f1.xxxxxx #不存在的属性访问，触发__getattr__ __getattribute__ class Foo: def __init__(self,x): self.x=x def __getattribute__(self, item): print('不管是否存在,我都会执行') f1=Foo(10) f1.x f1.xxxxxx __getattribute__ 二者同时出现 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class Foo: def __init__(self,x): self.x=x def __getattr__(self, item): print('执行的是我') # return self.__dict__[item] def __getattribute__(self, item): print('不管是否存在,我都会执行') raise AttributeError('哈哈') f1=Foo(10) f1.x f1.xxxxxx #当__getattribute__与__getattr__同时存在,只会执行__getattrbute__,除非__getattribute__在执行过程中抛出异常AttributeError 二者同时出现 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:5:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"六 描述符(get,set,delete) 1 描述符是什么:描述符本质就是一个新式类,在这个新式类中,至少实现了__get__(),set(),delete()中的一个,这也被称为描述符协议 get():调用一个属性时,触发 set():为一个属性赋值时,触发 delete():采用del删除属性时,触发 定义一个描述符 class Foo: #在python3中Foo是新式类,它实现了三种方法,这个类就被称作一个描述符 def __get__(self, instance, owner): pass def __set__(self, instance, value): pass def __delete__(self, instance): pass 定义一个描述符 2 描述符是干什么的:描述符的作用是用来代理另外一个类的属性的(必须把描述符定义成这个类的类属性，不能定义到构造函数中) 引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 class Foo: def __get__(self, instance, owner): print('触发get') def __set__(self, instance, value): print('触发set') def __delete__(self, instance): print('触发delete') #包含这三个方法的新式类称为描述符,由这个类产生的实例进行属性的调用/赋值/删除,并不会触发这三个方法 f1=Foo() f1.name='egon' f1.name del f1.name #疑问:何时,何地,会触发这三个方法的执行 引子:描述符类产生的实例进行属性操作并不会触发三个方法的执行 描述符应用之何时?何地? #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') #描述符Int class Int: def __get__(self, instance, owner): print('Int调用') def __set__(self, instance, value): print('Int设置...') def __delete__(self, instance): print('Int删除...') class People: name=Str() age=Int() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #何地？：定义成另外一个类的类属性 #何时？：且看下列演示 p1=People('alex',18) #描述符Str的使用 p1.name p1.name='egon' del p1.name #描述符Int的使用 p1.age p1.age=18 del p1.age #我们来瞅瞅到底发生了什么 print(p1.__dict__) print(People.__dict__) #补充 print(type(p1) == People) #type(obj)其实是查看obj是由哪个类实例化来的 print(type(p1).__dict__ == People.__dict__) 描述符应用之何时?何地? 3 描述符分两种 一 数据描述符:至少实现了__get__()和__set__() 1 class Foo: 2 def __set__(self, instance, value): 3 print('set') 4 def __get__(self, instance, owner): 5 print('get') 二 非数据描述符:没有实现__set__() 1 class Foo: 2 def __get__(self, instance, owner): 3 print('get') 4 注意事项: 一 描述符本身应该定义成新式类,被代理的类也应该是新式类 二 必须把描述符定义成这个类的类属性，不能为定义到构造函数中 三 要严格遵循该优先级,优先级由高到底分别是 1.类属性 2.数据描述符 3.实例属性 4.非数据描述符 5.找不到的属性触发__getattr__() 类属性\u003e数据描述符 #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age #基于上面的演示,我们已经知道,在一个类中定义描述符它就是一个类属性,存在于类的属性字典中,而不是实例的属性字典 #那既然描述符被定义成了一个类属性,直接通过类名也一定可以调用吧,没错 People.name #恩,调用类属性name,本质就是在调用描述符Str,触发了__get__() People.name='egon' #那赋值呢,我去,并没有触发__set__() del People.name #赶紧试试del,我去,也没有触发__delete__() #结论:描述符对类没有作用--------\u003e傻逼到家的结论 ''' 原因:描述符在使用时被定义成另外一个类的类属性,因而类属性比二次加工的描述符伪装而来的类属性有更高的优先级 People.name #恩,调用类属性name,找不到就去找描述符伪装的类属性name,触发了__get__() People.name='egon' #那赋值呢,直接赋值了一个类属性,它拥有更高的优先级,相当于覆盖了描述符,肯定不会触发描述符的__set__() del People.name #同上 ''' 数据描述符\u003e实例属性 #描述符Str class Str: def __get__(self, instance, owner): print('Str调用') def __set__(self, instance, value): print('Str设置...') def __delete__(self, instance): print('Str删除...') class People: name=Str() def __init__(self,name,age): #name被Str类代理,age被Int类代理, self.name=name self.age=age p1=People('egon',18) #如果描述符是一个数据描述符(即有__get__又有__set__),那么p1.name的调用与赋值都是触发描述符的操作,于p1本身无关了,相当于覆盖了实例的属性 p1.name='egonnnnnn' p1.name print(p1.__dict__)#实例的属性字典中没有name,因为name是一个数据描述符,优先级高于实例属性,查看/赋值/删除都是跟描述符有关,与实例无关了 del p1.name 数据描述符\u003e实例属性 实例属性\u003e非数据描述符 class Foo: def func(self): print('我胡汉三又回来了') f1=Foo() f1.func() #调用类的方法,也可以说是调用非数据描述符 #函数是一个非数据描述符对象(一切皆对象么) print(dir(Foo.func)) print(hasattr(Foo.func,'__set__')) print(hasattr(Foo.func,'__get__')) print(hasattr(Foo.func,'__delete__')) #有人可能会问,描述符不都是类么,函数怎么算也应该是一个对象啊,怎么就是描述符了 #笨蛋哥,描述符是类没问题,描述符在应用的时候不都是实例化成一个类属性么 #函数就是一个由非描述符类实例化得到的对象 #没错，字符串也一样 f1.func='这是实例属性啊' print(f1.func) del f1.func #删掉了非数据 f1.func() 实例属性\u003e非数据描述符 再次验证：实例属性\u003e非数据描述符 class Foo: def __set__(self, instance, value): print('set') def __get__(self, instance, owner): print('get') class Room: name=Foo() def __init__(self,name,width,length): self.name=name self.width=width self.length=length #name是一个数据描述符,因为name=Foo()而Foo实现了get和set方法,因而比实例属性有更高的优先级 #对实例的属性操作,触发的都是描述符的 r1=Room('厕所',1,1) r1.n","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:6:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"六 再看property 一个静态属性property本质就是实现了get，set，delete三种方法 用法一 class Foo: @property def AAA(self): print('get的时候运行我啊') @AAA.setter def AAA(self,value): print('set的时候运行我啊') @AAA.deleter def AAA(self): print('delete的时候运行我啊') #只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter f1=Foo() f1.AAA f1.AAA='aaa' del f1.AAA 用法一 用法二 class Foo: def get_AAA(self): print('get的时候运行我啊') def set_AAA(self,value): print('set的时候运行我啊') def delete_AAA(self): print('delete的时候运行我啊') AAA=property(get_AAA,set_AAA,delete_AAA) #内置property三个参数与get,set,delete一一对应 f1=Foo() f1.AAA f1.AAA='aaa' del f1.AAA 怎么用？ 案例一 class Goods: def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price obj = Goods() obj.price # 获取商品价格 obj.price = 200 # 修改商品原价 print(obj.price) del obj.price # 删除商品原价 案例一 案例二 #实现类型检测功能 #第一关： class People: def __init__(self,name): self.name=name @property def name(self): return self.name # p1=People('alex') #property自动实现了set和get方法属于数据描述符,比实例属性优先级高,所以你这面写会触发property内置的set,抛出异常 #第二关：修订版 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------\u003e') return self.DouNiWan @name.setter def name(self,value): print('set------\u003e') self.DouNiWan=value @name.deleter def name(self): print('delete------\u003e') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 print(p1.name) print(p1.name) print(p1.name) print(p1.__dict__) p1.name='egon' print(p1.__dict__) del p1.name print(p1.__dict__) #第三关:加上类型检查 class People: def __init__(self,name): self.name=name #实例化就触发property @property def name(self): # return self.name #无限递归 print('get------\u003e') return self.DouNiWan @name.setter def name(self,value): print('set------\u003e') if not isinstance(value,str): raise TypeError('必须是字符串类型') self.DouNiWan=value @name.deleter def name(self): print('delete------\u003e') del self.DouNiWan p1=People('alex') #self.name实际是存放到self.DouNiWan里 p1.name=1 案例二 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:7:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"七 setitem,__getitem,delitem class Foo: def __init__(self,name): self.name=name def __getitem__(self, item): print(self.__dict__[item]) def __setitem__(self, key, value): self.__dict__[key]=value def __delitem__(self, key): print('del obj[key]时,我执行') self.__dict__.pop(key) def __delattr__(self, item): print('del obj.key时,我执行') self.__dict__.pop(item) f1=Foo('sb') f1['age']=18 f1['age1']=19 del f1.age1 del f1['age'] f1['name']='alex' print(f1.__dict__) ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:8:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"八 str,repr,format 改变对象的字符串显示__str__,repr 自定制格式化字符串__format__ #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' format_dict={ 'nat':'{obj.name}-{obj.addr}-{obj.type}',#学校名-学校地址-学校类型 'tna':'{obj.type}:{obj.name}:{obj.addr}',#学校类型:学校名:学校地址 'tan':'{obj.type}/{obj.addr}/{obj.name}',#学校类型/学校地址/学校名 } class School: def __init__(self,name,addr,type): self.name=name self.addr=addr self.type=type def __repr__(self): return 'School(%s,%s)' %(self.name,self.addr) def __str__(self): return '(%s,%s)' %(self.name,self.addr) def __format__(self, format_spec): # if format_spec if not format_spec or format_spec not in format_dict: format_spec='nat' fmt=format_dict[format_spec] return fmt.format(obj=self) s1=School('oldboy1','北京','私立') print('from repr: ',repr(s1)) print('from str: ',str(s1)) print(s1) ''' str函数或者print函数---\u003eobj.__str__() repr或者交互式解释器---\u003eobj.__repr__() 如果__str__没有被定义,那么就会使用__repr__来代替输出 注意:这俩方法的返回值必须是字符串,否则抛出异常 ''' print(format(s1,'nat')) print(format(s1,'tna')) print(format(s1,'tan')) print(format(s1,'asfdasdffd')) 自定义format练习 date_dic={ 'ymd':'{0.year}:{0.month}:{0.day}', 'dmy':'{0.day}/{0.month}/{0.year}', 'mdy':'{0.month}-{0.day}-{0.year}', } class Date: def __init__(self,year,month,day): self.year=year self.month=month self.day=day def __format__(self, format_spec): if not format_spec or format_spec not in date_dic: format_spec='ymd' fmt=date_dic[format_spec] return fmt.format(self) d1=Date(2016,12,29) print(format(d1)) print('{:mdy}'.format(d1)) 自定义format练习 issubclass和isinstance #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class A: pass class B(A): pass print(issubclass(B,A)) #B是A的子类,返回True a1=A() print(isinstance(a1,A)) #a1是A的实例 issubclass和isinstance ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:9:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"九 __slots__ __slots__使用 ''' 1.__slots__是什么:是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性) 2.引子:使用点来访问属性本质就是在访问类或者对象的__dict__属性字典(类的字典是共享的,而每个实例的是独立的) 3.为何使用__slots__:字典会占用大量内存,如果你有一个属性很少的类,但是有很多实例,为了节省内存可以使用__slots__取代实例的__dict__ 当你定义__slots__后,__slots__就会为实例使用一种更加紧凑的内部表示。实例通过一个很小的固定大小的数组来构建,而不是为每个实例定义一个 字典,这跟元组或列表很类似。在__slots__中列出的属性名在内部被映射到这个数组的指定小标上。使用__slots__一个不好的地方就是我们不能再给 实例添加新的属性了,只能使用在__slots__中定义的那些属性名。 4.注意事项:__slots__的很多特性都依赖于普通的基于字典的实现。另外,定义了__slots__后的类不再 支持一些普通类特性了,比如多继承。大多数情况下,你应该 只在那些经常被使用到 的用作数据结构的类上定义__slots__比如在程序中需要创建某个类的几百万个实例对象 。 关于__slots__的一个常见误区是它可以作为一个封装工具来防止用户给实例增加新的属性。尽管使用__slots__可以达到这样的目的,但是这个并不是它的初衷。 更多的是用来作为一个内存优化工具。 ''' class Foo: __slots__='x' f1=Foo() f1.x=1 f1.y=2#报错 print(f1.__slots__) #f1不再有__dict__ class Bar: __slots__=['x','y'] n=Bar() n.x,n.y=1,2 n.z=3#报错 __slots__使用 刨根问底 class Foo: __slots__=['name','age'] f1=Foo() f1.name='alex' f1.age=18 print(f1.__slots__) f2=Foo() f2.name='egon' f2.age=19 print(f2.__slots__) print(Foo.__dict__) #f1与f2都没有属性字典__dict__了,统一归__slots__管,节省内存 刨根问底 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:10:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十 __next__和__iter__实现迭代器协议 简单示范 #_*_coding:utf-8_*_ __author__ = 'Linhaifeng' class Foo: def __init__(self,x): self.x=x def __iter__(self): return self def __next__(self): n=self.x self.x+=1 return self.x f=Foo(3) for i in f: print(i) 简单示范 class Foo: def __init__(self,start,stop): self.num=start self.stop=stop def __iter__(self): return self def __next__(self): if self.num \u003e= self.stop: raise StopIteration n=self.num self.num+=1 return n f=Foo(1,5) from collections import Iterable,Iterator print(isinstance(f,Iterator)) for i in Foo(1,5): print(i) 练习：简单模拟range，加上步长 class Range: def __init__(self,n,stop,step): self.n=n self.stop=stop self.step=step def __next__(self): if self.n \u003e= self.stop: raise StopIteration x=self.n self.n+=self.step return x def __iter__(self): return self for i in Range(1,7,3): # print(i) 练习：简单模拟range，加上步长 斐波那契数列 class Fib: def __init__(self): self._a=0 self._b=1 def __iter__(self): return self def __next__(self): self._a,self._b=self._b,self._a + self._b return self._a f1=Fib() print(f1.__next__()) print(next(f1)) print(next(f1)) for i in f1: if i \u003e 100: break print('%s ' %i,end='') ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:11:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十一 __doc__ 它类的描述信息 class Foo: \"\"\"我是描述信息\"\"\" pass print(Foo.__doc__) 该属性无法被继承 class Foo: '我是描述信息' pass class Bar(Foo): pass print(Bar.__doc__) #该属性无法继承给子类 该属性无法被继承 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:12:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十二 __module__和__class__ __module__ 表示当前操作的对象在那个模块 __class__ 表示当前操作的对象的类是什么 lib/aa.py class C: def __init__(self): self.name = \"sb\" index.py from lib.aa import C obj = C() print obj._module__ # 输出 lib.aa, 即输出模块 print obj.__class__ # 输出 lib.aa.C 即输出类 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:13:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十三 __del__ 析构方法，当对象在内存中被释放时，自动触发执行。 注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__ 简单示范 class Foo: def __del__(self): print('执行我啦') f1=Foo() del f1 print('-------\u003e') #输出结果 执行我啦 -------\u003e 挖坑埋了你 class Foo: def __del__(self): print('执行我啦') f1=Foo() # del f1 print('-------\u003e') #输出结果 -------\u003e 执行我啦 #为何啊？？？ 典型的应用场景： 创建数据库类，用该类实例化出数据库链接对象，对象本身是存放于用户空间内存中，而链接则是由操作系统管理的，存放于内核空间内存中 当程序结束时，python只会回收自己的内存空间，即用户态内存，而操作系统的资源则没有被回收，这就需要我们定制__del__，在对象被删除前向操作系统发起关闭数据库链接的系统调用，回收资源 这与文件处理是一个道理： f=open('a.txt') #做了两件事，在用户空间拿到一个f变量，在操作系统内核空间打开一个文件 del f #只回收用户空间的f，操作系统的文件还处于打开状态 #所以我们应该在del f之前保证f.close()执行,即便是没有del，程序执行完毕也会自动del清理资源，于是文件操作的正确用法应该是 f=open('a.txt') 读写... f.close() 很多情况下大家都容易忽略f.close,这就用到了with上下文管理 ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:14:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"十四 __enter__和__exit__ 我们知道在操作文件对象的时候可以这么写 1 with open('a.txt') as f: 2 '代码块' 上述叫做上下文管理协议，即with语句，为了让一个对象兼容with语句，必须在这个对象的类中声明__enter__和__exit__方法 上下文管理协议 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') # return self def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') with Open('a.txt') as f: print('=====\u003e执行代码块') # print(f,f.name) 上下文管理协议 __exit__()中的三个参数分别代表异常类型，异常值和追溯信息,with语句中代码块出现异常，则with后的代码都无法执行 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) with Open('a.txt') as f: print('=====\u003e执行代码块') raise AttributeError('***着火啦,救火啊***') print('0'*100) #-------------------------------\u003e不会执行 如果__exit__()返回值为True,那么异常会被清空，就好像啥都没发生一样，with后的语句正常执行 class Open: def __init__(self,name): self.name=name def __enter__(self): print('出现with语句,对象的__enter__被触发,有返回值则赋值给as声明的变量') def __exit__(self, exc_type, exc_val, exc_tb): print('with中代码块执行完毕时执行我啊') print(exc_type) print(exc_val) print(exc_tb) return True with Open('a.txt') as f: print('=====\u003e执行代码块') raise AttributeError('***着火啦,救火啊***') print('0'*100) #-------------------------------\u003e会执行 练习：模拟Open class Open: def __init__(self,filepath,mode='r',encoding='utf-8'): self.filepath=filepath self.mode=mode self.encoding=encoding def __enter__(self): # print('enter') self.f=open(self.filepath,mode=self.mode,encoding=self.encoding) return self.f def __exit__(self, exc_type, exc_val, exc_tb): # print('exit') self.f.close() return True def __getattr__(self, item): return getattr(self.f,item) with Open('a.txt','w') as f: print(f) f.write('aaaaaa') f.wasdf #抛出异常，交给__exit__处理 练习：模拟Open 用途或者说好处： 1.使用with语句的目的就是把代码块放入with中执行，with结束后，自动完成清理工作，无须手动干预 2.在需要管理一些资源比如文件，网络连接和锁的编程环境中，可以在__exit__中定制自动释放资源的机制，你无须再去关系这个问题，这将大有用处 十五 call 对象后面加括号，触发执行。 注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()() class Foo: def __init__(self): pass def __call__(self, *args, **kwargs): print('__call__') obj = Foo() # 执行 __init__ obj() # 执行 __call__ [toc] ","date":"2017-03-02","objectID":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/:15:0","tags":["面向对象"],"title":"python 面向对象高级","uri":"/posts/python-22-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"},{"categories":["Python基础"],"content":"一 反射 在Python中，反射指的是通过字符串来操作对象的属性，涉及到四个内置函数的使用（Python中一切皆对象，类和对象都可以用下述四个方法） class Teacher: def __init__(self,full_name): self.full_name =full_name t=Teacher('Egon Lin') # hasattr(object,'name') hasattr(t,'full_name') # 按字符串'full_name'判断有无属性t.full_name # getattr(object, 'name', default=None) getattr(t,'full_name',None) # 等同于t.full_name,不存在该属性则返回默认值None # setattr(x, 'y', v) setattr(t,'age',18) # 等同于t.age=18 # delattr(x, 'y') delattr(t,'age') # 等同于del t.age 基于反射可以十分灵活地操作对象的属性，比如将用户交互的结果反射到具体的功能执行 \u003e\u003e\u003e class FtpServer: ... def serve_forever(self): ... while True: ... inp=input('input your cmd\u003e\u003e: ').strip() ... cmd,file=inp.split() ... if hasattr(self,cmd): # 根据用户输入的cmd，判断对象self有无对应的方法属性 ... func=getattr(self,cmd) # 根据字符串cmd，获取对象self对应的方法属性 ... func(file) ... def get(self,file): ... print('Downloading %s...' %file) ... def put(self,file): ... print('Uploading %s...' %file) ... \u003e\u003e\u003e server=FtpServer() \u003e\u003e\u003e server.serve_forever() input your cmd\u003e\u003e: get a.txt Downloading a.txt... input your cmd\u003e\u003e: put a.txt Uploading a.txt... ","date":"2017-03-01","objectID":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/:1:0","tags":["反射","面向对象"],"title":"python 反射及内置方法","uri":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"二 内置方法 Python的Class机制内置了很多特殊的方法来帮助使用者高度定制自己的类，这些内置方法都是以双下划线开头和结尾的，会在满足某种条件时自动触发，我们以常用的__str__和__del__为例来简单介绍它们的使用。 __str__方法会在对象被打印时自动触发，print功能打印的就是它的返回值，我们通常基于方法来定制对象的打印信息，该方法必须返回字符串类型 \u003e\u003e\u003e class People: ... def __init__(self,name,age): ... self.name=name ... self.age=age ... def __str__(self): ... return '\u003cName:%s Age:%s\u003e' %(self.name,self.age) #返回类型必须是字符串 ... \u003e\u003e\u003e p=People('lili',18) \u003e\u003e\u003e print(p) #触发p.__str__()，拿到返回值后进行打印 \u003cName:lili Age:18\u003e __del__会在对象被删除时自动触发。由于Python自带的垃圾回收机制会自动清理Python程序的资源，所以当一个对象只占用应用程序级资源时，完全没必要为对象定制__del__方法，但在产生一个对象的同时涉及到申请系统资源（比如系统打开的文件、网络连接等）的情况下，关于系统资源的回收，Python的垃圾回收机制便派不上用场了，需要我们为对象定制该方法，用来在对象被删除时自动触发回收系统资源的操作 class MySQL: def __init__(self,ip,port): self.conn=connect(ip,port) # 伪代码，发起网络连接，需要占用系统资源 def __del__(self): self.conn.close() # 关闭网络连接，回收系统资源 obj=MySQL('127.0.0.1',3306) # 在对象obj被删除时，自动触发obj.__del__() [toc] ","date":"2017-03-01","objectID":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/:2:0","tags":["反射","面向对象"],"title":"python 反射及内置方法","uri":"/posts/python-21-%E5%8F%8D%E5%B0%84%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"一 绑定方法 类中定义的函数分为两大类：绑定方法和非绑定方法 其中绑定方法又分为绑定到对象的对象方法和绑定到类的类方法。 在类中正常定义的函数默认是绑定到对象的，而为某个函数加上装饰器@classmethod后，该函数就绑定到了类。 类方法通常用来在__init__的基础上提供额外的初始化实例的方式 # 配置文件settings.py的内容 HOST='127.0.0.1' PORT=3306 # 类方法的应用 import settings class MySQL: def __init__(self,host,port): self.host=host self.port=port @classmethod def from_conf(cls): # 从配置文件中读取配置进行初始化 return cls(settings.HOST,settings.PORT) \u003e\u003e\u003e MySQL.from_conf # 绑定到类的方法 \u003cbound method MySQL.from_conf of \u003cclass ‘__main__.MySQL'\u003e\u003e \u003e\u003e\u003e conn=MySQL.from_conf() # 调用类方法，自动将类MySQL当作第一个参数传给cls 绑定到类的方法就是专门给类用的，但其实对象也可以调用，只不过自动传入的第一个参数仍然是类，也就是说这种调用是没有意义的，并且容易引起混淆，这也是Python的对象系统与其他面向对象语言对象系统的区别之一，比如Smalltalk和Ruby中，绑定到类的方法与绑定到对象的方法是严格区分开的。 ","date":"2017-02-28","objectID":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/:1:0","tags":["面向对象"],"title":"python 面向对象之 绑定方法与非绑定方法","uri":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"二 非绑定方法 为类中某个函数加上装饰器 @staticmethod 后，该函数就变成了非绑定方法，也称为静态方法。该方法不与类或对象绑定，类与对象都可以来调用它，但它就是一个普通函数而已，因而没有自动传值那么一说 import uuid class MySQL: def __init__(self,host,port): self.id=self.create_id() self.host=host self.port=port @staticmethod def create_id(): return uuid.uuid1() \u003e\u003e\u003e conn=MySQL(‘127.0.0.1',3306) \u003e\u003e\u003e print(conn.id) #100365f6-8ae0-11e7-a51e-0088653ea1ec # 类或对象来调用create_id发现都是普通函数，而非绑定到谁的方法 \u003e\u003e\u003e MySQL.create_id \u003cfunction MySQL.create_id at 0x1025c16a8\u003e \u003e\u003e\u003e conn.create_id \u003cfunction MySQL.create_id at 0x1025c16a8\u003e 总结绑定方法与非绑定方法的使用：若类中需要一个功能，该功能的实现代码中需要引用对象则将其定义成对象方法、需要引用类则将其定义成类方法、无需引用类或对象则将其定义成静态方法。 ","date":"2017-02-28","objectID":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/:2:0","tags":["面向对象"],"title":"python 面向对象之 绑定方法与非绑定方法","uri":"/posts/python-20-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E9%9D%9E%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95/"},{"categories":["Python基础"],"content":"继承的定义 继承是创建新类的一种方式, 这种方式解决了 代码冗余的问题. 在python中, 子类可以继承多个父类. 父类又称之为 “基类” 或 “超类” 在其他语言中, 子类只能继承一个父类. # 父类1 class Father1: pass # 父类2 class Father2: pass # 子类-- 单继承 class Son(Father1): pass # 子类 多继承 class Son2(Father1, Father2): pass son_obj = Son() ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:1:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"查看继承. 是调用类的__bases__ 方法查看所继承的父类. print(Son2.__bases__) # 输出结果 (\u003cclass '__main__.Father1'\u003e, \u003cclass '__main__.Father2'\u003e) 返回的结果是一个元组, 包晗父类的信息 ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:2:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"经典类与新式类. 什么是经典类, 什么是新式类? object 是python3 中所有类的几类 , 它提供给了一些常见的方法入 __str__ ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"新式类 在python中, 所有继承object的 子类都属于新式类 python3 中所有的类都属于新式类, 默认全部继承object ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"经典类 所有没有继承object类的, 都属于经典类. 经典类只有在python2 中才有, ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:3:2","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"抽象与继承 要想找到子类与父类之间的关系, 需要先进行抽象, 然后在类中找到相同的部分, 抽象成父类. 类是由对象进行抽象, 找到对象之间的相同的关系, 然后抽象成类. 父类是由类进行抽象, 找到类之间的相同关系, 然后抽象成父类 ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:4:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"继承与重用性 请先看下面例子 class OldboyStudent: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def choose_course(self): pass class OldboyTeacher(): school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex def score(self): pass 两个类中, 都有相同的代码, 这样的话, 就会代码冗余 两个类之中都有相同的部分, 那么就可以抽象出来一个父类 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyStudent: def choose_course(self): pass class OldboyTeacher(): def score(self): pass 在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时 我们不可能从头开始写一个类B，这就用到了类的继承的概念。 通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用 ==提示：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大减少了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.== ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:5:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"属性查找 重点 class Foo: def f1(self): print('Foo.f1') def f2(self): print('Foo.f2') self.f1() class Bar(Foo): def f1(self): print('Foo.f1') b=Bar() b.f2() 属性的查找 是先从对象的名称空间中查找, 然后再找子类. ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:5:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"派生 当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。 以下为例. 当老师有自己的独有属性. 例如 老师有自己的工资, 那么就可以按照下面的方式进行修改 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): self.name = name self.age = age self.sex = sex self.sal = sal def score(self): pass 但是有一个问题, 子类和父类都有很多的重复代码. 这样代码仍然很冗余. 如何解决这个问题呢? ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:0","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"解决重用的代码冗余. 方案1 重用父类的__init__的方法 class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): OldboyPeople.__init__(self, name, age, sex) self.sal = sal def score(self): pass 这种方法和调用类内的函数一样, 此时的__init__ 就是一个普通的函数, 使用的时候, 要将 self 传入. 方案2 使用super() super类是个特殊类, 调用此类可以直接指向父类的名称空间, 即, 在super().父类方法. 并且 不需要再手动传入 对象, 即self class OldboyPeople: school = \"oldboy\" def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class OldboyTeacher(): def __init__(self, name, age, sex, sal): super().__init__(name, age, sex) self.sal = sal def score(self): pass ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:1","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"菱形继承(钻石继承) python3 中, 新式类是以广度优先. python2 中, 经典类是以深度优先 [toc] ","date":"2017-02-27","objectID":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/:6:2","tags":["面向对象"],"title":"python 面向对象之 继承","uri":"/posts/python-19-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E7%BB%A7%E6%89%BF/"},{"categories":["Python基础"],"content":"组合 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"什么是组合? 在一个类中, 以另外一个类的对象作为数据属性, 称之为组合 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:1","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"组合有什么用? 组合与继承都是用来解决代码的重用性问题 继承是一种\"是\"的关系. 例如, 老师是人, 学生也是人 都有, 名字, 年龄 性别 组合是一种 “有” 的关系, ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:1:2","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"怎么用组合? 看下面代码 # 示例 class People: def __init__(self, name, age, sex): self.name = name self.age = age self.sex = sex class Teacher(People): def __init__(self, name, age, sex,): super().__init__(name, age, sex, ) self.course = [] def add_course(self, course): self.course.append(course) def show_course(self): for line in self.course: print(line.c_name, line.c_price, line.c_cycle) class Course: def __init__(self, c_name, c_price, c_cycle): self.c_name = c_name self.c_price = c_price self.c_cycle = c_cycle # 实例化处一个 python课程 python_obj = Course(\"python\", 22000, \"6 mon\") # 将python课程 关联到 老师对象中 tea1 = Teacher(\"七里塘\", 18, \"male\") tea1.add_course(python_obj) # 查看组合内对象的属性 # print(tea1.course[0].c_name) # 为了便于查看, 需要在类内定义方法. tea1.show_course() ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:2:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"封装 ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:0","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"1. 什么是封装 解释1: 封装就是将一堆属性即方法封装起来. 1: 定义类的过程就是封装, 由类产生对象,就是讲对象的属性和方法封装进对象体内. 解释2: 也有说 在类内 定义属性和方法时 使用__属性/方法名 这种方式是封装. 2: 这种方式, 遵循的是 在对象内部属性的使用是开放的, 在对象外部使用内部属性或方法是封闭的 为什么用封装? 可以通过 “对象.” 的方式 “存放/获取” 属性或方法。 对象拥有 “.” 的机制。 方便数据的存取。 如何进行封装, 在定义类的时候, 就进行了封装 \"\"\" 示例 class User: x = 10 def __init__(self): pass ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:1","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"访问限制机制: 什么是访问限制机制: 在创建类的时候, 定义类内部的 属性和方法是, 使用__ 开头, 凡是以__开头的属性/方法,都会被限制, 外部不能直接访问 ==注意: 凡是在类内部定义__开头的属性或方法，都会变形为 _类名__属性/方法。== 为什么要用 访问限制机制? 将一些隐私数据隐藏起来, 不让外部轻易获取 如何实现? # 示例1 class User: _name = \"王大\" def tell_name(self): print(self._name) obj = User() # 直接用.属性名 方法 会找不到, # print(obj.__name) \"\"\" Traceback (most recent call last): File \"D:/Python_study/Project/oldboy/day22/封装.py\", line 55, in \u003cmodule\u003e print(obj.__name) AttributeError: 'User' object has no attribute '__name' \"\"\" # 所以只能通过接口调用 # obj.tell_name() ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:2","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"什么是property property 是将类中的方法, 伪装成属性的方法. [toc] ","date":"2017-02-24","objectID":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/:3:3","tags":["面向对象"],"title":"python 面向对象之 封装","uri":"/posts/python-18-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B-%E5%B0%81%E8%A3%85/"},{"categories":["Python基础"],"content":"面向对象编程 我们以前已经学了面向过程编程思想. 那什么是面向对象编程呢? 首先我们要搞明白 什么是对象, 然后才能去了解什么是面向对象编程. ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:0:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"对象的概念 面向对象的核心是 “对象” 二字, 而对象的精髓在于 “整合”, 即 对象是 “特征与技能\"的结合体. 要了解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。 面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的数据属性和方法属性），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙交互着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取),对象是特征与技能的结合体，基于面向对象设计程序就好比在创造一个世界，你就是这个世界的上帝，存在的皆为对象，不存在的也可以创造出来，与面向过程机械式的思维方式形成鲜明对比，面向对象更加注重对现实世界的模拟，是一种“上帝式”的思维方式。 优点: 解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 缺点: 编程的复杂度远高于面向过程，不了解面向对象而立即上手基于它设计程序，极容易出现过度设计的问题。一些扩展性要求低的场景使用面向对象会徒增编程难度，比如管理linux系统的shell脚本就不适合用面向对象去设计，面向过程反而更加适合。 无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法准确地预测最终结果。于是我们经常看到对战类游戏，新增一个游戏人物，在对战的过程中极容易出现阴霸的技能，一刀砍死3个人，这种情况是无法准确预知的，只有对象之间交互才能准确地知道最终的结果。 应用场景: 需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方 面向对象的程序设计并不是全部。对于一个软件质量来说，面向对象的程序设计只是用来解决扩展性 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:1:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"类与对象 类即类别、种类，是面向对象设计最重要的概念，对象是特征与技能的结合体，而类则是一系列对象相似的特征与技能的结合体 在现实世界中：先有对象，再有类 世界上肯定是先出现各种各样的实际存在的物体，然后随着人类文明的发展，人类站在不同的角度总结出了不同的种类，如人类、动物类、植物类等概念 也就说，对象是具体的存在，而类仅仅只是一个概念，并不真实存在 在程序中：务必保证先定义类，后产生对象 这与函数的使用是类似的，先定义函数，后调用函数，类也是一样的，在程序中需要先定义类，后调用类 不一样的是，调用函数会执行函数体代码返回的是函数体执行的结果，而调用类会产生对象，返回的是对象 #在现实世界中，站在老男孩学校的角度：先有对象，再有类 对象1：李坦克 特征: 学校=oldboy 姓名=李坦克 性别=男 年龄=18 技能： 学习 吃饭 睡觉 对象2：王大炮 特征: 学校=oldboy 姓名=王大炮 性别=女 年龄=38 技能： 学习 吃饭 睡觉 对象3：牛榴弹 特征: 学校=oldboy 姓名=牛榴弹 性别=男 年龄=78 技能： 学习 吃饭 睡觉 现实中的老男孩学生类 相似的特征: 学校=oldboy 相似的技能： 学习 吃饭 睡觉 在现实世界中：先有对象，再有类 在程序中，务必保证：先定义（类），后使用（产生对象） PS: 1. 在程序中特征用变量标识，技能用函数标识 2. 因而类中最常见的无非是：变量和函数的定义 #程序中的类 class OldboyStudent: school='oldboy' def learn(self): print('is learning') def eat(self): print('is eating') def sleep(self): print('is sleeping') #注意： 1.类中可以有任意python代码，这些代码在类定义阶段便会执行 2.因而会产生新的名称空间，用来存放类的变量名与函数名，可以通过OldboyStudent.__dict__查看 3.对于经典类来说我们可以通过该字典操作类名称空间的名字（新式类有限制），但python为我们提供专门的.语法 4.点是访问属性的语法，类中定义的名字，都是类的属性 #程序中类的用法 .:专门用来访问属性，本质操作的就是__dict__ OldboyStudent.school #等于经典类的操作OldboyStudent.__dict__['school'] OldboyStudent.school='Oldboy' #等于经典类的操作OldboyStudent.__dict__['school']='Oldboy' OldboyStudent.x=1 #等于经典类的操作OldboyStudent.__dict__['x']=1 del OldboyStudent.x #等于经典类的操作OldboyStudent.__dict__.pop('x') #程序中的对象 #调用类，或称为实例化，得到对象 s1=OldboyStudent() s2=OldboyStudent() s3=OldboyStudent() #如此，s1、s2、s3都一样了，而这三者除了相似的属性之外还各种不同的属性，这就用到了__init__ #注意：该方法是在对象产生之后才会执行，只用来为对象进行初始化操作，可以有任意代码，但一定不能有返回值 class OldboyStudent: ...... def __init__(self,name,age,sex): self.name=name self.age=age self.sex=sex ...... s1=OldboyStudent('李坦克','男',18) #先调用类产生空对象s1，然后调用OldboyStudent.__init__(s1,'李坦克','男',18) s2=OldboyStudent('王大炮','女',38) s3=OldboyStudent('牛榴弹','男',78) #程序中对象的用法 #执行__init__,s1.name='牛榴弹'，很明显也会产生对象的名称空间 s2.__dict__ {'name': '王大炮', 'age': '女', 'sex': 38} s2.name #s2.__dict__['name'] s2.name='王三炮' #s2.__dict__['name']='王三炮' s2.course='python' #s2.__dict__['course']='python' del s2.course #s2.__dict__.pop('course') 在程序中：先定义类，后产生对象 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:2:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"！！！细说__init__方法！！！ #方式一、为对象初始化自己独有的特征 class People: country='China' x=1 def run(self): print('-----\u003e', self) # 实例化出三个空对象 obj1=People() obj2=People() obj3=People() # 为对象定制自己独有的特征 obj1.name='egon' obj1.age=18 obj1.sex='male' obj2.name='lxx' obj2.age=38 obj2.sex='female' obj3.name='alex' obj3.age=38 obj3.sex='female' # print(obj1.__dict__) # print(obj2.__dict__) # print(obj3.__dict__) # print(People.__dict__) #方式二、为对象初始化自己独有的特征 class People: country='China' x=1 def run(self): print('-----\u003e', self) # 实例化出三个空对象 obj1=People() obj2=People() obj3=People() # 为对象定制自己独有的特征 def chu_shi_hua(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z chu_shi_hua(obj1,'egon',18,'male') chu_shi_hua(obj2,'lxx',38,'female') chu_shi_hua(obj3,'alex',38,'female') #方式三、为对象初始化自己独有的特征 class People: country='China' x=1 def chu_shi_hua(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z def run(self): print('-----\u003e', self) obj1=People() # print(People.chu_shi_hua) People.chu_shi_hua(obj1,'egon',18,'male') obj2=People() People.chu_shi_hua(obj2,'lxx',38,'female') obj3=People() People.chu_shi_hua(obj3,'alex',38,'female') # 方式四、为对象初始化自己独有的特征 class People: country='China' x=1 def __init__(obj, x, y, z): #obj=obj1,x='egon',y=18,z='male' obj.name = x obj.age = y obj.sex = z def run(self): print('-----\u003e', self) obj1=People('egon',18,'male') #People.__init__(obj1,'egon',18,'male') obj2=People('lxx',38,'female') #People.__init__(obj2,'lxx',38,'female') obj3=People('alex',38,'female') #People.__init__(obj3,'alex',38,'female') # __init__方法 # 强调： # 1、该方法内可以有任意的python代码 # 2、一定不能有返回值 class People: country='China' x=1 def __init__(obj, name, age, sex): #obj=obj1,x='egon',y=18,z='male' # if type(name) is not str: # raise TypeError('名字必须是字符串类型') obj.name = name obj.age = age obj.sex = sex def run(self): print('-----\u003e', self) # obj1=People('egon',18,'male') obj1=People(3537,18,'male') # print(obj1.run) # obj1.run() #People.run(obj1) # print(People.run) ！！！__init__方法之为对象定制自己独有的特征 PS~~ 1. 站的角度不同，定义出的类是截然不同的，详见面向对象实战之需求分析 2. 现实中的类并不完全等于程序中的类，比如现实中的公司类，在程序中有时需要拆分成部门类，业务类…… 3. 有时为了编程需求，程序中也可能会定义现实中不存在的类，比如策略类，现实中并不存在，但是在程序中却是一个很常见的类 ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:0","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"类的特殊属性(了解即可) #python为类内置的特殊属性 类名.__name__# 类的名字(字符串) 类名.__doc__# 类的文档字符串 类名.__base__# 类的第一个父类(在讲继承时会讲) 类名.__bases__# 类所有父类构成的元组(在讲继承时会讲) 类名.__dict__# 类的字典属性 类名.__module__# 类定义所在的模块 类名.__class__# 实例对应的类(仅新式类中) ","date":"2017-02-23","objectID":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/:3:1","tags":["面向对象"],"title":"python 面向对象","uri":"/posts/python-17-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"},{"categories":["Python基础"],"content":"time 模块 time 模块是内置时间模块 time.time() 是当前时间戳 返回的是float 类型的时间 是从1970 年一月一号到现在的秒数 格式化时间输出 time.strftime() 格式化时间输出 传入格式 %Y Year with century as a decimal number. %m Month as a decimal number [01,12]. %d Day of the month as a decimal number [01,31]. %H Hour (24-hour clock) as a decimal number [00,23]. %M Minute as a decimal number [00,59]. %S Second as a decimal number [00,61]. %z Time zone offset from UTC. %a Locale's abbreviated weekday name. %A Locale's full weekday name. %b Locale's abbreviated month name. %B Locale's full month name. %c Locale's appropriate date and time representation. %I Hour (12-hour clock) as a decimal number [01,12]. %p Locale's equivalent of either AM or PM. 时间对象获取 obj = time.localtime() 获取时间对象 print(obj) # 得到结果 time.struct_time(tm_year=2019, tm_mon=11, tm_mday=17, tm_hour=21, tm_min=39, tm_sec=48, tm_wday=6, tm_yday=321, tm_isdst=0) 可以从时间对象中 获取指定的数据. 获取时间对象的格式化时间, 可以是未来/过去的时间对象 获取当前格式化时间 print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime()) # 个人感觉这是脱了裤子放屁, 多此一举 在strftime内第二个参数, 可以传入之前的时间对象, 把此过去/未来的时间对象格式化 字符串格式时间转换为时间对象 res = time.strptime('2018-12-13', '%Y:%m:%d') 这个返回值就是时间对象, 两个参数, 第一个是字符串时间格式, 第二个是格式化时间样式, 返回值是此格式化时间的对象 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"datatime 模块 # 获取当前年月日 obj_data = datetime.date.today() # 获取当前年月日,时分秒 obj_datatime = datatime.datatime() # 两者得到的都是时间对象, 可以分别取出 年, 月, 日, 时, 分, 秒 obj_datatime.weekday() 计算今天是周几 时区 # 获取当前时区的时间 datetime.datetime.now() # 获取UTC时间(格林尼治) datetime.datetime.utcnow() 日期/时间计算 # 首先获取时间对象. obj_time = datatime.timedelta(7) # 默认 是天 # 可以指定 week, mount等 # 获取日期时间 current_date = datetime.datetime.now() 日期时间 = 日期时间 +/- 时间对象 时间对象 = 日期时间 +/- 日期时间 获取七天后时间 later_time = current_time + time_obj ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"random 随机模块 random.random() 随机0-1之间的浮点数 random.randomint(n,m) n,m 之间的整数 random.choice(可迭代对象) 随机取出可迭代对象的一个元素 random.shuffle(可迭代对象), 对可迭代对象中的元素乱序 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"os 模块 和操作系统交互 # 获取当前执行文件的目录 os.path.dirname(__file__) # 路径要用常量 # 进行路径拼接 os.path.join(路径,字符串) # 判断“文件/文件夹”是否存在：若文件存在返回True，若不存在返回False os.path.exists(路径) # 判断是否是文件夹 True/False os.path.isdir(路径) # 创建文件夹 os.mkdir(路径) # 删除空文件夹 os.rmdir(路径) # 获取某个文件夹类所有文件的名字 os.listdir(路径) # 获取可迭代对象的索引即元素的对应关系, 对象有一个个的元组(索引, 元素) enumerate(可迭代对象) ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:4:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"sys 模块 # 获取当前python解释器的环境变量路径 sys.path # 将当前项目添加到环境变量中 BASE_PATH = os.path.dirname(os.path.dirname(__file__)) sys.path.append(BASE_PATH) # 获取cmd终端的命令行 python3 py文件 用户名 密码 print(sys.argv) # 返回的是列表[''] ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"hashlib 加密模块 内置很多算法, 常用的是MD5 # 首先实例化 一个对象 m = hashlib.md5() m.update(bytes 类型的字符串) res = m.hexdigest() # res 是经过加密算法得到的32位的位字符串. 可以对密码进行加盐处理 略过 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"序列化 序列化 我们把对象(变量)从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"为什么要序列化? 1：持久保存状态 需知一个软件/程序的执行就在处理一系列状态的变化，在编程语言中，‘状态’会以各种各样有结构的数据类型(也可简单的理解为变量)的形式被保存在内存中。 内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。 在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。 具体的来说，你玩使命召唤闯到了第13关，你保存游戏状态，关机走人，下次再玩，还能从上次的位置开始继续闯关。或如，虚拟机状态的挂起等。 2：跨平台数据交互 序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:1","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"json \u0026 pickle 序列化 json 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： import json dic={'name':'alvin','age':23,'sex':'male'} print(type(dic))#\u003cclass 'dict'\u003e j=json.dumps(dic) print(type(j))#\u003cclass 'str'\u003e f=open('序列化对象','w') f.write(j) #-------------------等价于json.dump(dic,f) f.close() #-----------------------------反序列化\u003cbr\u003e import json f=open('序列化对象') data=json.loads(f.read())# 等价于data=json.load(f) 注意 import json #dct=\"{'1':111}\"#json 不认单引号 #dct=str({\"1\":111})#报错,因为生成的数据还是单引号:{'one': 1} dct='{\"1\":\"111\"}' print(json.loads(dct)) #conclusion: # 无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads 注意点 import pickle dic={'name':'alvin','age':23,'sex':'male'} print(type(dic))#\u003cclass 'dict'\u003e j=pickle.dumps(dic) print(type(j))#\u003cclass 'bytes'\u003e f=open('序列化对象_pickle','wb')#注意是w是写入str,wb是写入bytes,j是'bytes' f.write(j) #-------------------等价于pickle.dump(dic,f) f.close() #-------------------------反序列化 import pickle f=open('序列化对象_pickle','rb') data=pickle.loads(f.read())# 等价于data=pickle.load(f) print(data['age']) Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:2","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"collections 模块 python默认八大数据: - 整型 - 浮点型 - 字符串 - 字典 - 元组 - 列表 - 集合 - 布尔 collections模块: 提供一些python八大数据类型 “以外的数据类型” 。 具名元组: 具名元组 只是一个名字。 应用场景: - 坐标 - ``` from collections import namedtuple``` 有序字典: python中字典默认是无序 collections中提供了有序的字典 from collections import OrderedDict 示例 # 具名元组 from collections import namedtuple # 传入可迭代对象是有序的 # 应用:坐标 # 将'坐标'变成 “对象” 的名字 point = namedtuple('坐标', ['x', 'y']) # 第二个参数既可以传可迭代对象 point = namedtuple('坐标', ('x', 'y')) # 第二个参数既可以传可迭代对象 point = namedtuple('坐标', 'x y') # 第二个参数既可以传可迭代对象 # 会将 1 ---\u003e x, 2 ---\u003e y # 传参的个数，要与namedtuple第二个参数的个数一一对应 p = point(1, 3) # 本质上传了4个，面向对象讲解 print(p) print(type(p)) ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"openpyxl 模块 openpyxl模块：第三方模块 - 可以对Excle表格进行操作的模块 - 下载: pip3 install openpyxl - Excel版本: 2003之前: excle名字.xls 2003以后: excle名字.xlsx - 清华源: https://pypi.tuna.tsinghua.edu.cn/simple - 配置永久第三方源: D:\\Python36\\Lib\\site-packages\\pip\\_internal\\models\\index.py 示例 # 写入数据 from openpyxl import Workbook # 获取Excel文件对象 wb_obj = Workbook() wb1 = wb_obj.create_sheet('python13期工作表1', 1) wb2 = wb_obj.create_sheet('python13期工作表2', 2) # 修改工作表名字: 为python13期工作表1标题修改名字 ---》 tank大宝贝 print(wb1.title) wb1.title = 'tank大宝贝' print(wb1.title) # 为第一张工作表添加值 # wb1['工作簿中的表格位置'] wb1['A10'] = 200 wb1['B10'] = 1000 wb1['C10'] = '=SUM(A10:B10)' wb2['A1'] = 100 # 生成Excel表格 wb_obj.save('python13期.xlsx') print('excel表格生成成功') 读取数据 # 读取数据 from openpyxl import load_workbook wb_obj = load_workbook('python13期.xlsx') print(wb_obj) # # wb_obj['表名'] wb1 = wb_obj['tank大宝贝'] print(wb1['A10'].value) wb1['A10'] = 20 print(wb1['A10'].value) [toc] ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:1","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"subprocess 模块 用于和系统的cmd 终端进行交互. 方法比较简单 import subprocess while True: cmd = input(\"\u003e\u003e:\").strip() # 输入终端命令字符串 res = subprocess.Popen(cmd, shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE, ) # 参数介绍. 传入命令字符串, shell = True , 打开 cmd 终端功能 stderr 接收命令错误的信息 stdout 接收命令正确的返回信息 实例化对象用stdout.read() 方法接收信息 print(res.stdout.read().decode(\"gbk\")) res.stderr.read() ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"re模块. 一：什么是正则？ 正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。 字符组: - [0-9] 可以匹配到一个0-9的字符 - [9-0]: 报错, 必须从小到大 - [a-z]: 从小写的a-z - [A-Z]: 从大写A-Z - [z-A]: 错误, 只能从小到大，根据ascii表来匹配大小。 - [A-z]: 总大写的A到小写的z。 注意: 顺序必须要按照ASCII码数值的顺序编写。 - [^...]: 表示取反的意思。 - [^ab]: 代表只去ab以外的字符。 - [^a-z]: 取a-z以外的字符。 re 模块较重要的方法: re模块三种比较重要的方法: - findall()： ----\u003e [] 可以匹配 \"所有字符\" ，拿到返回的结果，返回的结果是一个列表。 'awfwaghowiahioawhio' # a ['a', 'a', 'a', 'a'] - search()：----\u003e obj ----\u003e obj.group() 'awfwaghowiahioawhio' # a 在匹配一个字符成功后，拿到结果后结束，不往后匹配。 'a' - match()：----\u003e obj ----\u003e obj.group() 'awfwaghowiahioawhio' # a 'a' 'wfwaghowiahioawhio' # a None 从匹配字符的开头匹配,若开头不是想要的内容，则返回None。 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"爬虫四步原理 1.发送请求: requests 2.获取响应数据: 对方机器直接返回的 3.解析并提取想要的数据: re 4.保存提取后的数据: with open() ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:11:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"爬蟲三部曲: 1.发送请求 2.解析数据 3.保存数据 import requests import re import os my_path = os.path.join(os.path.dirname(__file__),\"妹子图\") if not os.path.exists(my_path): os.mkdir(my_path) # 爬虫的四大步骤 \"\"\" 1 . 发送请求, 2 . 接收返回数据 3 . 数据处理 4 . 数据保存 \"\"\" # 返回每个类所有的URL def send_request(url): response = requests.get(url) data = response.text url_data = re.findall('\u003cdiv class=\"boxa\"\u003e \u003ca href=\"//(.*?)\"', data, re.S) data_url = [] for i in url_data: data_url.append(f\"https://{i}\") return data_url def send_url(img_url): response = requests.get(img_url) if response.status_code == 200: data = response.text url_data = re.findall('\u003ca href=\"//(.*?)@!w1200\".*?data-med=', data, re.S) url_data.pop(0) return url_data def save(res, num, url): data_img = requests.get(f\"http://{url}\") with open(f'{my_path}\\{res}{num}.jpg', \"wb\")as f: f.write(data_img.content) list1 = [\"xinggan\",\"qingchun\",\"xiaohua\",\"chemo\",\"qipao\"] if __name__ == '__main__': while True: for num, s in enumerate(list1): print(num,s) res = input(\"请输入要爬取类别序号\u003e\u003e:\").strip() res1 = int(res) res2 = list1[res1] print(\"开始爬取\") url = f\"https://www.plmm.com.cn/{res2}/flow/\" url_data = send_request(url) q = 0 for i in url_data: s = send_url(i) for m in s: save(res,q, m) q +=1 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"loging 模块的使用 loging 配置模板 logging配置 \"\"\" import os import logging.config # 定义三种日志输出格式 开始 standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \\ '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字 simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s' # 定义日志输出格式 结束 # ****************注意1: log文件的目录 BASE_PATH = os.path.dirname(os.path.dirname(__file__)) logfile_dir = os.path.join(BASE_PATH, 'log_dir') # print(logfile_dir) # ****************注意2: log文件名 logfile_name = 'user.log' # 如果不存在定义的日志目录就创建一个 if not os.path.isdir(logfile_dir): os.mkdir(logfile_dir) # log文件的全路径 logfile_path = os.path.join(logfile_dir, logfile_name) # ****************注意3: log配置字典 LOGGING_DIC = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'standard': { 'format': standard_format }, 'simple': { 'format': simple_format }, }, 'filters': {}, 'handlers': { #打印到终端的日志 'console': { 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' }, # 打印到文件的日志,收集info及以上的日志 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'standard', 'filename': logfile_path, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 }, }, 'loggers': { #logging.getLogger(__name__)拿到的logger配置 '': { 'handlers': ['default', 'console'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', 'propagate': True, # 向上（更高level的logger）传递 }, }, } 注意配置 def get_logger(user_type): # 1.加载log配置字典到logging模块的配置中 logging.config.dictConfig(LOGGING_DIC) # 2.获取日志对象 logger = logging.getLogger(user_type) return logger logger = get_logger('user') logger.info('学习不要浮躁，一步一个脚印!') 以上记牢即可 ","date":"2017-02-20","objectID":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:13:0","tags":["常用模块","爬虫"],"title":"python 常用模块","uri":"/posts/python-16-%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"什么是包? 包指的是内部包含__init__.py的文件夹。 包的作用: 存放模块，包可以更好的管理模块。 一 什么是模块？ 模块是一系列功能的结合体。 相当于与模块包着一堆函数与代码。 模块本质上是一个个的.py文件。 模块的三种来源: 1.python内置的模块: (python解释器的) 比如: sys\\time\\os\\turtle 2.第三方的模块: (别人写的) 比如: requests 3.自定义的模块: (自己写的) 比如: 自己定义的demo.py文件 模块的四种表现形式: 1.使用python编写的py文件。（了解） 2.编译后的共享库DLL或者是C或者C++库。（了解） 3.包下面带有__init__.py的一组py文件。 - py_demo - init.py - demo.py - demo2.py 4.python解释器下的py文件。 - python解释器下的文件夹 - 一个个的py文件 二 为什么要使用模块？ 模块可以帮我们更好地管理功能代码，比如: 函数.. 可以将项目拆分成一个个的功能，分别存放在不同的py文件(模块)中。 三 如何创建，编写模块，并使用模块？ 鼠标右键创建py文件 在py文件编写python代码 在一个文件中，通过import关键字导入模块 import 模块名 注意: import 模块时，模块不能加.py后缀 在使用模块阶段，必须要注意，谁是执行文件，谁是被导入文件（被导入的模块） 模块在首次导入时，就已经固定好了，当前文件查找的顺序是先从内存中查找 模块在导入时发生的事情: 1.会先执行当前执行文件，并产生执行文件中的名称空间。 2.当执行到导入模块的代码时，被导入的模块会产生一个模块的名称空间。 3.会将被导入模块的名称空间加载到内存中。 给模块起别名 as import 模块 as 模块的别名 模块的导入方式 import 模块 在执行文件中直接import导入 from 包/模块 import 模块/(函数名、变量名、类名) 在执行文件中直接import导入 循环导入问题: model1.py from model2 import name name = ‘jason’ model2.py from model1 import name name = ’tank' 解决循环导入问题: 1.需要查找的名字放在导入模块的上方 2.在函数内部导入，将模块变成函数名称空间中的名字 软件开发目录规范: 注意: 每一次写项目时，都要新建一个文件夹与项目工程,必须让项目文件夹作为项目根目录。 项目的文件夹 conf: 用于存放配置文件的文件夹 core: 核心业务代码 .py interface: 接口， 接口内写获取数据前的逻辑代码，通过后才能获取数据 db: 用于存放文件数据 lib: 存放公共功能文件 log: 用于存放日志文件，日志用于记录用户的操作记录 bin: 里面存放启动文件 / - 启动文件 readme.txt: 项目说明书, 用户告诉使用者项目的操作 [toc] ","date":"2017-02-16","objectID":"/posts/python-15-%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/:0:0","tags":["包与模块"],"title":"python 包与模块","uri":"/posts/python-15-%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"},{"categories":["Python基础"],"content":"内置函数 由python提供的函数功能, 就是内置函数, 常见内置函数有以下几种. 本节示例都是和匿名函数连用 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:0:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"max 去一个可迭代对象的最大值 , 是按照 ASCII 码的先后顺序进行比较. 参数: max(可迭代对象, key= 比较对象) 示例1 l = [2, 3, 6, 8, 1, 10] res = max(l) print(res) 示例2 # 要求, 取出薪资最大的人员 dict1 = { 'tank': 1000, 'egon':/ 500, 'sean': 200, 'jason': 500 } res= max(dict1, key = lambda x:dict1[x]) print(res) ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:1:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"min 函数 略过 和max 方法相同, 取最小值. ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:2:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"sorted 方法 排序 将 可迭代对象按照升序进行排列 dict1 = { 'tank': 1000, 'egon': 500, 'sean': 200, 'jason': 500 } # 以 key 进行排序 dict2 = sorted(dict1) print(dict2) # 以 value 进行排序, 这就需要使用到匿名函数 dict2 = sorted(dict1.items(), lambda x:x[1]) # 次函数按照key 在ASCII码顺序进行排列, 返回的是keys 组成的列表 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:3:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"map 映射 参数1 函数对象 参数2 可迭代对象 示例 l = [1, 2, 3, 4] s = map(lambda x:x+2, l) print(s) # 返回值是个 \u003cmap object at 0x000001DF3C878978\u003e \u003c!--用list 取出值--\u003e print(list(s) # [3, 4, 5, 6] ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:4:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"reduce 合并 参数1 函数对象 参数2 可迭代对象 参数3 默认初始值 res = reduce(lambda x, y: x + y, range(1, 101), 0) print(res) # 5050 ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:5:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"filter 过滤 参数1 函数对象 参数2 可迭代对象 满足条件的 返回. name_list = ['egon_dsb', 'jason_dsb', 'sean_dsb', '大饼_dsb', 'tank'] filter_obj = filter(lambda name: name.endswith('_dsb'), name_list) print(filter_obj) print(list(filter_obj)) ","date":"2017-02-13","objectID":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/:6:0","tags":["内置函数"],"title":"python 内置函数","uri":"/posts/python-14-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"面向过程编程 面向过程编程是一门编程思想。 面向 过程 编程: 核心是 ‘过程’ 二字，过程 指的是一种解决问题的步骤，即先干什么再干什么 基于该编程思想编写程序，就好比在设计一条工厂流水线，一种机械式的思维方式。 优点: 将复杂的问题流程化，进而简单化 缺点: -若修改当前程序设计的某一部分，会导致他部分同时需要修改， 扩展性差。 ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:1:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"三元表达式 三元表达式: 可以将if…else…分支变成一行。 语法: 条件成立返回左边的值 if 判断条件 else 条件不成立返回右边的值 def func(x, y): res = x if x \u003ey else y return res ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:2:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"列表生成式 可以一行实现生成列表。 语法: list = [取出的每一个值、任意值 for 可迭代对象中取出的每一个值 in 可迭代对象] for的右边是循环次数，并且可以取出可迭代对象中每一个值 for的左边可以为当前列表添加值 list = [值 for 可迭代对象中取出的每一个值 in 可迭代对象] list = [值 for 可迭代对象中取出的每一个值 in 可迭代对象 if 判断] 示例 list1 = [f'1{line}' for line in range(1, 101)] print(list1) ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:3:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"生成器表达式(生成器生成式): 列表生成式: 若数据量小时采用 [line for line in range(1, 6)] —\u003e [1, 2, 3, 4, 5] 优点: 可以依赖于索引取值，取值方便 缺点: 浪费资源 生成器生成式: 若数据量过大时采用 () —\u003e 返回生成器 (line for line in range(1, 6)) —\u003e g生成器(1, 2, 3, 4, 5) 优点: 节省资源 缺点: 取值不方便 # 生成一个有1000个值的生成器 g = (line for line in range(1, 1000001)) # \u003cgenerator object \u003cgenexpr\u003e at 0x00000203262318E0\u003e print(g) # 列表生成式实现 list1 = [line for line in range(1, 1000001)] print(list1) ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:4:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"匿名函数: 无名字的函数 左边是参数， 右边是返回值 lambda : PS: 原因,因为没有名字，函数的调用 函数名 () 匿名函数需要一次性使用。 注意: 匿名函数单独使用毫无意义，它必须配合 “内置函数” 一起使用的才有意义。 有名函数: 有名字的函数 ’’' [toc] ","date":"2017-02-12","objectID":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/:5:0","tags":["三元表达式","列表生成式","匿名函数"],"title":"python 面向过程编程, 三元表达式, 列表生成式, 匿名函数","uri":"/posts/python-13-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%98%E6%88%90-%E4%B8%89%E5%85%83%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%BC%8F%E7%94%9F%E6%88%90%E5%BC%8F-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"categories":["Python基础"],"content":"生成器理论 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:0","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"1.什么是生成器？ 生成的工具。 生成器是一个 “自定义” 的迭代器， - 本质上是一个迭代器。 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:1","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"2.如何实现生成器 但凡在函数内部定义了的yield， 调用函数时，函数体代码不会执行， 会返回一个结果，该结果就是一个生成器。 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:2","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"yield: 每一次yield都会往生成器对象中添加一个值。 yield只能在函数内部定义 yield可以保存函数的暂停状态 ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:3","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"yield与return: 相同点: 返回值的个数都是无限制的。 不同点: return只能返回一次值，yield可以返回多个值 示例 自定义range def my_range(start, end=None, step=1): if end is None: end = start start = 0 while start \u003c end: yield start start += step for i in my_range(1,11,2): print(i) ","date":"2017-02-12","objectID":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/:1:4","tags":["生成器"],"title":"python 生成器","uri":"/posts/python-12-%E7%94%9F%E6%88%90%E5%99%A8/"},{"categories":["Python基础"],"content":"什么是迭代器? 迭代器就是用来迭代取值的工具. 迭代 迭代是重复反馈过程的活动, 其目的是为了逼近所需目标或结果, 每一次对过程的重复称之为一次\"迭代\", 而每一次迭代得到的结果会作为下一次迭代的初始值, 单纯的重复不是迭代. 示例1- 非迭代 msg = 1 while True: print(msg) 示例2 迭代 msg = \"w shi ni baba\" index= 0 while index \u003c len(msg): print(msg[index]) index += 1 ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:0","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"可迭代对象 通过索引取值的方法实现很简单, 那么 当遇到没有索引的 集合, 字典时, 我们该怎么办呢? 这我们就需要一种不依赖索引的取值方式, 这就需要用到迭代器. 可迭代对象定义 从语法角度讲, 内置有.iter() 方法的对象都是可迭代对象, 字符串, 列表, 元组, 字典, 集合, 打开的文件, 都是可迭代对象 l = [1, 2, 3, 4,] l.__iter__() 等等 ...... ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:1","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"迭代器对象 可迭代对象调用内置.iter() 方法后返回的对象就是迭代器对象. l = [1, 2, 3, 4,] iter_l = l.__iter__() iter_l 就是迭代器对象. 迭代器对象都有内置的.next()方法 ==对于可迭代对象, 可以用内置的 iter() 方法, 和 next()方法进行取值 == list1 = [1, 2, 3, 4] i = iter(list1) print(next(i)) print(next(i)) print(next(i)) print(next(i)) ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:2","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"优点 为序列和非序列提供了一个统一取值的方法. 惰性计算: 迭代器对象本身是一个数据流, 只有在使用时才会用__next__() 计算出下一个值, 就迭代器本身来说,同一时刻在内存中只有一个值, 因此可以存放无限大的数据流. ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:3","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"缺点 除非取尽 , 否则无法获取数据的长度. 只能取一个值, 不能回到取值开始, ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:1:4","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"for 循环原理 代码示例 list1 = [1, 2, 3, 4, 5] # list1 是可迭代对象, 所以可以用__iter__() 方法产生迭代器对象 iter_list1 = list1.__iter__() # 循环用迭代器对象的__next__()方法取值 while True: print(iter_list1.__next__()) # 输出结果 1 Traceback (most recent call last): 2 3 4 5 File \"D:/Python_study/Project/oldboy/day12/text.py\", line 8, in \u003cmodule\u003e print(iter_list1.__next__()) StopIteration # 但是当迭代器对象内的值取尽的时候, python解释器会抛出异常, 这样就需要用到异常处理 for 循环原理 异常处理 list1 = [1, 2, 3, 4, 5] # list1 是可迭代对象, 所以可以用__iter__() 方法产生迭代器对象 iter_list1 = list1.__iter__() # 循环用迭代器对象的__next__()方法取值 while True: try: print(iter_list1.__next__()) except StopIteration: break # 这就是for 循环原理 [toc] ","date":"2017-02-11","objectID":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/:2:0","tags":["迭代器"],"title":"python 迭代器","uri":"/posts/python-11-%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"categories":["Python基础"],"content":"闭包函数 什么是闭包函数呢? 闭: 封闭 包: 包裹 比如手机是闭包函数（内层函数），被手机包装盒 (外层函数) 包裹起来， 手机可以使用包装盒中的东西，内层函数可以引用外层函数的名字。 闭包函数必须在函数内部定义 闭包函数可以引用外层函数的名字. 闭包函数是 函数嵌套, 函数对象, 名称空间与作用域的 结合体 def func(y): x = 100 # inner是闭包函数 def inner(): print(x) print(y) return inner inner = func() inner() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:1:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"什么是装饰器？ 装饰: 装饰，修饰 。 器: 工具。 装饰的工具。 “开放封闭”： 装饰器必须要遵循 “开放封闭” 原则。 开放: 对函数功能的添加是开放的。 封闭: 对函数功能修改是封闭的。 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器的作用？ 在不修改被装饰对象源代码与调用方式的前提下, 添加新的功能。 装饰器的定义必须遵循 不修改被装饰对象源代码 不修改被装饰对象调用方式 为什么使用装饰器 可以解决代码冗余问题，提高代码的可扩展性。 代码示例: - 无装饰器实现运行时间统计 def download_movie(): print('开始下载电影...') # 模拟电影下载时间 3秒 time.sleep(3) # 等待3秒 print('电影下载成功...') return '小泽.mp4' start_time = time.time() # 获取当前时间戳 download_movie() end_time = time.time() # 获取当前时间戳 print(f'消耗时间: {end_time - start_time}') # 问题: 多个被装饰对象，需要写多次统计时间的代码，导致代码冗余。 - 使用函数实现 def time_record(func): start_time = time.time() # 获取当前时间戳 # 写死了,该功能只能给一个函数使用 # download_movie() func() end_time = time.time() # 获取当前时间戳 print(f'消耗时间: {end_time - start_time}') return None # 被装饰对象的调用方式 res = time_record(download_movie) print(res) # None # 问题, 更改了调用方式. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器: 初级版 def time_record(func): def inner(*args, **kwargs): # 统计开始 start_time = time.time() # 被装饰对象， 问题1: 有返回值， 问题2: 不确定参数的 个数 res = func(*args, **kwargs) # func() ---\u003e download_movie() # 当被统计的函数执行完毕后，获取当前时间 end_time = time.time() # 统计结束，打印统计时间 print(f'消耗时间: {end_time - start_time}') return res return inner download_movie = time_record(download_movie) # inner # name = 'egon' # download_movie(name) download_movie(name='egon') ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:3","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器, 终极版. 考虑被装饰对象,有参数,有返回值的情况. def time_record(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:2:4","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器语法糖, ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器使用的两种方式. 装饰器使用得时候 , 需要两步, 调用装饰器函数, 并将被装饰对象传入,将返回值用 “调用函数\"的名字赋值 调用被重新赋值后的 “名字” 代码演示 download_movie= time_record(*args, **kwargs) download_movie() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"语法糖 即在被装饰对象的上方 用@+装饰器 来进行使用装饰器 语法糖是python解释器提供的, 用来简便使用装饰器的一种方式. 注意, 使用语法糖时 , 装饰器的定义要在被装饰对象之前, 不然会报错. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:3:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器的叠加. 当一个被装饰对象, 需要多个功能时, 应该使用多个不同功能的装饰器, 而==不是在一个装饰器中添加多个功能==. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:4:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"装饰器叠加原则. 装饰时 是 从下往上 调用时 是 从上往下 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:4:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰 当我们需要判断用户的权限, 就需要获取用户的身份信息, 并传入装饰器中,进行判断, 这就需要有参装饰器. 代码示例如下. ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰器的定义 def outher(需要传入的参数) def wrapper(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner return wrapper ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:1","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"有参装饰器的调用 def outher(需要传入的参数) def wrapper(func): # 参数用于接收被装饰对象 def inner(*args, **kwargs) # 接收所有的被装饰对象的参数 # 调用前添加功能 res = func(*args, **kwargs) # 调用被装饰对象, 并接收返回值. # 调用后添加功能 return res # 返回被装饰对象的返回值 return inner # 返回inner return wrapper @outer(传入参数) def func(): pass func() ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:5:2","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"warps 的使用. 在每个函数内, 我们都是需要写注释 , 来表明此函数所实现的功能,和用法. 使用装饰器的时候, 也是需要添加注释, 表明装饰器实现的是某个功能. 当装饰器和被装饰对象同时有注释的时候, 调用被装饰对象的.doc() 方法就不能看到其注释说明. 代码示例 from functools import wraps def wrapper(func): def inner(*args, **kwargs): ''' this is the doc from inner :param args: :param kwargs: :return: ''' res = func() return res return inner @wrapper def func1(): ''' this is doc from func1 :return: ''' pass print(func1.__doc__) # 输出结果 this is the doc from inner :param args: :param kwargs: :return: 由此可见, 在使用装饰器后, 被装饰对象的注释被污染, 因此可以用, wraps 进行修复. from functools import wraps def wrapper(func): @wraps(func) def inner(*args, **kwargs): ''' this is the doc from inner :param args: :param kwargs: :return: ''' res = func() return res return inner @wrapper def func1(): ''' this is doc from func1 :return: ''' pass print(func1.__doc__) 在inner的上方使用@wraps(func) 并将被装饰函数传入wraps , 即可 ","date":"2017-02-09","objectID":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/:6:0","tags":["装饰器"],"title":"python 闭包函数及装饰器","uri":"/posts/python-10-%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0%E5%92%8C%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["Python基础"],"content":"引子 如今我们已经编写一些简单的程序, 但是随着功能的增多, 代码量随之增大. 此时如果仍然不区分把实现不同的功能的代码放到一起, 将会使得程序结构不清晰, 代码的可读性差, 和代码的冗余. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:1:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"什么是函数 函数就是具备某一功能的\"工具\" ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:2:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"为什么用函数 为了解决代码的冗余 为了使代码有更强的可读性. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:3:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数应该怎么用 函数和变量一样, 应该先定义, 后使用. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:0","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的定义方式. 函数的定义是用 def 关键字进行定义, 格式如下 def index(): pass def 表示定义函数的关键字 index 表示这个函数的名字. ()形参位置 : 冒号是必须要的. 函数下代码有四个空格缩进. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:1","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的调用方式. 函数定义后, 就可以使用, 函数的定义是,在内存中开辟内存空间, 将函数体代码放进内存空间中, 并和函数名建立映射关系. # 打印函数 def index(): pass print(index) # 输出结果 \u003cfunction index at 0x000002C1C4141EA0\u003e 输出的结果是 函数所在的内存空间地址. # 函数的调用 def index(): print(\"我运行了\") index() # 用函数名+() 就是函数的调用方式. # 输出结果 我运行了 ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:2","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的分类 无参函数 在函数定义的时候, 没有形参, 即在函数运行的时候, 也没有参数的传入, 称之为无参函数 def index(): print(\"我运行了\") 有参函数 def index(a,b): print(a,b) 空函数 为什么要用空函数? 因为在写项目的时候, 会去实现很多功能, 定义空函数就是为了先进行项目的功能分类, 让项目的架构更清晰. 然后再逐一实现对象的功能函数代码 def index(): pass ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:3","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"形参和实参 形参 在函数的定义阶段, 函数名后括号内, 填入的占位用的 变量名 称之为形参. def index(a,b): pass # a,b 就是形参 实参 在函数的调用阶段, 传入的值即为实参. def index(a,b): print(a,b) index(1,2) # 1,2 就是实参. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:4","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"函数的传参方式. 位置传参 位置参数就是, 依照前后的顺序,依次传参, 就是位置参数. def index(a,b): print(a,b) index(1,2) 这种传参方式就是位置参数. 关键字参数. 以关键字和值这种 对应的方式传参, 即为关键字参数. def index(a,b): print(a,b) index(a=1, b=2) a= 1,b=2 就是关键字参数. 默认参数 # 当一个参数的值重复传入的时候, 就可以设置默认参数, 即在 形参处 def index(name, age, gender=\"male\"): print(f\"我的名字是{name}, 年龄{age},性别{gender}\") index(\"张\", 18 ) # 输出结果 我的名字是张, 年龄18,性别male 使用默认参数时, 如果不传参,则自动传入设置的默认值. 传参的话, 覆盖掉默认值. def index(name, age, gender=\"male\"): print(f\"我的名字是{name}, 年龄{age},性别{gender}\") index(\"张\", 18 ) index(\"王\",19,\"female\") # 输出时间 我的名字是张, 年龄18,性别male 我的名字是王, 年龄19,性别female ps: 注意,当位置参数和关键字参数同时使用的时候, 位置参数要在关键字参数的前面. ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:5","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"可变长参数 *args **kwargs 当用户不知道要传入几个参数的时候, 就出现会多传参的情况, 这时 我们就需要找个万能的形参来接收用户多传来的值. # *args 用来接收多传进来的位置参数, def index(a,b,*args): print(a,b) print(*args) index(1,2,3,4,5) # 输出结果 1,2 3,4,5 # 例2 def index(a,b,*args): print(a,b) print(args) index(1,2,3,4,5) # 输出结果 1,2 (3,4,5) # 原理是, 将多传入的未知参数打包到元组中, 并赋值给args , # 所以args 只是python中官方认证的方法, 可以用任意的名称 # * 打散的功能, 可以看出上面两个立体中 args和*args的区别 # * 如果后面跟的是字典, 则返回的值是字典的所有key # **kwargs # 用来接收多传进来的关键字参数, 是以字典的方式接收, 即 关键字是字典的key 值为 value def index(a, b, *args, **kwargs): print(a, b) print(kwargs) index(1, 2, 3, 4, 5, d=13, c=\"wo\") # 输出结果 1 2 {'d': 13, 'c': 'wo'} [toc] ","date":"2017-02-08","objectID":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/:4:6","tags":["函数"],"title":"python 函数","uri":"/posts/python-09-%E5%87%BD%E6%95%B0%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9A%E4%B9%89/"},{"categories":["Python基础"],"content":"一 数字类型 int 与 float 记录数字类型的事物状态 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.1 定义 age = 18 # 定义整型 weight = 63.8 # 定义浮点型 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.2 类型转换 整型和浮点型之间可以相互转换. 整型转换成浮点型 整型转换为浮点型后,会默认精确到小数点后一位, 以0 补足 a = 18 b = float(a) print (a,type(a),b,type(b)) # 输出结果 18 \u003cclass 'int'\u003e 18.0 \u003cclass 'float'\u003e 浮点型转换为整型 a = 18.333 b = int(a) print (a,type(a),b,type(b)) # 输出结果为 18.333 \u003cclass 'float'\u003e 18 \u003cclass 'int'\u003e 转换后, 浮点数的小数部分全部舍去 , 而不是四舍五入 int() 可以转换由纯数字组成的字符串, 如果字符串中含有非纯数字则会报错 a = \"123\" a = int(a) print(a,type(a)) # 输出结果 123 \u003cclass 'int'\u003e a = \"12.3\" a = int(a) print(a,type(a)) # 输出结果 a = int(a) ValueError: invalid literal for int() with base 10: '12.3' 进制之间的转换 十进制转其他进制 # 十进制转二进制 a = bin(10) # 十进制转八进制 a = oct(10) # 十进制转十六进制 a = hex(1005) 其他进制转十进制 # 使用int() 方法, 第一个参数是字符串, 是将其他进制类型的数字当字符串传入第一个参数, 第二个参数是int类型, 指明第一个单数的进制 int(\"10101010111\",2) ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"1.3 使用 主要用来做数学运算, 无其他特殊用途. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:1:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"二 字符串 字符串就是一串描述性文字. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.1 定义 定义字符串的三种方式: a = “abc” 用双引号引起来 即可 a = ‘abc’ 用单引号 a = ‘‘‘abc’’’ 用三引号 注意: 三种方式不可混用, 当字符串中含有\"“时 , 外面的药用 ’’ 包裹, 即成对出现 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.2 类型转换 任意类型可以转换为字符串 a = 18 print(a,type(a) # 输出结果 18 \u003c class \"int\"\u003e b = str(b) print(b,type(b) # 输出结果 18 \u003c class \"str\"\u003e ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"2.3 使用 呵~ 真沙雕, 我就是个分隔符~~~~~~~~~~~~~~~ 2.3.1 优先掌握的操作 正反向取值 切片 统计长度 成员运算 移除首尾指定字符 默认移除首尾空格 切分以指定字符切分字符串, 默认是以空格 遍历, 可以遍历所有单个字符 a = \"hello word\" # 1. 正/反向索引取值 print(a[6]) print(a[-3]) # 输出结果 w o # 和列表的索引取值一样 正向取值从0开始, 反向取值为:从右向左1 开始. # 字符串只能取值, 而不能修改. # 2. 切片(顾头不顾尾,步长) print(a[0:5:2]) # 0 代表其实位置, # 5 代表结束位置 (此位置不计入切片范围) # 2 代表步长 # 输出结果 hlo # 2.1 反向切片 a[::-1] # 表示从右往左依次取值 # 输出结果为 dlrow olleh # 3 len 统计字符串长度 l = len(a) print(l,type(l)) # 输出结果 11 \u003cclass 'int'\u003e # 4 成员运算 in / not in 返回False/ True print(\"hello\" in a) # 输出结果 True print(\"python\" not in a) # 输出结果 True # 5 .strip() 移除字符串首尾指定字符, 默认为空格 s = \" help me \" print(s.strip()) # 输出结果 help me s = \"******help me******\" print(s.strip(\"*\")) # 输出结果 help me # 6 .split() 切分 括号内不指定字符, 则默认以空格切分 m = \" w shi ni dad \" print(m.split()) # 输出结果 ['w', 'shi', 'ni', 'dad'] m = \"127.0.0.1\" print(m.split(\".\")) # 输出结果 ['127', '0', '0', '1'] # 输出的结果是一个列表. # 7 可以被遍历(循环取出) q = \"我是你爸爸!\" for i in q: print(i) # 输出结果 我 是 你 爸 爸 ! 2.3.2 需要掌握的操作 strip lstrip rstrip s = \"******help me******\" print(s.strip(\"*\")) # 输出结果 help me # 左侧移除 print(s.lstrip(\"*\")) # 输出结果 help me****** # 右侧移除 print(s.rstrip(\"*\")) # 输出结果 ******help me 2 .lower() .upper() 将所有字符转换为大写, 小写 m = \"My Name Is Evgeny\" print(m.lower()) print(m.upper()) # 输出结果 my name is evgeny MY NAME IS EVGENY # 能转换的只有英文字母, 中文则不变 3 .startswith, .endswith 以什么开头, 以什么结尾 s = \"hello Evgeny\" print(s.startswith(\"h\")) print(s.endswith(\"y\")) # 输出结构 True True 4 格式化输出, 有单独的一章 ,不知道在哪儿? 点我, 点我, 亲爱哒 5 split rsplit 切分 # split 是从左往右进行切分, 可以指定切分次数 s = \"我|是你爸爸\" s = s.split(\"|\",1) print(s) # 输出结果 [\"我\",\"是你爸爸\"] # rsplit 是从左往右进行切分, 可以指定切分次数 s = \"我|是|你爸爸\" s = s.rsplit(\"|\",1) print(s) # 输出结果 ['我|是', '你爸爸'] 6 join 在可迭代对象后加入多个字符 print(\"!\".join(\"hello\")) # 输出结果 h!e!l!l!o 7.replace 替换指定字符 # 用新的字符替换字符串中旧的字符 st = 'my name is Evgeny, my age is 18!' # 将Evgeny的年龄由18岁改成20岁 st = st.replace('18', '73') # 语法:replace('旧内容', '新内容') print(st) # 输出结果 my name is Evgeny, my age is 20! # 可以指定修改的个数 st = 'my name is Evgeny, my age is 18!' st = str7.replace('my', 'MY',1) # 只把一个my改为MY print(st) 'MY name is Evgeny, my age is 18!' .isdigit 判断是否是纯数字 # 判断字符串是否是纯数字组成，返回结果为True或False str1 = '1990' print(str1.isdigit()) True str2 = '123.123' print(str8.isdigit()) False # .isdigit 不能判断浮点数 2.3.3 了解操作 # 1.find,rfind,index,rindex,count # 1.1 find：从指定范围内查找子字符串的起始索引，找得到则返回数字1，找不到则返回-1 msg='tony say hello' msg.find('o',1,3) # 在索引为1和2(顾头不顾尾)的字符中查找字符o的索引 输出结果 1 # 1.2 index:同find,但在找不到时会报错 msg.index('e',2,4) # 报错ValueError # 1.3 rfind与rindex：略 1.4 count:统计字符串在大字符串中出现的次数 \u003e\u003e\u003e msg = \"hello everyone\" \u003e\u003e\u003e msg.count('e') # 统计字符串e出现的次数 4 \u003e\u003e\u003e msg.count('e',1,6) # 字符串e在索引1~5范围内出现的次数 1 # 2.center,ljust,rjust,zfill \u003e\u003e\u003e name='tony' \u003e\u003e\u003e name.center(30,'-') # 总宽度为30，字符串居中显示，不够用-填充 -------------tony------------- \u003e\u003e\u003e name.ljust(30,'*') # 总宽度为30，字符串左对齐显示，不够用*填充 tony************************** \u003e\u003e\u003e name.rjust(30,'*') # 总宽度为30，字符串右对齐显示，不够用*填充 **************************tony \u003e\u003e\u003e name.zfill(50) # 总宽度为50，字符串右对齐显示，不够用0填充 0000000000000000000000000000000000000000000000tony # 3.expandtabs \u003e\u003e\u003e name = 'tony\\thello' # \\t表示制表符(tab键) \u003e\u003e\u003e name tony hello \u003e\u003e\u003e name.expandtabs(1) # 修改\\t制表符代表的空格数 tony hello # 4.captalize,swapcase,title # 4.1 captalize：首字母大写 \u003e\u003e\u003e message = 'hello everyone nice to meet you!' \u003e\u003e\u003e message.capitalize() Hello everyone nice to meet you! # 4.2 swapcase：大小写翻转 \u003e\u003e\u003e message1 = 'Hi girl, I want make friends with you!' \u003e\u003e\u003e message1.swapcase() hI GIRL, i WANT MAKE FRIENDS WITH YOU! #4.3 title：每个单词的首字母大写 \u003e\u003e\u003e msg = 'dear my friend i miss you very much' \u003e\u003e\u003e msg.title() Dear My Friend I Miss You Very Much # 5.is数字系列 #在python3中 num1 = b'4' #bytes num2 = u'4' #unicode,python3中无需加u就是unicode num3 = '四' #中文数字 num4 = 'Ⅳ' #罗马数字 #isdigt:bytes,unicode \u003e\u003e\u003e num1.isdigit() True \u003e\u003e\u003e num2.isdigit() True \u003e\u003e\u003e num3.isdigit() False \u003e\u003e\u003e num4.isdigit() False #isdecimal:uncicode(bytes类型无isdecimal方法) \u003e\u003e\u003e num2.isdecimal() True \u003e\u003e\u003e num3.isdecimal() False \u003e\u003e\u003e num4.isdecimal() False #isnumberic:unicode,中文数字,罗马数字(bytes类型无isnumberic方法) \u003e\u003e\u003e num2.isnumeric() True \u003e\u003e\u003e num3.isnumeric() Tru","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:2:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"三 列表 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.1 定义 # 定义：在[]内,用逗号分隔开多个任意数据类型的值 l1 = [1,'a',[1,2]] # 本质:l1 = list([1,'a',[1,2]]) ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.2 类型转换 # 但凡能被for循环遍历的数据类型都可以传给list()转换成列表类型，list()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到列表中 \u003e\u003e\u003e list('wdad') # 结果：['w', 'd', 'a', 'd'] \u003e\u003e\u003e list([1,2,3]) # 结果：[1, 2, 3] \u003e\u003e\u003e list({\"name\":\"jason\",\"age\":18}) #结果：['name', 'age'] \u003e\u003e\u003e list((1,2,3)) # 结果：[1, 2, 3] \u003e\u003e\u003e list({1,2,3,4}) # 结果：[1, 2, 3, 4] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"3.3 使用 3.3.1 优先掌握的操作 # 1.按索引存取值(正向存取+反向存取)：即可存也可以取 # 1.1 正向取(从左往右) \u003e\u003e\u003e my_friends=['tony','jason','tom',4,5] \u003e\u003e\u003e my_friends[0] tony # 1.2 反向取(负号表示从右往左) \u003e\u003e\u003e my_friends[-1] 5 # 1.3 对于list来说，既可以按照索引取值，又可以按照索引修改指定位置的值，但如果索引不存在则报错 \u003e\u003e\u003e my_friends = ['tony','jack','jason',4,5] \u003e\u003e\u003e my_friends[1] = 'martthow' \u003e\u003e\u003e my_friends ['tony', 'martthow', 'jason', 4, 5] # 2.切片(顾头不顾尾，步长) # 2.1 顾头不顾尾：取出索引为0到3的元素 \u003e\u003e\u003e my_friends[0:4] ['tony', 'jason', 'tom', 4] # 2.2 步长：0:4:2,第三个参数2代表步长，会从0开始，每次累加一个2即可，所以会取出索引0、2的元素 \u003e\u003e\u003e my_friends[0:4:2] ['tony', 'tom'] # 3.长度 \u003e\u003e\u003e len(my_friends) 5 # 4.成员运算in和not in \u003e\u003e\u003e 'tony' in my_friends True \u003e\u003e\u003e 'xxx' not in my_friends True # 5.添加 # 5.1 append()列表尾部追加元素 \u003e\u003e\u003e l1 = ['a','b','c'] \u003e\u003e\u003e l1.append('d') \u003e\u003e\u003e l1 ['a', 'b', 'c', 'd'] # 5.2 extend()一次性在列表尾部添加多个元素 \u003e\u003e\u003e l1.extend(['a','b','c']) \u003e\u003e\u003e l1 ['a', 'b', 'c', 'd', 'a', 'b', 'c'] # 5.3 insert()在指定位置插入元素 \u003e\u003e\u003e l1.insert(0,\"first\") # 0表示按索引位置插值 \u003e\u003e\u003e l1 ['first', 'a', 'b', 'c', 'alisa', 'a', 'b', 'c'] # 6.删除 # 6.1 del \u003e\u003e\u003e l = [11,22,33,44] \u003e\u003e\u003e del l[2] # 删除索引为2的元素 \u003e\u003e\u003e l [11,22,44] # 6.2 pop()默认删除列表最后一个元素，并将删除的值返回， # 括号内可以通过加索引值来指定删除元素 \u003e\u003e\u003e l = [11,22,33,22,44] \u003e\u003e\u003e res=l.pop() \u003e\u003e\u003e res 44 \u003e\u003e\u003e res=l.pop(1) \u003e\u003e\u003e res 22 # 6.3 remove()括号内指名道姓表示要删除哪个元素，没有返回值 \u003e\u003e\u003e l = [11,22,33,22,44] \u003e\u003e\u003e res=l.remove(22) # 从左往右查找第一个括号内需要删除的元素 \u003e\u003e\u003e print(res) None # 7.reverse()颠倒列表内元素顺序 \u003e\u003e\u003e l = [11,22,33,44] \u003e\u003e\u003e l.reverse() \u003e\u003e\u003e l [44,33,22,11] # 8.sort()给列表内所有元素排序 # 8.1 排序时列表元素之间必须是相同数据类型，不可混搭，否则报错 \u003e\u003e\u003e l = [11,22,3,42,7,55] \u003e\u003e\u003e l.sort() \u003e\u003e\u003e l [3, 7, 11, 22, 42, 55] # 默认从小到大排序 \u003e\u003e\u003e l = [11,22,3,42,7,55] \u003e\u003e\u003e l.sort(reverse=True) # reverse用来指定是否跌倒排序，默认为False \u003e\u003e\u003e l [55, 42, 22, 11, 7, 3] # 8.2 了解知识： # 我们常用的数字类型直接比较大小，但其实，字符串、列表等都可以比较大小， # 原理相同：都是依次比较对应位置的元素的大小，如果分出大小，则无需比较下一个元素，比如 \u003e\u003e\u003e l1=[1,2,3] \u003e\u003e\u003e l2=[2,] \u003e\u003e\u003e l2 \u003e l1 True # 字符之间的大小取决于它们在ASCII表中的先后顺序，越往后越大 \u003e\u003e\u003e s1='abc' \u003e\u003e\u003e s2='az' \u003e\u003e\u003e s2 \u003e s1 # s1与s2的第一个字符没有分出胜负，但第二个字符'z'\u003e'b',所以s2\u003es1成立 True # 所以我们也可以对下面这个列表排序 \u003e\u003e\u003e l = ['A','z','adjk','hello','hea'] \u003e\u003e\u003e l.sort() \u003e\u003e\u003e l ['A', 'adjk', 'hea', 'hello','z'] # 9.循环 # 循环遍历my_friends列表里面的值 for line in my_friends: print(line) 'tony' 'jack' 'jason' 4 5 3.3.2 了解操作 \u003e\u003e\u003e l=[1,2,3,4,5,6] \u003e\u003e\u003e l[0:3:1] [1, 2, 3] # 正向步长 \u003e\u003e\u003e l[2::-1] [3, 2, 1] # 反向步长 # 通过索引取值实现列表翻转 \u003e\u003e\u003e l[::-1] [6, 5, 4, 3, 2, 1] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:3:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"四 元祖 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.1 作用 元组与列表类似，也是可以存多个任意类型的元素，不同之处在于元组的元素不能修改，即元组相当于不可变的列表，用于记录多个固定不允许修改的值，单纯用于取 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.2 定义方式 # 在()内用逗号分隔开多个任意类型的值 \u003e\u003e\u003e countries = (\"中国\"，\"美国\"，\"英国\") # 本质:countries = tuple(\"中国\"，\"美国\"，\"英国\") # 强调：如果元组内只有一个值，则必须加一个逗号，否则()就只是包含的意思而非定义元组 \u003e\u003e\u003e countries = (\"中国\"，) # 本质:countries = tuple(\"中国\") ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.3 类型转换 # 但凡能被for循环的遍历的数据类型都可以传给tuple()转换成元组类型 \u003e\u003e\u003e tuple('wdad') # 结果：('w', 'd', 'a', 'd') \u003e\u003e\u003e tuple([1,2,3]) # 结果：(1, 2, 3) \u003e\u003e\u003e tuple({\"name\":\"jason\",\"age\":18}) # 结果：('name', 'age') \u003e\u003e\u003e tuple((1,2,3)) # 结果：(1, 2, 3) \u003e\u003e\u003e tuple({1,2,3,4}) # 结果：(1, 2, 3, 4) # tuple()会跟for循环一样遍历出数据类型中包含的每一个元素然后放到元组中 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"4.4 使用 \u003e\u003e\u003e tuple1 = (1, 'hhaha', 15000.00, 11, 22, 33) # 1、按索引取值(正向取+反向取)：只能取，不能改否则报错！ \u003e\u003e\u003e tuple1[0] 1 \u003e\u003e\u003e tuple1[-2] 22 \u003e\u003e\u003e tuple1[0] = 'hehe' # 报错：TypeError: # 2、切片(顾头不顾尾，步长) \u003e\u003e\u003e tuple1[0:6:2] (1, 15000.0, 22) # 3、长度 \u003e\u003e\u003e len(tuple1) 6 # 4、成员运算 in 和 not in \u003e\u003e\u003e 'hhaha' in tuple1 True \u003e\u003e\u003e 'hhaha' not in tuple1 False # 5、循环 \u003e\u003e\u003e for line in tuple1: ... print(line) 1 hhaha 15000.0 11 22 33 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:4:4","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"五 字典 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"定义方式 第一种方式 用花括号, 将key:value 这样的键值对放入, 并以逗号隔开. d1 = {“name”:“zhang”, “age”:18} 第二种方式 使用dict方法, d1 = dict(name=“zhang”, age =18 ) 第三种方法, zip 拉链函数. # zip 有两个参数 第一个和第二个参数都为可迭代对象, 工作方式, # 第一个参数取一个值, 第二个取一个, 组成一个元组, 返回一个可迭代对象 l1 = [1,2,3,4,5] l2 = [\"a\",\"b\",\"c\"] l3 = zip(l1,l2) for i in l3: print(i) # 输出结果 (1, 'a') (2, 'b') (3, 'c') 生成字典的方法 l1 = [1,2,3,4,5] l2 = [\"a\",\"b\",\"c\"] l3 = zip(l1,l2) d1 = dict(l3) print(d1) # 输出结果 {1: 'a', 2: 'b', 3: 'c'} ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"类型转换 定义方式已有提起 {}.fromkeys(可迭代对象,值) # 使用fromkeys创建一个字典, # 第一个参数, 可迭代对象, 必须所有元素为不可变类型. # 创建的字典, 是以可迭代对象的每一个元素作为新字典的 key, 然后分别与同一个值配对. 完成创建 # 结果是, 整个字典的value是第二个参数 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"使用 5.3.1 优先掌握的操作 操作无外乎 增删改查 增 d1 = {\"a\":1,\"b\":2} # 1. update 更新, 传递的参数是一个字典, 如果有, 则更新最新value, 如果没有, 则添加. d1 = {\"a\":1,\"b\":2} d1.update({\"b\":3}) print(d1) # 输出结果 {'a': 1, 'b': 3} update 只能更新一组数据. so # 2. [] 方法 d1 = {\"a\":1,\"b\":2} d1[\"c\"] = 3 print(d1) # 输出结果 {'a': 1, 'b': 2, 'c': 3} # 3 setdefault() 两个参数, 在元组里包起来. 第一个是key 第二个是value 当 有key 存在的时候, 返回原来所对应的值, 当key 不存在 添加, 并返回最新的value 值. 删 # del 方法 万能删除. pass # pop 参数: key , 传入key 删除 对应键值对 . 并返回 对应的value值 d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.pop(\"a\") print(d2,s) # 输出结果 {'b': 2, 'c': 3} 1 # popitem 无需传入参数, 随机删除一个键值对, 并返回由删除的key,value 组成的元组. d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.popitem() print(d2,s) # 输出结果 {'a': 1, 'b': 2} ('c', 3) 改 新增的时候, 已说, 查 # 1 用.keys 查找字典所有key d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.keys()) # 打印结果 dict_keys(['a', 'b', 'c']) # 2 用 .values 查找字典所有的value d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.values()) # 返回结果 dict_values([1, 2, 3]) # 3 用 items 查找字典所有的 key 和对应的value d2 = {'a': 1, 'b': 2, 'c': 3} print(d2.items()) # 返回结果 dict_items([('a', 1), ('b', 2), ('c', 3)]) # 4 get 方法, 传入key 查找对应的value . 如果没有key 则返回 None d2 = {'a': 1, 'b': 2, 'c': 3} s = d2.get(\"d\") print(s) # 返回结果 None 5.3.2 需要掌握的操作 以上大部分都需要掌握 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:5:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"六 集合 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:0","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.1 作用 主要用于 查重, 和 成员运算 ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:1","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.2 定义 set 是以花括号包裹,单个元素以逗号隔开的数据类型. 特点: 每个元素必须是不可变类型 集合内没有重复元素 集合内元素无序 s1 = {1,2,3} 定义空集合 因为 集合和字典都是以{}包裹, 所以 定义空集合必须需要set 方法. s1 = set() ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:2","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.3 类型转换 只要是能被for 循环遍历的 是非可变类型的元素, 都能传入set 进行查重. ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:3","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"6.4 使用 6.4.1 关系运算 | 并集, 求两个集合中所有的元素, 重复只留一个 \u0026 交集, 求两个集合中相交的部分. “-” 差集, 前一个集合中与后一个集合不相交的部分. ^ 对称差集, 两个集合中取出相交的元素. 6.4.2 去重 去重有局限性, 只能对只有不可变元素的容器进行去重 去重后集合内元素是无序的. [toc] ","date":"2017-02-06","objectID":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/:6:4","tags":["数据类型"],"title":"python 数据类型及内置方法详解","uri":"/posts/python-08-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"categories":["Python基础"],"content":"引入 当我们的cpython(C语言编写的python 解释器) 执行到定义变量的语法时, 会向系统申请内存空间来存储变量, 而 内存的容量是有限的, 那么这就牵扯到一个内存空间的回收问题. 当一个变量不再被使用, 就需要把这个变量所占用的内存空间回收. 由于变量名是访问变量值的唯一方式, 所以当一个变量值不再关联任何的变量名时, 我们就无法再访问到该变量值, 此时该变量值就是垃圾, cpython 为我们 提供了自动的垃圾回收机制来帮我们解决垃圾回收的问题 ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:1","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"垃圾回收机制 垃圾回收机制 (简称GC) 是python 解释器自带的一种机制, 是专门用来回收不可以的变量值所占用的内存空间 ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:2","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"为什么要用垃圾回收机制 程序运行中需要申请大量的内存空间, 而对于一些无用的内存空间如果不及时清除, 会导致内存耗尽,程序崩溃, 电脑(服务器) 宕机等, 引发严重问题. 因此管理内存是一件重要且繁杂的事情. ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:3","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"垃圾回收机制原理 Python 的 GC 模块主要运用了\"引用计数\"(referrence counting) 来跟踪和回收垃圾, 在引用计数基础上, 还可以通过\"标记-清除\" ( mark and sweep ) 解决容器对象可能产生的循环引用问题, 并且通过\"分代回收\"(generation collection) 以空间换取时间的方式来进一步提高垃圾回收效率 什么是引用计数 引用计数就是: 变量值被变量名关联的次数 如: age = 23 变量值 23 被 变量名 age 关联, 此时的 引用计数为1 引用计数增加 age = 23 ( 此时23 的引用计数次数为1 ) m = age ( 把 age的内存地址给了 m, 此时,. m,age 都关联23 , 所以变量值23的引用计数为2) 引用计数的减少: age = 18 ( 名字 age 先与23 解除关联, 再与18 简历关联, 此时 变量值得引用计数为1) ","date":"2017-02-04","objectID":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/:0:4","tags":["GC"],"title":"python 垃圾回收机制","uri":"/posts/python-07-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"},{"categories":["Python基础"],"content":"流程控制 流程控制即 控制流程, 具体指控制程序的执行流程, 而程序的流程分为三种, 顺序结构(以前写的代码都是顺序结构) 分支结构(if 判断) 循环结构(while 和 for 循环) ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:1:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"分支结构 ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"什么是分支结构 分支结构就是根据条件判断的真假去执行不同的代码块. ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:1","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"为什么要用分支结构 人类某些时候要根据条件决定做什么事情, 比如, 今天下雨, 带伞. 是最基本的逻辑判断. ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:2","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"如何使用分支结构 if 语法 用if关键字实现分支结构. if 条件1: 代码块1 ...... elif 条件2: 代码块2 ...... elif 条件3: 代码块3 ...... else: 代码块4. # 如果以上条件符合, 则执行下面相应的代码.以上代码块能且只能执行一块. # 1. python 用相同的缩进(四个空格表示一个缩进) 来标识一组代码. 同一组代码块 # 2.条件可以是任意表达式, 但执行结果必须为bool类型 # 在if 判断中的所有的数据类型都会转换为布尔类型 # None, 0 ,[],\"\",{} , 换算成bool值都为False , 非空即真 if 应用案例 # 案例1 # 如果: 女人年龄\u003e3岁, 那么叫阿姨 age = input(\"输入年龄\u003e\u003e:\") if age \u003e30: print(\"叫阿姨!\"\") # 案例2 # 如果 年龄\u003e30 叫阿姨, 否则叫姐姐 age = input(\"输入年龄\u003e\u003e:\") if age \u003e30: print(\"叫阿姨!\"\") else: print(\"叫姐姐1\") # 案例3 # 如果女人年龄\u003e= 18 并且\u003c= 22 岁 并且身高\u003e170 体重\u003c100 并且是漂亮的. 那么表白. 否则. 阿姨好 age = input(\"输入年龄\u003e\u003e:\") height = input(\"目测身高\u003e\u003e:\") is_beauty = True weight = input(\"目测体重\u003e\u003e:\") if 18\u003c= age \u003c= 22 and height \u003e170 and weight \u003c 100 and is_beauty: print(\"表白\") else: print(\"叫阿姨\") 练习登录 username_from_db = \"zhang\" password_from_db = 123 count = 0 tag = True while tag: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while tag: cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": tag = False else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") tag = False ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:2:3","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"循环结构 ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:0","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"while 循环语法 python中 有while 与for 两中循环机制, 其中while 称之为条件循环. while 条件: 代码1 代码2 ...... # while 的运行步骤, # 步骤1 : 如果条件成立,则依次执行代码1,代码2 ... # 步骤2: 执行完毕后, 再次判断条件,如果条件仍然成立,则再次执行代码1,代码2,代码3 案例1 用户认证 username_from_db = \"zhang\" password_from_db = 123 count = 0 while count \u003c3: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") else: print(\"用户名或密码错误,请重新收入\") count +=1 案例二 while + break 的使用 使用while 循环后, 当登录成功, 则需要后续操作, 需要结束本层循环 , 那么就需要break. break 结束本层循环. 结束后 循环内代码都不执行. username_from_db = \"zhang\" password_from_db = 123 # 记录验证错误次数 count = 0 while count \u003c3: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") break # 用于结束本层循环 else: print(\"用户名或密码错误,请重新收入\") count +=1 案例三, while 循环嵌套+ break 如果while 循环嵌套了很多层, 想要退出每层循环,则需要在每层都有一个break username_from_db = \"zhang\" password_from_db = 123 count = 0 while True: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while True: # 第二层循环 cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": break # 退出第二层循环 else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") break # 退出第一场循环 案例四, while 循环嵌套, + tag 的使用 针对嵌套多层的while循环, 如果当满足某个条件就退出所有循环, 就可以使用tag , 即 将tag 初始值为 True , 当满足某个条件后 tag 更改为False , 就会退出所有层循环 username_from_db = \"zhang\" password_from_db = 123 count = 0 tag = True while tag: username = input(\"please input your username\u003e\u003e:\").strip() password = input(\"please input your password\u003e\u003e:\").strip() if username == username_from_db and password == password_from_db: print(\"登录成功\") while tag: cmd = input(\"\u003e\u003e:\") if cmd == \"exit\": tag = False else: print(f\"调用{cmd}功能\") else: print(\"用户名或密码错误,请重新收入\") count += 1 if count == 3: print(\"输错超过三次, 账号已锁定\") tag = False 案例五 while + continue 的使用. break 代表结束本层循环, continue 代表结束本次循环, 进入下一次循环 num = 10 while num \u003e1: num -=1 if num ==6: continue # 结束到本次循环, 后面的代码则不会再运行, 直接进入下一次循环. print(num) # 结果 6 则不打印, 案例六, while 与 else 的使用 . 当循环正常结束后, 执行else 后语句, 用来验证 循环是否正常结束. count = 0 while count \u003c5: count +=1 print(f\"这是第{count}次循环\") else: print(\"循环正常结束\") print(\"*\"*50) # 输出 这是第1次循环 这是第2次循环 这是第3次循环 这是第4次循环 这是第5次循环 循环正常结束 ************************************************** 如果执行过程中用break , 则不会执行else语句. count = 0 while count \u003c5: count +=1 if count ==3: break print(f\"这是第{count}次循环\") else: print(\"循环正常结束\") print(\"*\"*50) # 输出结果 这是第1次循环 这是第2次循环 ************************************************** ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:1","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"for 循环语法. 循环结构的第二种实现方法是 for 循环, for 循环可以做的事情 while循环都可以实现,之所以使用for 是因为, for循环在遍历取值时, 更为简洁. for 循环语法如下 for 变量名 in 可迭代对象: # 可迭代对象为, 字典,列表, 字符串, 等.. 代码1 代码2 # 例子 for i in [1,2,3,4]: print(i) # 输出结果 1 2 3 4 # 循环是, 将列表[1,2,3,4] 中的值分别取出并赋值给i 然后打印i 直到列表值取完. 案例1 , 打印数字1-5 # for 版本 for count in range(6): print(count) # while 版本 count = 0 while count\u003c6: print(count) count +=1 # range 有三个参数, start = 其实数字 end = 结束数字. sep =步长 # range 顾头不顾尾. 遍历字典, 得到的是字典中的key 而不是 值. for k in {\"name\":\"Evgeny\", \"age\":18} print(k) # 输出结果 name age 案例 三, for 循环嵌套. # 使用for 循环嵌套的方式打印以下图形 **** **** **** for i in range(3): for j in range(4): print(\"*\", end = \"\") print() # 表示换行 注意: break 与continue 也可以用于for循环, 使用发放与while循环相同. [toc] ","date":"2017-02-04","objectID":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/:3:2","tags":["流程控制"],"title":"python 流程控制","uri":"/posts/python-06-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"categories":["Python基础"],"content":"数据类型 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"一. 什么是数据类型? 数据类型就是用来描述事物某个特征最恰当的方式, 例如: 用整数描述年龄 用浮点数描述小数 用字符串(文字类型)描述一些事物的信息. 等等等等 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"二. 类型有哪些? 怎么用? ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"2.1. 整型: int 类型 作用:记录 年龄,电话号, QQ号, 等数字 定义 age = 18 # age = int(18) print(age,type(age) # 输出结果 18 \u003cclass 'int'\u003e 定义int 类型, 是由int()这个功能函数实现的 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:1","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"2.2浮点数:float 类型 作用:记录工资,体重,身高等非整数类型数据 定义 height = 1.81 # height = float(1.81) print(height,type(height)) # 输出结果 1.81 \u003cclass 'float'\u003e 定义 int 类型,是由float()这个函数来实现的. 数字类型之间的运算 整型和浮点数 做数字运算, python 会自动将整型转换为浮点数类型. a = 10 b = 1.5 c = a*b print(c,type(c)) # 输出结果为 15.0 \u003cclass 'float'\u003e ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:2","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"字符串:str 类型 作用: 用来记录一段描述信息. 例如: 公司简介, 名称等信息 定义 可以用’ ‘,\" “,’’’ ‘‘‘定义一个字符串 name = \"Evgeny\" name1 = 'Evgeny' info = ''' company: 俄讯通文化有限公司 成立时间: 2017年 ''' print(name,type(name), name1,type(name1), info,type(info)) # 输出结果 Evgeny \u003cclass 'str'\u003e Evgeny \u003cclass 'str'\u003e company: 俄讯通文化有限公司 成立时间: 2017年 \u003cclass 'str'\u003e 区别: ’’ 和 \"” 本质上没有区别, 当同时用到的时候, 需要进行区分, 例如 print(\"my name is \"Evgeny\"\") # 输出结果 print(\"my name is \"Evgeny\"\") ^ SyntaxError: invalid syntax 这样就会报错 因为 python 解释器无法识别 哪两个\"\" 是一组. 所以会报错, 正确用法是 print(\"my name is 'Evgeny'\") ‘‘‘str’’’ 可以进行换行操作, 示例如上. str 字符串类型的运算 字符串之间可以相加 a = \"my\" b = \"name\" print(a+b) # 输出结果为 myname # 注, 字符串相加的底层操作是: - 先申请一个新的内存空间 - 将两个字符串value 拷贝,然后存入到新得内存空间 要尽量避免这种操作, 效率低下. 推荐占位符方法. 字符串可以与整型进行乘法操作 print(\"=\"*20) # 输出结果 ==================== 可以做分割线使用. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:3","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"列表 作用: 用来描述一个事物的同一种特性的不同数据, 例如: 人的爱好 定义: l = [1,2.3,\"hello\",[10,25] # l = list([1,2,3,\"hello\",[10,25]) print(l) # 输出结果 [1,2.3,\"hello\",[10,25] 由示例课件, 列表中的元素可以为整型, 字符串, 浮点数 乃至于一个列表 列表数据的取出,及索引 定义好数据之后,最终的目的是为了使用. 所以 如何正确取出列表中的数据,就变得很重要, 列表数据是按照以\"0\"为起始的下表索引. 具体请看示例 l = [10,22,33,\"hello\",[10,25] # 定义一个列表 print(l[0]) # 输出结果 10 如何取出列表内列表的值? 请看下面例子 students_info= [[\"wxx\",18,\"henan\"],[\"lxx\",24,\"hunan\"]] # 找到第二个人的省份 print(students_info[1][2]) # 输出结果 hunan 由示例可见, 想找到固定信息, 只需要按照索引,一级一级的向下找即可. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:4","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"字典 字典是以key:value 这样成组键值对出现的集合体. 作用 当一个事物有多种的特性, 特性又有多种状态的情况下, 列表已经不能满足我们的需要, 因位列表值得取用是按照列表的位置索引取用, 当数据量很大时, 取出的值并不能看出是属于哪种特性. # 举个栗子. info_evgeny = [\"evgeny\",18,\"man\",\"company\",] # 如上所示, 当想取出 这个人的\"年龄\" 信息时 , 该如何快速取出? # 当然可以用info_evgeny[1] 取出, 看了上面的代码, 我们就会发现一个问题. 这个列表只有四个值, 我们能一眼看出年龄所在列表的位置, 当 这个列表包晗的不仅仅只有这四个, 我们不能一眼看出位置索引时 , 我们应该怎么办? 那么 新的数据类型, 字典 dict 就出现了. 定义 定义列表有两种方式, # 第一种方式 dict1 = {\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"} print(dict1) # 输出结果 {'name': 'evgeny', 'age': 18, 'gender': 'man', 'name_company': 'company'} # 第二种方式 dict2 = dict({\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"}) # 输出结果 {'name': 'evgeny', 'age': 18, 'gender': 'man', 'name_company': 'company'} 使用 当字典中取某个值时, 只需要知道这组值得key, 就可以 dict1 = {\"name\":\"evgeny\",\"age\":18,\"gender\":\"man\",\"name_company\":\"company\"} age = dict1[\"age\"] print(age) # 输出结果 18 ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:5","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"布尔bool 什么是布尔类型, 作用 为了记录真假 这两种状态 定义 is_ok = True is_ok = False 使用 通常用在if while 语句, 用作判断条件. ","date":"2017-02-04","objectID":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:6","tags":["数据类型"],"title":"python 数据类型","uri":"/posts/python-05-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["Python基础"],"content":"格式化输出 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:0:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"什么是格式化输出？ 格式化输出就是将数据按照特定格式输出到屏幕上。 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:1:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"为什么要用格式化输出？ 一个事物有多种特性，当描述一个具体的事物的时候， 用一种特定的格式把此事物描述清楚，就需要用到格式化输出。 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:2:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"格式化输出有哪几种？ ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"1、%的方法 整数的输出 %o ——oct 八进制输出 %d ——dec 十进制输出 %c ——hex 十六进制输出 print(\"%o\" % 24) print(\"%d\" % 24) print(\"%x\" % 24) # 运行结果 30 24 18 # 输入的数字都是以十进制输入的。 浮点数输出 %f ——float 浮点数输出 print(\"%f\" % 25.66666666) # 运行结果 5.666667 默认保留小数后六位 print(\"%.4f\" % 12.333330) # 运行结果 12.3333 # 会根据要保留的后一位进行四舍五入。 %e ——用科学计数法输出。 print(\"%e\" % 1.11111111111) # 运行结果 1.111111e+00 默认保留小说后六位 print(\"%.3e\" % 1.11111111111) # 设置保留虚部位数 # 运行结果 1.111e+00 %g ——— 在保证6位有效数字的前提下， 使用小数计数法。 print(\"%g\" % 111.111111) # 运行结果 111.111 print('%.7g\" % 111.111111) # 取7位有效数字 # 运行结果 111.1111 print(\"%0.2g\" % 111.111111) # 取2位有效数字， 并用转换为科学计数法 # 运行结果 1.1e+02 字符串输出 %s –string 字符串输出 print(\"%s\" % \"hello world\") # 输出结果 hello world %-10s 占10个字符, 并左对齐 print(\"我是:%-10s, 今年18岁\" % \"七里塘\") # 输出结果 我是七里塘 , 今年18岁 %10s – 占用10个字符, 并右对齐 print(\"我是:%10s, 今年18岁\" % \"七里塘\") # 输出结果 我是: 七里塘, 今年18岁 %.2s –取前两个字符 print(\"我是:%.2s, 今年18岁\" % \"七里塘\") # 输出结果 我是:七里, 今年18岁 %10.2s – 取前两个字符,并且占用10个字符空间,向右对齐 print(\"我是:%10.2s, 今年18岁\" % \"七里塘\") # 输出结果 我是: 七里, 今年18岁 字符串格式代码如下 符号 说明 %s 字符串 %c 字符 %d 十进制数 %i 整数 %u 无符号整数 %o 八进制数 %x 十六进制整数 %X 十六进制整数大写 %f 浮点数1 %e 浮点数2 %E 浮点数3 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:1","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"format 方法 相对基本格式化输出采用‘%’的方法，format()功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’ ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:2","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"b.format() print(\"{} {}\".format(\"hello\", \"world\")) # 打印结果 hello world print(\"{} {}\".format(\"world\", \"hello\")) # 打印结果 world hello {0}{1}{2} 有索引位置, 会根据索引位置分别传参. print(\"{1} {0}\".format(\"world\", \"hello\")) # 输出结果 word hello 关键字传参 print(\"我叫{name}, 今年{age}岁\".format(name=\"七里塘\", age = 18)) # 输出结果 我叫七里塘,今年18岁 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:3","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"python3.6 之后新特性 在 字符串前用小写的f 进行生命花括号直接写变量名. print(f\"我叫{name}, 今年{age}岁\") # 输出结果 我叫七里塘,今年18岁 运算符 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:3:4","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"算数运算符 python支持的算数运算符与数学上计算的符号使用是一致的，我们以x=9，y=2为例来依次介绍它们 比较运算符 比较运算用来对两个值进行比较，返回的是布尔值True或False，我们以x=9，y=2为例来依次介绍它们 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:4:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"赋值运算符 python语法中除了有=号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值、解压赋值，这些赋值运算符存在的意义都是为了让我们的代码看起来更加精简。我们以x=9，y=2为例先来介绍一下增量赋值 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:0","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"增量赋值 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:1","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"链式复制 a = b = c = 1 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:2","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"交叉赋值 a = 1 b = 2 a, b = b, a ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:3","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"解压赋值 a, b, c, = [1,2,3] # 输出结果 a = 1 b = 2 c = 3 ","date":"2017-02-03","objectID":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/:5:4","tags":["格式化输出"],"title":"python 变量","uri":"/posts/python-04-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA/"},{"categories":["Python基础"],"content":"变量 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:0","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"什么是变量? 变量指的是现实生活中, 某种事物\"特性\"的某种\"衡量状态\" 变量的核心是\"变\"和\"量\" “变” 指的是,这种特性不是一成不变的 “量” 指的是这种衡量状态 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:1","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"为什么要用变量? 是为了让计算机能够像人一样,记录事物特性的状态,方便以后使用. ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:2","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"变量的使用方法 定义变量的语法 x = 1 “x” : 指的是 变量名 相当于门牌号 “=” : 赋值符号 “1” : 变量值 变量名的命名方式 # 变量名应该能提示能反应出值记录的状态 变量名是以数字、字母，下划线组成 不能以数字开头 不能使用python内置关键字 变量名的命名风格 # 推荐使用下划线 下划线 age_of_oldboy = 78 驼峰 AgeOfOldboy = 78 ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:3","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"定义一个完整变量所具有的特征 id 变量类型 变量值 \u003e\u003e\u003e x = 1 \u003e\u003e\u003e id(x) 26980696 \u003e\u003e\u003e type(x) \u003ctype 'int'\u003e \u003e\u003e\u003e print(x) ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:4","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"小整数池 1、在交互式模式下 Python实现int的时候有个小整数池。为了避免因创建相同的值而重复申请内存空间所带来的效率问题， Python解释器会在启动时创建出小整数池，范围是[-5,256]，该范围内的小整数对象是全局解释器范围内被重复使用，永远不会被GC回收 每创建一个-5到256之间的整数，都是直接从这个池里直接拿走一个值，例如 \u003e\u003e\u003e y=4 \u003e\u003e\u003e id(y) \u003e\u003e\u003e \u003e\u003e\u003e x=3 \u003e\u003e\u003e x+=1 \u003e\u003e\u003e id(x) 2、在pycharm中 但在pycharm中运行python程序，pycharm出于对性能的考虑，会扩大小整数池的范围，其他的字符串等不可变类型也都包含在内一便采用相同的方式处理了，我们只需要记住这是一种优化机制，至于范围到底多大，无需细究 [toc] ","date":"2017-02-02","objectID":"/posts/python-03-%E5%8F%98%E9%87%8F/:1:5","tags":["变量"],"title":"python 变量","uri":"/posts/python-03-%E5%8F%98%E9%87%8F/"},{"categories":["Python基础"],"content":"Python Python是一种跨平台的[计算机程序设计语言]。 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。最初被设计用于编写自动化脚本(shell)，随着版本的不断更新和语言新功能的添加，越多被用于独立的、大型项目的开发。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:0","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"Python简介及应用领域 Python是一种解释型脚本语言，可以应用于以下领域: Web 和 Internet开发 科学计算和统计 人工智能 桌面界面开发 软件开发 后端开发 网络爬虫 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:1","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"发展历程 自从20世纪90年代初Python语言诞生至今，它已被逐渐广泛应用于系统管理任务的处理和Web编程。 Python的创始人为荷兰人吉多·范罗苏姆 [4] （Guido van Rossum）。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，作为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是取自英国20世纪70年代首播的电视喜剧《蒙提.派森的飞行马戏团》（Monty Python’s Flying Circus）。 ABC是由Guido参加设计的一种教学语言。就Guido本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，Guido 认为是其非开放造成的。Guido 决心在Python 中避免这一错误。同时，他还想实现在ABC 中闪现过但未曾实现的东西。 就这样，Python在Guido手中诞生了。可以说，Python是从ABC发展起来，主要受到了Modula-3（另一种相当优美且强大的语言，为小型团体所设计的）的影响。并且结合了[Unix shell](https://baike.baidu.com/item/Unix shell)和C的习惯。 Python [5] 已经成为最受欢迎的程序设计语言之一。自从2004年以后，python的使用率呈线性增长。Python 2于2000年10月16日发布，稳定版本是Python 2.7。Python 3于2008年12月3日发布，不完全兼容Python 2。 [4] 2011年1月，它被TIOBE编程语言排行榜评为2010年度语言。 [6] 由于Python语言的简洁性、易读性以及可扩展性，在国外用Python做科学计算的研究机构日益增多，一些知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学的编程基础、麻省理工学院的计算机科学及编程导论就使用Python语言讲授。众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。而Python专用的科学计算扩 标识 展库就更多了，例如如下3个十分经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。因此Python语言及其众多的扩展库所构成的开发环境十分适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序。2018年3月，该语言作者在邮件列表上宣布Python 2.7将于2020年1月1日终止支持。用户如果想要在这个日期之后继续得到与Python 2.7有关的支持，则需要付费给商业供应商。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:2","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"风格 Python在设计上坚持了清晰划一的风格，这使得Python成为一门易读、易维护，并且被大量用户所欢迎的、用途广泛的语言。 设计者开发时总的指导思想是，对于一个特定的问题，只要有一种最好的方法来解决就好了。这在由Tim Peters写的Python格言（称为The Zen of Python）里面表述为：There should be one– and preferably only one –obvious way to do it. 这正好和Perl语言（另一种功能类似的高级动态语言）的中心思想TMTOWTDI（There’s More Than One Way To Do It）完全相反。 Python的作者有意的设计限制性很强的语法，使得不好的编程习惯（例如if语句的下一行不向右缩进）都不能通过编译。其中很重要的一项就是Python的缩进规则。 一个和其他大多数语言（如C）的区别就是，一个模块的界限，完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号{}来明确的定出模块的边界的，与字符的位置毫无关系）。这一点曾经引起过争议。因为自从C这类的语言诞生后，语言的语法含义与字符的排列方式分离开来，曾经被认为是一种程序语言的进步。不过不可否认的是，通过强制程序员们缩进（包括if，for和函数定义等所有需要使用模块的地方），Python确实使得程序更加清晰和美观。 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:3","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"第一个python程序 要开始写代码了, 好高兴呀…QAQ 运行python程序的两种方式 交互式运行 命令行运行 1 # 打开一个文本编辑工具，写入下述代码，并保存文件，此处文件的路径为D:\\test.py。强调：python解释器执行程序是解释执行，解释的根本就是打开文件读内容，因此文件的后缀名没有硬性限制，但通常定义为.py结尾 print(‘hello world’) -2、打开cmd，运行命令，如下图 注释 “#“在行尾巧两个空格 然后输入# 再加一个空格 写注释内容. print(\"我最牛逼\") # 打印我最牛逼 ’’’ 注释内容’’’/ \"”” 注释内容\"\"\" '''打印我最牛逼''' print(\"我最牛逼\") pycharm 的注释的快捷键是 ctrl+? ps: “““也可以是字符串””” print(''' 我最牛逼! 我是最牛逼的! 我在自我暗示. ''') 两者区别是 \"\"\"\"\"\" 可以换行. 代码的注释是在代码行首加上#和空格, 即这段代码被注释掉 # print(\"注释掉我最牛逼\") # 上一行代码不执行 ","date":"2017-02-02","objectID":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/:1:4","tags":null,"title":"python介绍","uri":"/posts/python-02-python-%E4%BB%8B%E7%BB%8D/"},{"categories":["Python基础"],"content":"一 编程语言分类 上一节已经把计算机基础讲完了, 也接触了编程语言, 那编程语言怎么分类呢? 容我慢慢装逼…. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:0","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.1 机器语言 也就是计算机能看懂的语言? 那是哪种语言呢? 就是01010101010 这种二进制语言. 开发者不仅要考虑自己的程序, 还要考虑如何调动硬件完成程序的运行 所以开发难度极大. 优点: 计算机运行效率高 缺点: 开发难度大. (这玩意儿简直不是人玩的.) 没示例, 想找示例的 自己去找. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:1","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.2 汇编语言 由于机器语言, 编程难度变态, 就有大佬对计算机进行了升级, 用英文标点代表一组二进制指令, 但是并没有从本质解决需要自己考虑如何调动硬件这件事. 所以开发难度依旧很大. 优点: 计算机相对与机器语言 , 开发效率要高 缺点: 运行效率稍微要低于机器语言. 没示例, 想找自己去找吧, 百度一大把. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:2","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.3 高级语言 高级语言就是站在人类角度, 以人类的语言进行编程. 而人类的字符是在向操作系统直接发指令的. 而不是向计算机硬件. 这里的高级指的是,高层, 开发者不必考虑硬件细节, 因而开发效率得到了极大的提升. 1.3.1 编译型语言 如(c 语言) 此类语言类似 谷歌翻译. 就是把程序代码,翻译成计算机能够识别的二进制指令. 优点: 一次编译后, 就可以重复运行,无需再次翻译 缺点: 编译型代码都是针对某平台翻译的, 所以无法直接拿到另外的平台使用, 即 跨平台能力差 1.3.2 解释型语言 解释型语言, 类似同声传译, 解释器会读取程序代码, 一边翻译, 一遍执行. 优点: 代码运行时依赖解释器的, 所以代码可以跨平台运行. 缺点:每次执行代码都需要翻译 ,所以运行效率低. ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:3","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"categories":["Python基础"],"content":"1.4 总结 综上所述: 执行效率: 机器语言\u003e汇编语言\u003e编译型语言\u003e解释型语言 开发效率 解释性语言\u003e编译型语言\u003e汇编语言\u003e机器语言 跨平台性 解释性语言有很强的跨平台性 由于我们开发的是应用程序 而应用程序的运行效率更受限于运行平台. 解释性语言有极强的跨平台性, 所以这是我们选择学习python的原因. [toc] ","date":"2017-02-02","objectID":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/:1:4","tags":["编程语言"],"title":"编程语言","uri":"/posts/python-01-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}]